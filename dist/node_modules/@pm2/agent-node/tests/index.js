/* eslint-env mocha */

'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

process.env.NODE_ENV = 'test';

var Agent = require('../src/index');
var assert = require('assert');
var transport = require('../src/transport');
var createAgent = function createAgent(proc, cb) {
  if (!cb) {
    cb = proc;
    proc = null;
  }
  transport.prototype.connect = function (cb) {
    return cb();
  };
  module.exports = transport;
  var tmp = Agent.prototype.checkCredentials;
  Agent.prototype.checkCredentials = function (config, cb) {
    return cb(null, { ws: 'endpoint' });
  };
  var config = { publicKey: 'public', secretKey: 'secret', appName: 'app' };
  var agent = new Agent(config, proc || {});
  return cb(agent, function (next) {
    Agent.prototype.checkCredentials = tmp;
    agent.destruct();
    next();
  });
};

describe('Agent', function (_) {
  describe('constructor', function (_) {
    it('should return an error with bad configuration', function (done) {
      assert(new Agent() instanceof Error);
      assert(new Agent({}) instanceof Error);
      assert(new Agent({ publicKey: '' }) instanceof Error);
      assert(new Agent({ publicKey: '', secretKey: '' }) instanceof Error);
      assert(new Agent({ publicKey: '', secretKey: '', appName: '' }) instanceof Error);
      assert(new Agent({ publicKey: '', secretKey: '', appName: {}, proc: {} }) instanceof Error);
      assert(new Agent({ publicKey: '', secretKey: '', appName: {}, proc: '' }) instanceof Error);
      return done();
    });
    it('should fail check credentials', function (done) {
      var tmp = Agent.prototype.checkCredentials;
      Agent.prototype.checkCredentials = function (config, cb) {
        return cb(new Error('Test error'));
      };
      var agent = new Agent({ publicKey: 'public', secretKey: 'secret', appName: 'app' }, {});
      assert(!(agent instanceof Error));
      agent.start().then(function (e) {
        console.log(e);
        agent.destruct();
        done(new Error('agent started'));
      }).catch(function (err) {
        agent.destruct();
        assert(err instanceof Error);
        done();
      });
      Agent.prototype.checkCredentials = tmp;
    });
    it('should fail transport connect', function (done) {
      transport.prototype.connect = function (cb) {
        return cb(new Error('Test error'));
      };
      module.exports = transport;
      var tmp = Agent.prototype.checkCredentials;
      Agent.prototype.checkCredentials = function (config, cb) {
        return cb(null, { ws: 'endpoint' });
      };
      var agent = new Agent({ publicKey: 'public', secretKey: 'secret', appName: 'app' }, {});
      assert(!(agent instanceof Error));
      agent.start().then(function (_) {
        agent.destruct();
        done(new Error('correctly connected'));
      }).catch(function (err) {
        agent.destruct();
        assert(err instanceof Error);
        done();
      });
      Agent.prototype.checkCredentials = tmp;
    });
    it('should save config', function (done) {
      transport.prototype.connect = function (cb) {
        return cb();
      };
      module.exports = transport;
      var tmp = Agent.prototype.checkCredentials;
      Agent.prototype.checkCredentials = function (config, cb) {
        return cb(null, { ws: 'endpoint' });
      };
      var config = { publicKey: 'public', secretKey: 'secret', appName: 'app' };
      var agent = new Agent(config, {});
      assert(!(agent instanceof Error));
      agent.start().then(function (_) {
        assert(agent.transport instanceof transport);
        assert(agent.config.publicKey === config.publicKey);
        assert(agent.config.secretKey === config.secretKey);
        assert(agent.config.appName === config.appName);
        assert(typeof agent.config.internalIp === 'string');
        assert(typeof agent.process.unique_id === 'string');
        clearInterval(agent.statusInterval);
        Agent.prototype.checkCredentials = tmp;
        agent.destruct();
        done();
      }).catch(function (err) {
        done(err);
      });
    });
  });
  describe('generateUniqueId', function (_) {
    it('should return unique id', function (done) {
      var ids = [];
      for (var i = 0; i < 100; i++) {
        var id = Agent.prototype.generateUniqueId();
        assert(!ids.includes(id));
        ids.push(id);
      }
      return done();
    });
  });
  describe('generateProcess', function (_) {
    it('should add created at', function (done) {
      createAgent(function (agent, next) {
        var proc = agent.generateProcess(agent.process);
        assert(proc.pid === process.pid);
        assert(proc.name === agent.config.appName);
        assert(proc.interpreter === 'node');
        assert(proc.restart_time === 0);
        assert(typeof proc.created_at === 'number');
        assert(proc.exec_mode === 'fork_mode');
        assert(proc.watching === false);
        assert(typeof proc.pm_uptime === 'number');
        assert(proc.status === 'online');
        assert(proc.pm_id === 0);
        assert(proc.unique_id === agent.process.unique_id);
        assert(typeof proc.cpu === 'number');
        assert(typeof proc.memory === 'number');
        assert(proc.versioning === null);
        assert(proc.node_env === 'test');
        assert(Array.isArray(proc.axm_actions));
        assert(_typeof(proc.axm_monitor) === 'object');
        assert(_typeof(proc.axm_options) === 'object');
        assert(_typeof(proc.axm_dynamic) === 'object');
        return next(done);
      });
    });
    it('should return process with new axm action', function (done) {
      var configProc = {
        axm_actions: [{ action_type: 'pm2', action_name: 'test' }]
      };
      createAgent(configProc, function (agent, next) {
        var proc = agent.generateProcess(agent.process);
        assert(proc.axm_actions[0].action_name === 'test');
        return next(done);
      });
    });
  });
  describe('listenForLogs', function (_) {
    var config = { publicKey: 'public', secretKey: 'secret', appName: 'app' };
    it('should send stdout logs', function (done) {
      var agent = new Agent(config, {});
      agent.sendLogs = true;
      agent.send = function (channel, data) {
        assert(channel === 'logs');
        assert(data.data === 'log line\n');
        agent.destruct();
        return done();
      };
      agent.listenForLogs();
      console.log('log line');
    });
    it('should send stderr logs', function (done) {
      var agent = new Agent(config, {});
      agent.sendLogs = true;
      agent.send = function (channel, data) {
        assert(channel === 'logs');
        assert(data.data === 'log line\n');
        agent.destruct();
        return done();
      };
      agent.listenForLogs();
      console.error('log line');
    });
    it("shouldn't send logs", function (done) {
      var agent = new Agent(config, {});
      agent.sendLogs = false;
      agent.send = function (channel, data) {
        assert(false);
      };
      agent.listenForLogs();
      console.log('log line');
      setTimeout(function (_) {
        agent.destruct();
        return done();
      }, 1000);
    });
    it("shouldn't send unmatched logs", function (done) {
      var agent = new Agent(Object.assign({ logFilter: 'unmatch' }, config), {});
      agent.sendLogs = true;
      agent.send = function (channel, data) {
        assert(false);
      };
      agent.listenForLogs();
      console.log('log line');
      setTimeout(function (_) {
        agent.destruct();
        return done();
      }, 1000);
    });
    it("shouldn't send unmatched logs", function (done) {
      var agent = new Agent(Object.assign({ logFilter: 'unmatch' }, config), {});
      agent.sendLogs = true;
      agent.send = function (channel, data) {
        assert(false);
      };
      agent.listenForLogs();
      console.error('log line');
      setTimeout(function (_) {
        agent.destruct();
        return done();
      }, 1000);
    });
    it('should send matched logs', function (done) {
      var agent = new Agent(Object.assign({ logFilter: 'log' }, config), {});
      agent.sendLogs = true;
      agent.send = function (channel, data) {
        assert(channel === 'logs');
        assert(data.data === 'log line\n');
        agent.destruct();
        return done();
      };
      agent.listenForLogs();
      console.log('log line');
    });
    it('should send matched logs', function (done) {
      var agent = new Agent(Object.assign({ logFilter: 'log' }, config), {});
      agent.sendLogs = true;
      agent.send = function (channel, data) {
        assert(channel === 'logs');
        assert(data.data === 'log line\n');
        agent.destruct();
        return done();
      };
      agent.listenForLogs();
      console.error('log line');
    });
  });
});
//# sourceMappingURL=index.js.map