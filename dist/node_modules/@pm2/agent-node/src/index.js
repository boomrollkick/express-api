'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = require('debug')('agent:main');
var os = require('os');
var http = require('./utils/http');
var cst = require('../constants');
var meta = require('./utils/meta');
var version = require('../package.json').version;
var Transport = require('./transport');

module.exports = function () {
  /**
   * Init new agent
   * @param {Object} config Configuration
   * @param {String} config.publicKey
   * @param {String} config.secretKey
   * @param {String} config.appName
   * @param {String} [config.serverName] Will be hostname if not provided
   * @param {String} [config.logFilter] RegExp used to filter logs
   * @param {Object} process Process to send
   */
  function Agent(config, proc) {
    _classCallCheck(this, Agent);

    // Valid config
    if (!config || typeof config.publicKey !== 'string' || typeof config.secretKey !== 'string' || typeof config.appName !== 'string' || typeof config.proxy !== 'undefined' && config.proxy !== 'string' || (typeof proc === 'undefined' ? 'undefined' : _typeof(proc)) !== 'object') {
      var err = new Error('You need to provide a valid configuration and process!');
      return err;
    }
    debug('New agent constructed with: [public: ' + config.publicKey + ', secret: ' + config.secretKey + ', app: ' + config.appName + ']');
    if (!config.serverName) config.serverName = os.hostname().toLowerCase();
    this.config = config;
    if (this.config.logFilter && !(this.config.logFilter instanceof RegExp)) {
      this.config.logFilter = new RegExp(this.config.logFilter);
    }
    proc.unique_id = this.generateUniqueId();
    this.process = proc;
    this.sendLogs = false; // Options to override startLogging and stopLogging
    this.methods = { // Used to destruct
      processOutWrite: process.stdout.write,
      processErrWrite: process.stderr.write
      // Init transport (listen event emitter even if an error occur)
    };this.transport = new Transport();
  }

  /**
   * Used to destruct agent
   */


  _createClass(Agent, [{
    key: 'destruct',
    value: function destruct() {
      this.stop();
      process.stdout.write = this.methods.processOutWrite;
      process.stderr.write = this.methods.processErrWrite;
    }

    /**
     * Check credentials and start agent
     */

  }, {
    key: 'start',
    value: function start() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (_this.isStopping) return reject(new Error('Agent is stopping'));

        // Trying to check infos
        _this.checkCredentials(_this.config, function (err, endpoints) {
          if (err) {
            _this.restartOnError(err);
            return reject(err);
          }

          // Connect to websocket
          _this.transport.setConfig(endpoints.ws, {
            'X-KM-PUBLIC': _this.config.publicKey,
            'X-KM-SECRET': _this.config.secretKey,
            'X-KM-SERVER': _this.config.serverName,
            'X-PM2-VERSION': cst.PM2_VERSION,
            'X-PROTOCOL-VERSION': cst.PROTOCOL_VERSION,
            'User-Agent': 'PM2 Agent Node v' + version
          }, _this.config.proxy);
          return _this.transport.connect(function (err) {
            if (err) {
              _this.restartOnError(err);
              return reject(err);
            }

            // Store config
            _this.config.endpoint = endpoints.ws;
            _this.config.internalIp = meta.computeInternalIp();

            // Start sending status
            _this.statusInterval = setInterval(_this.sendStatus.bind(_this), 1 * 1000); // each second
            _this.listenForLogs();

            // Listening for endpoint update
            _this.endpointUpdateInterval = setInterval(_this.listenEndpointUpdate.bind(_this), 5 * 60 * 1000); // each 5 min

            return resolve();
          });
        });
      });
    }

    /**
     * Restart agent because of an error
     */

  }, {
    key: 'restartOnError',
    value: function restartOnError(err) {
      var _this2 = this;

      if (this.isStopping) return;

      debug('Got an error on start pm2-agent-node: ' + err.message + ', retrying in 5sec...');
      return setTimeout(function () {
        // Error already handled in start function
        _this2.start().catch(function (_) {});
      }, 5 * 1000);
    }

    /**
     * Generate an unique ID
     */

  }, {
    key: 'generateUniqueId',
    value: function generateUniqueId() {
      var s = [];
      var hexDigits = '0123456789abcdef';
      for (var i = 0; i < 36; i++) {
        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);
      }
      s[14] = '4';
      s[19] = hexDigits.substr(s[19] & 0x3 | 0x8, 1);
      s[8] = s[13] = s[18] = s[23] = '-';
      return s.join('');
    }

    /**
     * Used to generate valid a process
     * @param {Object} process
     * @return {Object} process Valid process with default value
     */

  }, {
    key: 'generateProcess',
    value: function generateProcess(proc) {
      if (!proc.createdAt) proc.createdAt = new Date().getTime();
      return {
        pid: process.pid,
        name: this.config.appName,
        interpreter: proc.interpreter || 'node',
        restart_time: 0,
        created_at: proc.createdAt,
        exec_mode: 'fork_mode',
        watching: false,
        pm_uptime: proc.createdAt,
        status: 'online',
        pm_id: 0,
        unique_id: proc.unique_id,

        cpu: meta.getCpuUsage(),
        memory: meta.getMemoryUsage(),

        versioning: proc.versioning || null,

        node_env: process.env.NODE_ENV || null,

        axm_actions: proc.axm_actions || [],
        axm_monitor: proc.axm_monitor || {},
        axm_options: proc.axm_options || {},
        axm_dynamic: proc.dynamic || {}
      };
    }

    /**
     * Ping root.keymetrics.io, compare current endpoint, and reconnect agent if needed
     */

  }, {
    key: 'listenEndpointUpdate',
    value: function listenEndpointUpdate() {
      var _this3 = this;

      debug('Check if endpoint was updated');
      this.checkCredentials(this.config, function (err, endpoints) {
        if (err) return debug('Got an error on check credentials: ' + err.message);
        if (endpoints.ws === _this3.config.endpoint) return debug('Endpoint wasn\'t updated');

        // Update transport endpoint
        _this3.config.endpoint = endpoints.ws;
        _this3.transport.endpoint = endpoints.ws;
        _this3.transport.disconnect();
        _this3.transport.connect(function (err) {
          if (err) return debug('Got an error on websocket connection while endpoint update: ' + err.message);
          return debug('Websocket endpoint updated!');
        });
      });
    }

    /**
     * Check credentials with API
     * @param {Object} config Configuration
     * @param {String} config.publicKey
     * @param {String} config.secretKey
     * @param {String} config.appName
     * @param {Function} cb Invoked with <err, endpoints>
     */

  }, {
    key: 'checkCredentials',
    value: function checkCredentials(config, cb) {
      http.open({
        url: cst.ROOT_URL + '/api/node/verifyPM2',
        method: 'POST',
        data: {
          public_id: config.publicKey,
          private_id: config.secretKey,
          data: meta(config.publicKey, config.serverName)
        },
        proxy: config.proxy,
        headers: {
          'User-Agent': 'PM2 Agent Node v' + version
        }
      }, function (err, data) {
        if (err) return cb(err);
        if (data.disabled === true || data.pending === true) return cb(new Error('Interactor disabled.'));
        if (data.active === false) return cb(new Error('Interactor not active.'));
        if (!data.endpoints) return cb(new Error('Endpoints field not present (' + JSON.stringify(data) + ').'));
        return cb(null, data.endpoints);
      });
    }

    /**
     * Send status
     * @param {String} channel
     * @param {Object} payload
     */

  }, {
    key: 'send',
    value: function send(channel, payload) {
      return this.transport.send({
        channel: channel,
        payload: Object.assign(payload, {
          process: {
            pm_id: 0,
            name: this.config.appName,
            server: this.config.serverName,
            rev: null
          }
        })
      });
    }

    /**
     * Listen stdout and stderr to send logs
     */

  }, {
    key: 'listenForLogs',
    value: function listenForLogs() {
      var _this4 = this;

      var send = this.send.bind(this, 'logs');
      var sendLogs = false; // used for startLogging and stopLogging

      // Listen actions
      var reply = function reply(method) {
        _this4.transport.send({
          channel: 'trigger:pm2:result',
          payload: {
            ret: { err: null, data: 'Log streaming ' + (sendLogs ? 'enabled' : 'disabled') },
            meta: {
              method_name: method,
              app_name: _this4.config.appName,
              machine_name: _this4.config.serverName,
              public_key: _this4.config.publicKey
            }
          }
        });
      };
      this.transport.on('trigger:pm2:action', function (data) {
        var method = data.method_name;
        if (!['startLogging', 'stopLogging'].includes(method)) return; // Don't listen that
        sendLogs = method === 'startLogging';
        debug(method + ' triggered');
        return reply(method);
      });

      // Listen logs
      var self = this;
      process.stdout.write = function (write) {
        return function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          write.apply(process.stdout, args);
          if (!self.sendLogs && !sendLogs) return; // Don't send logs
          if (self.config.logFilter && !self.config.logFilter.test(args[0])) return;
          send({
            at: new Date().getTime(),
            data: args[0]
          });
        };
      }(process.stdout.write);

      process.stderr.write = function (write) {
        return function () {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          write.apply(process.stderr, args);
          if (!self.sendLogs && !sendLogs) return; // Don't send logs
          if (self.config.logFilter && !self.config.logFilter.test(args[0])) return;
          send({
            at: new Date().getTime(),
            data: args[0]
          });
        };
      }(process.stderr.write);
    }

    /**
     * Send status
     */

  }, {
    key: 'sendStatus',
    value: function sendStatus() {
      return this.transport.send({
        channel: 'status',
        payload: {
          data: {
            process: [this.generateProcess(this.process)],
            server: meta.getServerMeta()
          },
          server_name: this.config.serverName,
          internal_ip: this.config.internalIp,
          rev_con: true
        }
      });
    }

    /**
     * Stop agent
     */

  }, {
    key: 'stop',
    value: function stop() {
      debug('Stopping agent');
      this.isStopping = true;
      this.transport.disconnect();
      clearInterval(this.statusInterval);
      clearInterval(this.endpointUpdateInterval);
    }
  }]);

  return Agent;
}();
//# sourceMappingURL=index.js.map