'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WebSocket = require('ws');
var EventEmitter2 = require('eventemitter2').EventEmitter2;
var ProxyAgent = require('proxy-agent');
var debug = require('debug')('agent:transport');

module.exports = function (_EventEmitter) {
  _inherits(WebsocketTransport, _EventEmitter);

  /**
   * Construct new websocket instance for specific endpoint
   */
  function WebsocketTransport() {
    _classCallCheck(this, WebsocketTransport);

    var _this = _possibleConstructorReturn(this, (WebsocketTransport.__proto__ || Object.getPrototypeOf(WebsocketTransport)).call(this, {
      wildcard: true,
      delimiter: ':'
    }));

    _this.endpoint = null;
    _this.headers = null;
    _this.ws = null;
    _this.pingInterval = null;
    _this.buffer = [];
    _this.maxBufferLength = 100000;
    return _this;
  }

  /**
   * Set config for instance
   * @param {Object} headers Key-value with upgrade headers
   * @param {String} endpoint Websocket endpoint
   * @param {String} proxy Proxy
   */


  _createClass(WebsocketTransport, [{
    key: 'setConfig',
    value: function setConfig(endpoint, headers, proxy) {
      debug('Init new websocket transport with endpoint: ' + endpoint + ' and headers: [' + Object.keys(headers).map(function (header) {
        return header + ': ' + headers[header];
      }).join(',') + ']');
      this.endpoint = endpoint;
      this.headers = headers;
      this.proxy = proxy;
    }

    /**
     * Connect to websocket server
     * @param {Function} cb Invoked with <err, ws>
     */

  }, {
    key: 'connect',
    value: function connect(cb) {
      var _this2 = this;

      debug('Connect transporter to websocket server');

      try {
        this.ws = new WebSocket(this.endpoint, {
          perMessageDeflate: false,
          handshakeTimeout: 5 * 1000, // 5 seconds
          headers: this.headers,
          agent: typeof this.proxy !== 'undefined' ? new ProxyAgent(this.proxy) : undefined
        });
      } catch (e) {
        return cb(e);
      }

      var onError = function onError(err) {
        _this2.ws.removeAllListeners();
        return cb(err);
      };
      this.ws.once('error', onError);
      this.ws.once('open', function (_) {
        debug('Websocket connected');
        _this2.ws.removeListener('error', onError);
        _this2.ws.on('close', _this2.onClose.bind(_this2));
        // We don't handle errors (DNS issues...), ping will close/reopen if any error is found
        _this2.ws.on('error', function (err) {
          return debug('Got an error with websocket connection: ' + err.message);
        });
        if (_this2.pingInterval) clearInterval(_this2.pingInterval);
        _this2.pingInterval = setInterval(_this2.ping.bind(_this2), 30 * 1000); // 30 seconds
        _this2.clearBuffer();
        return cb(null, _this2.ws);
      });
      this.ws.on('ping', function (_) {
        debug('Received ping! Pong sended!');
        _this2.ws.pong();
      });
      this.ws.on('message', this.onMessage.bind(this));
    }

    /**
     * When websocket connection is closed, try to reconnect
     */

  }, {
    key: 'onClose',
    value: function onClose() {
      debug('Websocket connection is closed, try to reconnect');
      this.ws.terminate();
      this.ws.removeAllListeners();
      return this.connect(function (err) {
        return debug(err ? 'Got an error on websocket connection: ' + err.message : 'Websocket connection successfuly reconnected');
      });
    }

    /**
     * Send to listeners
     * @param {String} rawData
     */

  }, {
    key: 'onMessage',
    value: function onMessage(rawData) {
      var data = null;
      try {
        data = JSON.parse(rawData);
      } catch (e) {
        return debug('Get non-JSON data from websocket server: ' + rawData);
      }
      if (!data.channel || !data.payload) return debug('Get bad message from websocket server: ' + rawData);
      return this.emit(data.channel, data.payload);
    }

    /**
     * Try to ping server, if we get no response, disconnect and try to reconnect
     */

  }, {
    key: 'ping',
    value: function ping() {
      var _this3 = this;

      if (!this.isConnected()) return;
      var noResponse = function noResponse(_) {
        clearTimeout(timeout);
        debug('We can\'t get any response to ping from websocket server, trying to reconnect');
        _this3.ws.terminate();
        return _this3.connect(function (err) {
          return debug(err ? 'Got an error on websocket connection: ' + err.message : 'Websocket connection successfuly reconnected');
        });
      };
      var timeout = setTimeout(noResponse.bind(this), 5 * 1000); // 5 seconds timeout

      this.ws.ping(function (err) {
        if (err) return noResponse();
        return debug('Successfuly sended a ping!');
      });
      this.ws.on('pong', function (_) {
        clearTimeout(timeout);
        _this3.ws.removeEventListener('pong');
        return debug('Websocket server has replied to ping!');
      });
    }

    /**
     * Send data to websocket server
     * @param {Object} packet Packet to send (send with JSON)
     * @return {Boolean} success
     */

  }, {
    key: 'send',
    value: function send(packet) {
      if (!packet.channel || !packet.payload) return false;
      if (!this.isConnected()) {
        this.bufferPacket(packet);
        return false;
      }
      try {
        this.ws.send(JSON.stringify(packet));
      } catch (err) {
        debug('Failed to send packet: ' + err.message);
        console.log(err);
        this.bufferPacket(packet);
        return false;
      }
      return true;
    }

    /**
     * Packet couldn't be send, so buffer it into an array
     * @param {Object} packet Packet to send (send with JSON)
     */

  }, {
    key: 'bufferPacket',
    value: function bufferPacket(packet) {
      if (this.buffer.length > this.maxBufferLength) this.buffer.pop();
      this.buffer.push(packet);
    }

    /**
     * Send every packet stored in buffer
     */

  }, {
    key: 'clearBuffer',
    value: function clearBuffer() {
      this.buffer.forEach(this.send.bind(this));
    }

    /**
     * Disconnect from websocket server
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      debug('Disconnect from websocket server');
      if (this.pingInterval) clearInterval(this.pingInterval);
      if (this.ws) {
        this.ws.removeAllListeners('close');
        this.ws.removeAllListeners('error');
        return this.ws.close();
      }
    }

    /**
     * Return if websocket is connected or not
     */

  }, {
    key: 'isConnected',
    value: function isConnected() {
      return this.ws && this.ws.readyState < 2; // Connected or connecting
    }
  }]);

  return WebsocketTransport;
}(EventEmitter2);
//# sourceMappingURL=transport.js.map