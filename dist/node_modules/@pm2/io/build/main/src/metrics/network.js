"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var netModule = require("net");
var metricConfig_1 = require("../utils/metricConfig");
var debug_1 = require("debug");
var debug = debug_1.default('axm:network');

var NetworkMetric = function () {
    function NetworkMetric(metricFeature) {
        _classCallCheck(this, NetworkMetric);

        this.defaultConf = {
            ports: false,
            traffic: true
        };
        this.metricFeature = metricFeature;
    }

    _createClass(NetworkMetric, [{
        key: "init",
        value: function init(config) {
            config = metricConfig_1.default.getConfig(config, this.defaultConf);
            if (config.traffic) {
                this.catchTraffic(config.traffic);
            }
            if (config.ports) {
                this.catchPorts();
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            clearTimeout(this.timer);
            debug('NetworkMetric destroyed !');
        }
    }, {
        key: "catchPorts",
        value: function catchPorts() {
            var portsList = [];
            var openedPorts = 'N/A';
            this.metricFeature.metric({
                name: 'Open ports',
                type: 'internal/network/open-ports',
                value: function value() {
                    return openedPorts;
                }
            });
            var originalListen = netModule.Server.prototype.listen;
            netModule.Server.prototype.listen = function () {
                var port = parseInt(arguments[0], 10);
                if (!isNaN(port) && portsList.indexOf(port) === -1) {
                    portsList.push(port);
                    openedPorts = portsList.sort().join();
                }
                this.once('close', function () {
                    if (portsList.indexOf(port) > -1) {
                        portsList.splice(portsList.indexOf(port), 1);
                        openedPorts = portsList.sort().join();
                    }
                });
                return originalListen.apply(this, arguments);
            };
        }
    }, {
        key: "catchTraffic",
        value: function catchTraffic(config) {
            var download = 0;
            var upload = 0;
            var up = '0 B/sec';
            var down = '0 B/sec';
            var filter = function filter(bytes) {
                var toFixed = 0;
                if (bytes < 1024) {
                    toFixed = 6;
                } else if (bytes < 1024 * 1024) {
                    toFixed = 3;
                } else if (bytes !== 0) {
                    toFixed = 2;
                }
                bytes = (bytes / (1024 * 1024)).toFixed(toFixed);
                var cutZeros = 0;
                for (var i = bytes.length - 1; i > 0; --i) {
                    if (bytes[i] === '.') {
                        ++cutZeros;
                        break;
                    }
                    if (bytes[i] !== '0') break;
                    ++cutZeros;
                }
                if (cutZeros > 0) {
                    bytes = bytes.slice(0, -cutZeros);
                }
                return bytes + ' MB/s';
            };
            var interval = setInterval(function () {
                up = filter(upload);
                down = filter(download);
                upload = 0;
                download = 0;
            }, 999);
            interval.unref();
            if (config === true || config.download === true) {
                this.metricFeature.metric({
                    name: 'Network In',
                    type: 'internal/network/in',
                    agg_type: 'sum',
                    value: function value() {
                        return down;
                    }
                });
            }
            if (config === true || config.upload === true) {
                this.metricFeature.metric({
                    name: 'Network Out',
                    type: 'internal/network/out',
                    agg_type: 'sum',
                    value: function value() {
                        return up;
                    }
                });
            }
            if (config === true || config.upload === true) {
                var originalWrite = netModule.Socket.prototype.write;
                netModule.Socket.prototype.write = function (data) {
                    if (data.length) {
                        upload += data.length;
                    }
                    return originalWrite.apply(this, arguments);
                };
            }
            if (config === true || config.download === true || Number.isInteger(config.download)) {
                var delay = Number.isInteger(config.download) ? config.download : 500;
                this.timer = setTimeout(function () {
                    var originalRead = netModule.Socket.prototype.read;
                    netModule.Socket.prototype.read = function () {
                        if (!this.monitored) {
                            this.monitored = true;
                            this.on('data', function (data) {
                                if (data.length) {
                                    download += data.length;
                                }
                            });
                        }
                        return originalRead.apply(this, arguments);
                    };
                }, delay);
                this.timer.unref();
            }
        }
    }]);

    return NetworkMetric;
}();

exports.default = NetworkMetric;
//# sourceMappingURL=network.js.map