"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });

var DeepMetricsTracer = function () {
    function DeepMetricsTracer(metricFeature, tracer, eventName) {
        _classCallCheck(this, DeepMetricsTracer);

        this.allMetrics = {
            http: {
                histogram: {
                    name: 'HTTP: Response time',
                    type: 'internal/http/inbound/latency',
                    measurement: 'mean',
                    unit: 'ms'
                },
                meter: {
                    name: 'HTTP: Throughput',
                    samples: 60,
                    type: 'internal/http/inbound/throughput',
                    unit: 'req/min'
                }
            },
            https: {
                histogram: {
                    name: 'HTTPS: Response time',
                    type: 'internal/https/inbound/latency',
                    measurement: 'mean',
                    unit: 'ms'
                },
                meter: {
                    name: 'HTTPS: Throughput',
                    samples: 60,
                    type: 'internal/https/inbound/throughput',
                    unit: 'req/min'
                }
            },
            'http-outbound': {
                histogram: {
                    name: 'HTTP out: Response time',
                    type: 'internal/http/outbound/latency',
                    measurement: 'mean',
                    unit: 'ms'
                },
                meter: {
                    name: 'HTTP out: Throughput',
                    samples: 60,
                    type: 'internal/http/outbound/throughput',
                    unit: 'req/min'
                }
            },
            'https-outbound': {
                histogram: {
                    name: 'HTTPS out: Response time',
                    type: 'internal/https/outbound/latency',
                    measurement: 'mean',
                    unit: 'ms'
                },
                meter: {
                    name: 'HTTPS out: Throughput',
                    samples: 60,
                    type: 'internal/https/outbound/throughput',
                    unit: 'req/min'
                }
            },
            mysql: {
                histogram: {
                    name: 'MYSQL: Response time',
                    type: 'internal/mysql/latency',
                    measurement: 'mean',
                    unit: 'ms'
                },
                meter: {
                    name: 'MYSQL: Throughput',
                    samples: 60,
                    type: 'internal/mysql/throughput',
                    unit: 'req/min'
                }
            },
            mongo: {
                histogram: {
                    name: 'Mongo: Response time',
                    type: 'internal/mongodb/latency',
                    measurement: 'mean',
                    unit: 'ms'
                },
                meter: {
                    name: 'Mongo: Throughput',
                    samples: 60,
                    type: 'internal/mongodb/throughput',
                    unit: 'req/min'
                }
            },
            mqtt: {
                histogram: {
                    name: 'MQTT: Response time',
                    type: 'internal/mqtt/latency',
                    measurement: 'mean',
                    unit: 'ms'
                },
                meter: {
                    name: 'MQTT: Throughput',
                    samples: 60,
                    type: 'internal/mqtt/throughput',
                    unit: 'req/min'
                }
            },
            socketio: {
                histogram: {
                    name: 'WS: Response time',
                    type: 'internal/socketio/latency',
                    measurement: 'mean',
                    unit: 'ms'
                },
                meter: {
                    name: 'WS: Throughput',
                    samples: 60,
                    type: 'internal/socketio/throughput',
                    unit: 'req/min'
                }
            },
            redis: {
                histogram: {
                    name: 'Redis: Response time',
                    type: 'internal/redis/latency',
                    measurement: 'mean',
                    unit: 'ms'
                },
                meter: {
                    name: 'Redis: Throughput',
                    samples: 60,
                    type: 'internal/redis/throughput',
                    unit: 'req/min'
                }
            }
        };
        this.metricFeature = metricFeature;
        this.tracer = tracer;
        this.eventName = eventName;
        this.listenerFunc = this.listener.bind(this);
    }

    _createClass(DeepMetricsTracer, [{
        key: "init",
        value: function init() {
            this.tracer.on(this.eventName, this.listenerFunc);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.tracer.removeListener(this.eventName, this.listenerFunc);
        }
    }, {
        key: "listener",
        value: function listener(data) {
            if (!this.latency) {
                this.latency = this.metricFeature.histogram(this.allMetrics[this.eventName].histogram);
            }
            if (!this.throughput) {
                this.throughput = this.metricFeature.meter(this.allMetrics[this.eventName].meter);
            }
            data = JSON.parse(data);
            this.throughput.mark();
            if (data.duration) {
                this.latency.update(data.duration);
            }
        }
    }]);

    return DeepMetricsTracer;
}();

exports.default = DeepMetricsTracer;
//# sourceMappingURL=deepMetricsTracer.js.map