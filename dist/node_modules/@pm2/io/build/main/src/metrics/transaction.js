"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var util = require("util");
var proxy_1 = require("../utils/proxy");
var httpWrapper_1 = require("../wrapper/httpWrapper");
var debug_1 = require("debug");
var debug = debug_1.default('axm:tracing');
var configuration_1 = require("../configuration");
var metricConfig_1 = require("../utils/metricConfig");
var serviceManager_1 = require("../serviceManager");

var Transaction = function () {
    function Transaction(metricFeature) {
        _classCallCheck(this, Transaction);

        this.defaultConf = {
            http: true
        };
        this.metricFeature = metricFeature;
        serviceManager_1.ServiceManager.set('wrapper', {});
    }

    _createClass(Transaction, [{
        key: "init",
        value: function init(config) {
            config = metricConfig_1.default.getConfig(config, this.defaultConf);
            if (config.http) {
                var opts = _typeof(config.http) === 'object' ? config.http : {};
                this.http(opts);
            }
            if (config.tracing) {
                var _opts = _typeof(config.tracing) === 'object' ? config.tracing : {};
                this.tracing(_opts);
            }
        }
    }, {
        key: "destroy",
        value: function destroy() {
            debug('Transaction destroyed !');
        }
    }, {
        key: "tracing",
        value: function tracing(opts) {
            if (Array.isArray(opts.ignore_routes) && opts.ignore_routes.length > 0) {
                opts.ignoreFilter = { url: opts.ignore_routes };
            }
            // we should never enable tracing agent two time
            if (require('vxx').get().isActive()) return;
            this.tracer = require('vxx').start(opts);
            configuration_1.default.configureModule({
                tracing_enabled: true
            });
            // broadcast to pm2 aggregator
            this.tracer.getBus().on('transaction', function (data) {
                serviceManager_1.ServiceManager.get('transport').send('axm:trace', data);
            });
        }
    }, {
        key: "http",
        value: function http(opts) {
            var Module = require('module');
            debug('Wrapping HTTP routes');
            if (Array.isArray(opts)) {
                var routes = JSON.parse(JSON.stringify(opts));
                opts = {
                    http: true,
                    http_latency: 200,
                    http_code: 500,
                    ignore_routes: routes
                };
            }
            opts = util['_extend']({
                http: true,
                http_latency: 200,
                http_code: 500,
                ignore_routes: []
            }, opts);
            var self = this;
            proxy_1.default.wrap(Module, '_load', function (load) {
                if (load.__axm_original) {
                    debug('HTTP routes have already been wrapped before');
                    configuration_1.default.configureModule({
                        latency: opts.http
                    });
                    if (opts.http === false) {
                        return function (file) {
                            return load.__axm_original.apply(this, arguments);
                        };
                    } else {
                        return function (file) {
                            if (file === 'http' || file === 'https') {
                                // initialize transaction metrics only once
                                if (!serviceManager_1.ServiceManager.get('wrapper')[file]) {
                                    opts.name = file;
                                    serviceManager_1.ServiceManager.get('wrapper')[file] = new httpWrapper_1.default(self.metricFeature).init(opts, load.__axm_original.apply(this, arguments));
                                }
                                return serviceManager_1.ServiceManager.get('wrapper')[file];
                            } else {
                                return load.__axm_original.apply(this, arguments);
                            }
                        };
                    }
                }
                return function (file) {
                    if (opts.http && (file === 'http' || file === 'https')) {
                        debug('http module being required');
                        configuration_1.default.configureModule({
                            latency: true
                        });
                        // initialize transaction metrics only once
                        if (!serviceManager_1.ServiceManager.get('wrapper')[file]) {
                            opts.name = file;
                            serviceManager_1.ServiceManager.get('wrapper')[file] = new httpWrapper_1.default(self.metricFeature).init(opts, load.apply(this, arguments));
                        }
                        return serviceManager_1.ServiceManager.get('wrapper')[file];
                    } else {
                        return load.apply(this, arguments);
                    }
                };
            });
        }
    }]);

    return Transaction;
}();

exports.default = Transaction;
//# sourceMappingURL=transaction.js.map