"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var util = require("util");
var semver = require("semver");
var json_1 = require("../utils/json");
var configuration_1 = require("../configuration");
var serviceManager_1 = require("../serviceManager");
var debug_1 = require("debug");
var debug = debug_1.default('axm:notify');

var NotifyOptions = function NotifyOptions() {
    _classCallCheck(this, NotifyOptions);
};

exports.NotifyOptions = NotifyOptions;
exports.NotifyOptionsDefault = {
    level: 'info',
    catchExceptions: true
};

var NotifyFeature = function () {
    function NotifyFeature() {
        _classCallCheck(this, NotifyFeature);

        this.options = exports.NotifyOptionsDefault;
        this.levels = ['fatal', 'error', 'warn', 'info', 'debug', 'trace'];
    }

    _createClass(NotifyFeature, [{
        key: "init",
        value: function init(options) {
            if (options) {
                this.options = options;
            }
            configuration_1.default.configureModule({
                error: true
            });
            if (process.env.CATCH_CONTEXT_ON_ERROR === 'true' && (semver.satisfies(process.version, '< 8.0.0') || semver.satisfies(process.version, '< 10.0.0') && !process.env.FORCE_INSPECTOR)) {
                debug("Inspector is not available on node version " + process.version + " !");
            }
            if (process.env.CATCH_CONTEXT_ON_ERROR === 'true' && semver.satisfies(process.version, '>= 10.0.0') || semver.satisfies(process.version, '>= 8.0.0') && process.env.FORCE_INSPECTOR) {
                debug('Enabling inspector based error reporting');
                var NotifyInspector = require('./notifyInspector').default;
                this.feature = new NotifyInspector();
                this.feature.init(options);
            } else {
                this.catchAll();
            }
            return {
                notifyError: this.notifyError
            };
        }
    }, {
        key: "destroy",
        value: function destroy() {
            if (this.feature) {
                this.feature.destroy();
            }
        }
    }, {
        key: "notifyError",
        value: function notifyError(err, level) {
            if (!(err instanceof Error)) {
                console.trace('[PM2-IO-APM] You should use notify with an Error object');
                return -1;
            }
            if (!level || this.levels.indexOf(level) === -1 && serviceManager_1.ServiceManager.get('transport')) {
                return serviceManager_1.ServiceManager.get('transport').send('process:exception', json_1.default.jsonize(err));
            }
            if (this.levels.indexOf(this.options.level) >= this.levels.indexOf(level) && serviceManager_1.ServiceManager.get('transport')) {
                return serviceManager_1.ServiceManager.get('transport').send('process:exception', json_1.default.jsonize(err));
            }
            return null;
        }
    }, {
        key: "catchAll",
        value: function catchAll(opts) {
            if (opts === undefined) {
                opts = { errors: true };
            }
            if (process.env.exec_mode === 'cluster_mode') {
                return false;
            }
            var self = this;
            function getUncaughtExceptionListener(listener) {
                return function uncaughtListener(err) {
                    var error = err && err.stack ? err.stack : err;
                    if (listener === 'unhandledRejection') {
                        console.log('You have triggered an unhandledRejection, you may have forgotten to catch a Promise rejection:');
                    }
                    console.error(error);
                    var errObj = void 0;
                    if (err) {
                        errObj = self._interpretError(err);
                    }
                    if (serviceManager_1.ServiceManager.get('transport')) {
                        serviceManager_1.ServiceManager.get('transport').send('process:exception', errObj !== undefined ? errObj : { message: 'No error but ' + listener + ' was caught!' });
                    }
                    if (!process.listeners(listener).filter(function (listener) {
                        return listener !== uncaughtListener;
                    }).length) {
                        if (listener === 'uncaughtException') {
                            process.exit(1);
                        }
                    }
                };
            }
            if (opts.errors === true && util.inspect(process.listeners('uncaughtException')).length === 2) {
                process.once('uncaughtException', getUncaughtExceptionListener('uncaughtException'));
                process.once('unhandledRejection', getUncaughtExceptionListener('unhandledRejection'));
            } else if (opts.errors === false && util.inspect(process.listeners('uncaughtException')).length !== 2) {
                process.removeAllListeners('uncaughtException');
                process.removeAllListeners('unhandledRejection');
            }
        }
    }, {
        key: "expressErrorHandler",
        value: function expressErrorHandler() {
            configuration_1.default.configureModule({
                error: true
            });
            return function errorHandler(err, req, res, next) {
                if (res.statusCode < 400) res.statusCode = 500;
                err.url = req.url;
                err.component = req.url;
                err.action = req.method;
                err.params = req.body;
                err.session = req.session;
                if (serviceManager_1.ServiceManager.get('transport')) {
                    serviceManager_1.ServiceManager.get('transport').send('process:exception', json_1.default.jsonize(err));
                }
                return next(err);
            };
        }
    }, {
        key: "_interpretError",
        value: function _interpretError(err) {
            var sErr = {
                message: null,
                stack: null
            };
            if (err instanceof Error) {
                // Error object type processing
                sErr = err;
            } else {
                // JSON processing
                sErr.message = err;
                sErr.stack = err;
            }
            return json_1.default.jsonize(sErr);
        }
    }]);

    return NotifyFeature;
}();

exports.NotifyFeature = NotifyFeature;
//# sourceMappingURL=notify.js.map