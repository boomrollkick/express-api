"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var meter_1 = require("../utils/metrics/meter");
var counter_1 = require("../utils/metrics/counter");
var histogram_1 = require("../utils/metrics/histogram");
var serviceManager_1 = require("../serviceManager");
var constants_1 = require("../constants");
var metrics_1 = require("../services/metrics");

var MetricsFeature = function () {
    function MetricsFeature() {
        _classCallCheck(this, MetricsFeature);

        this._var = new Map();
        this.defaultAggregation = 'avg';
        this._started = false;
        this._alreadySentData = [];
        this.AVAILABLE_MEASUREMENTS = ['min', 'max', 'sum', 'count', 'variance', 'mean', 'stddev', 'median', 'p75', 'p95', 'p99', 'p999'];
        this._var = serviceManager_1.ServiceManager.get('metricsMap');
        serviceManager_1.ServiceManager.set('metricService', new metrics_1.default(this));
        this.metricService = serviceManager_1.ServiceManager.get('metricService');
    }

    _createClass(MetricsFeature, [{
        key: "init",
        value: function init(config, force) {
            if (this._started === false) {
                this._started = true;
                var self = this;
                this.timer = setInterval(function () {
                    var data = self._cookData(self._getVar());
                    // don't send empty data
                    if (Object.keys(data).length !== 0 && serviceManager_1.ServiceManager.get('transport')) {
                        serviceManager_1.ServiceManager.get('transport').setMetrics(data);
                    }
                }, constants_1.default.METRIC_INTERVAL);
                this.timer.unref();
            }
            this.metricService.init(config, force);
            return {
                histogram: this.histogram,
                meter: this.meter,
                counter: this.counter,
                metric: this.metric
            };
        }
    }, {
        key: "transpose",
        value: function transpose(variableName, reporter) {
            if ((typeof variableName === "undefined" ? "undefined" : _typeof(variableName)) === 'object') {
                reporter = variableName.data;
                variableName = variableName.name;
            }
            if (typeof reporter !== 'function') {
                console.error('[PM2 IO][Transpose] reporter is not a function');
                return undefined;
            }
            this._var.set(variableName, {
                value: reporter
            });
        }
    }, {
        key: "meter",
        value: function meter(opts) {
            if (!opts.name) {
                console.error('[PM2 IO][Meter] Name not defined');
                return undefined;
            }
            opts.unit = opts.unit || '';
            var meter = new meter_1.default(opts);
            this._var.set(opts.name, {
                value: function value() {
                    return meter.val() + ("" + opts.unit);
                },
                type: opts.type || opts.name,
                historic: this._historicEnabled(opts.historic),
                agg_type: opts.agg_type || this.defaultAggregation,
                unit: opts.unit
            });
            return meter;
        }
    }, {
        key: "counter",
        value: function counter(opts) {
            if (!opts.name) {
                console.error('[PM2 IO][Counter] Name not defined');
                return undefined;
            }
            var counter = new counter_1.default(opts);
            this._var.set(opts.name, {
                value: function value() {
                    return counter.val();
                },
                type: opts.type || opts.name,
                historic: this._historicEnabled(opts.historic),
                agg_type: opts.agg_type || this.defaultAggregation,
                unit: opts.unit
            });
            return counter;
        }
    }, {
        key: "histogram",
        value: function histogram(opts) {
            if (!opts.name) {
                console.error('[PM2 IO][Histogram] Name not defined');
                return undefined;
            }
            opts.measurement = opts.measurement || 'mean';
            opts.unit = opts.unit || '';
            if (this.AVAILABLE_MEASUREMENTS.indexOf(opts.measurement) === -1) {
                console.error('[PM2 IO][Histogram] Measure type %s does not exists', opts.measurement);
                return undefined;
            }
            var histogram = new histogram_1.default(opts);
            this._var.set(opts.name, {
                value: function value() {
                    return Math.round(histogram.val() * 100) / 100 + ("" + opts.unit);
                },
                type: opts.type || opts.name,
                historic: this._historicEnabled(opts.historic),
                agg_type: opts.agg_type || this.defaultAggregation,
                unit: opts.unit
            });
            return histogram;
        }
    }, {
        key: "metric",
        value: function metric(opts) {
            if (!opts.name) {
                console.error('[PM2 IO][Metric] Name not defined');
                return undefined;
            }
            this._var.set(opts.name, {
                value: opts.value || 0,
                type: opts.type || opts.name,
                historic: this._historicEnabled(opts.historic),
                agg_type: opts.agg_type || this.defaultAggregation,
                unit: opts.unit
            });
            var self = this;
            return {
                val: function val() {
                    var value = self._var.get(opts.name).value;
                    if (typeof value === 'function') {
                        value = value();
                    }
                    return value;
                },
                set: function set(dt) {
                    if (self._var.get(opts.name)) self._var.get(opts.name).value = dt;
                }
            };
        }
    }, {
        key: "deleteMetric",
        value: function deleteMetric(name) {
            this._var.delete(name);
            this._alreadySentData.splice(this._alreadySentData.indexOf(name), 1);
        }
    }, {
        key: "destroy",
        value: function destroy() {
            clearInterval(this.timer);
            this._getVar().clear();
            this._started = false;
            this.metricService.destroyAll();
        }
        /** -----------------------------------------
         * Private Methods
         * ------------------------------------------
         */
        /**
         * Check if metric is historic or not
         *
         * @param historic
         * @returns {boolean}
         * @private
         */

    }, {
        key: "_historicEnabled",
        value: function _historicEnabled(historic) {
            if (historic === false) {
                return false;
            }
            if (typeof historic === 'undefined') {
                return true;
            }
            return true;
        }
        /**
         * Only for tests
         *
         * @returns {Object}
         */

    }, {
        key: "_getVar",
        value: function _getVar() {
            return this._var;
        }
        /**
         * Data that will be sent to Keymetrics
         */

    }, {
        key: "_cookData",
        value: function _cookData(data) {
            var cookedData = {};
            var self = this;
            data.forEach(function (probe, probeName) {
                if (typeof data.get(probeName).value === 'undefined') {
                    return false;
                }
                var value = self._getValue(data.get(probeName).value);
                // do not send data if this is always equal to 0
                // probably an initialized metric which is not "active"
                if (self._alreadySentData.indexOf(probeName) === -1 && value !== 0 || self._alreadySentData.indexOf(probeName) > -1) {
                    if (self._alreadySentData.indexOf(probeName) === -1) {
                        self._alreadySentData.push(probeName);
                    }
                    cookedData[probeName] = {
                        value: value
                    };
                    /**
                     * Attach aggregation mode
                     */
                    if (data.get(probeName).agg_type && data.get(probeName).agg_type !== 'none') {
                        cookedData[probeName].agg_type = data.get(probeName).agg_type;
                    }
                    cookedData[probeName].historic = data.get(probeName).historic;
                    cookedData[probeName].type = data.get(probeName).type;
                    cookedData[probeName].unit = data.get(probeName).unit;
                }
            });
            return cookedData;
        }
    }, {
        key: "_getValue",
        value: function _getValue(value) {
            if (typeof value === 'function') {
                return value();
            }
            return value;
        }
    }]);

    return MetricsFeature;
}();

exports.default = MetricsFeature;
//# sourceMappingURL=metrics.js.map