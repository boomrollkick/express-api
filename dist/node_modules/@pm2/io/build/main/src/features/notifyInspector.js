"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var async_1 = require("async");
var json_1 = require("../utils/json");
var serviceManager_1 = require("../serviceManager");

var NotifyInspector = function () {
    function NotifyInspector() {
        _classCallCheck(this, NotifyInspector);

        this.inspectorService = serviceManager_1.ServiceManager.get('inspector');
        this.exceptionsTrapped = [];
    }

    _createClass(NotifyInspector, [{
        key: "init",
        value: function init() {
            this.inspectorService.createSession();
            this.inspectorService.connect();
            this.catchAllDebugger();
        }
    }, {
        key: "destroy",
        value: function destroy() {
            this.inspectorService.disconnect();
        }
    }, {
        key: "trapException",
        value: function trapException(listener) {
            var _this = this;

            return function (error) {
                // log it
                if (listener === 'unhandledRejection') {
                    console.log('You have triggered an unhandledRejection, you may have forgotten to catch a Promise rejection:');
                }
                console.error(error);
                // create object to be send
                var context = _this.exceptionsTrapped.find(function (exception) {
                    return !!exception.error.description.match(error.message);
                });
                error = json_1.default.jsonize(error);
                // inject async stackframe
                if (context && context.asyncStackTrace) {
                    var fetchFrames = function fetchFrames(entry) {
                        return entry.parent ? entry.callFrames.concat(fetchFrames(entry.parent)) : entry.callFrames;
                    };
                    var asyncStack = fetchFrames(context.asyncStackTrace).filter(function (frame) {
                        return frame.url.indexOf('internal') === -1;
                    }).map(function (frame) {
                        return "    at " + (frame.functionName || '<anonymous>') + " (" + frame.url + ":" + frame.lineNumber + ":" + frame.columnNumber + ")";
                    });
                    asyncStack.unshift('');
                    error.stack = error.stack.concat(asyncStack.join('\n'));
                }
                error.frame = context ? context.frame : undefined;
                // send it
                serviceManager_1.ServiceManager.get('transport').send('process:exception', error);
                // at this point the process should exit
                process.exit(1);
            };
        }
    }, {
        key: "isObjectInteresting",
        value: function isObjectInteresting(entry) {
            if (!entry.value) return false;
            if (!entry.value.objectId) return false;
            if (entry.value.type !== 'object') return false;
            switch (entry.value.description) {
                case 'IncomingMessage':
                    {
                        return true;
                    }
            }
            switch (entry.name) {
                case 'headers':
                    {
                        return true;
                    }
                case 'user':
                    {
                        return true;
                    }
                case 'token':
                    {
                        return true;
                    }
                case 'body':
                    {
                        return true;
                    }
                case 'params':
                    {
                        return true;
                    }
                case 'query':
                    {
                        return true;
                    }
            }
            return false;
        }
    }, {
        key: "isPropertyIntesting",
        value: function isPropertyIntesting(entry, parent) {
            if (!entry.value) return false;
            if (entry.value.type === 'object' && entry.properties) return true;
            if (parent && parent.name === 'headers') return true;
            if (parent && parent.name === 'body') return true;
            if (parent && parent.name === 'params') return true;
            if (parent && parent.name === 'query') return true;
            if (entry.name === '__proto__') return false;
            switch (entry.name) {
                case 'url':
                    {
                        return true;
                    }
                case 'user':
                    {
                        return true;
                    }
                case 'token':
                    {
                        return true;
                    }
                case 'method':
                    {
                        return true;
                    }
                case 'ip':
                    {
                        return true;
                    }
                case 'query':
                    {
                        return true;
                    }
                case 'path':
                    {
                        return true;
                    }
                case 'body':
                    {
                        return true;
                    }
                case 'params':
                    {
                        return true;
                    }
            }
            return false;
        }
    }, {
        key: "formatProperty",
        value: function formatProperty(property) {
            var value = property.value && property.value.value ? property.value.value : null;
            var description = property.value && property.value.description ? property.value.description : null;
            return {
                name: property.name,
                value: value || description || property.value,
                properties: property.properties
            };
        }
    }, {
        key: "fetchObjectProperties",
        value: function fetchObjectProperties(session, object, cb) {
            var _this2 = this;

            session.post('Runtime.getProperties', {
                objectId: object,
                ownProperties: true
            }, function (err, data) {
                if (err) return cb(err, undefined);
                async_1.default.map(data.result, function (entry, next) {
                    if (entry.value && entry.value.objectId && _this2.isObjectInteresting(entry)) {
                        return _this2.fetchObjectProperties(session, entry.value.objectId, function (err, properties) {
                            if (err) return next(err);
                            // if some properties has been dumped, attach them
                            if (properties) {
                                entry.properties = properties.filter(function (property) {
                                    return _this2.isPropertyIntesting(property, entry);
                                }).map(_this2.formatProperty);
                            }
                            return next(undefined, _this2.formatProperty(entry));
                        });
                    } else {
                        return next(undefined, _this2.formatProperty(entry));
                    }
                }, cb);
            });
        }
    }, {
        key: "catchAllDebugger",
        value: function catchAllDebugger() {
            var _this3 = this;

            var session = this.inspectorService.createSession();
            this.inspectorService.connect();
            // trap exception so we can re-use them with the debugger
            process.on('uncaughtException', this.trapException('uncaughtException'));
            process.on('unhandledRejection', this.trapException('unhandledRejection'));
            // enable all the debugger options
            session.post('Debugger.enable');
            var maxDepth = parseInt(process.env.PM2_APM_ASYNC_STACK_DEPTH || '', 10);
            if (!isNaN(maxDepth)) {
                session.post('Debugger.setAsyncCallStackDepth', { maxDepth: maxDepth });
            }
            session.post('Debugger.setPauseOnExceptions', { state: 'uncaught' });
            // register handler for paused event
            session.on('Debugger.paused', function (_ref) {
                var params = _ref.params;

                // should not happen but anyway
                if (params.reason !== 'exception' && params.reason !== 'promiseRejection') {
                    return session.post('Debugger.resume');
                }
                if (!params.data) return session.post('Debugger.resume');
                var error = params.data;
                // get only the current frame
                var frame = params.callFrames[0];
                // on each frame, dump all scopes
                async_1.default.map(frame.scopeChain, function (scope, nextScope) {
                    if (scope.type === 'global') return nextScope();
                    if (!scope.object.objectId) return nextScope();
                    // get context of the scope
                    return _this3.fetchObjectProperties(session, scope.object.objectId, function (error, context) {
                        return nextScope(error, Object.assign(scope, {
                            context: context,
                            object: undefined
                        }));
                    });
                }, function (err, scopes) {
                    if (err) {
                        console.error(err);
                        return session.post('Debugger.resume');
                    }
                    // we can remove some scope so we want to remove null entry
                    scopes = scopes.filter(function (scope) {
                        return !!scope;
                    });
                    // inspect each scope to retrieve his context
                    _this3.exceptionsTrapped.push({
                        error: error,
                        asyncStackTrace: params.asyncStackTrace,
                        frame: Object.assign(frame, {
                            scopeChain: scopes
                        })
                    });
                    // continue execution
                    return session.post('Debugger.resume');
                });
            });
        }
    }]);

    return NotifyInspector;
}();

exports.default = NotifyInspector;
//# sourceMappingURL=notifyInspector.js.map