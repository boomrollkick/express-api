"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

Object.defineProperty(exports, "__esModule", { value: true });
var debug_1 = require("debug");
var pmx_1 = require("../pmx");
var debug = debug_1.default('PM2-IO-APM');
var IO_KEY = Symbol.for('@pm2/io');

var Entrypoint = function (_pmx_1$default) {
    _inherits(Entrypoint, _pmx_1$default);

    function Entrypoint() {
        _classCallCheck(this, Entrypoint);

        var _this = _possibleConstructorReturn(this, (Entrypoint.__proto__ || Object.getPrototypeOf(Entrypoint)).call(this));

        _this.defaultConf = {
            metrics: {
                eventLoopActive: true,
                eventLoopDelay: true,
                network: {
                    traffic: false,
                    ports: false
                },
                transaction: {
                    http: true,
                    tracing: false
                },
                deepMetrics: false,
                v8: false
            },
            actions: {
                eventLoopDump: false,
                profilingCpu: true,
                profilingHeap: true
            }
        };
        try {
            _this.io = global[IO_KEY].init(_this.conf());
            _this.onStart(function (err) {
                if (err) {
                    debug(err);
                }
                _this.sensors();
                _this.events();
                _this.actuators();
                _this.io.onExit(function (code, signal) {
                    _this.onStop(err, function () {
                        _this.io.destroy();
                    }, code, signal);
                });
                if (process && process.send) process.send('ready');
            });
        } catch (e) {
            // properly exit in case onStart/onStop method has not been override
            if (_this.io) {
                _this.io.destroy();
            }
            throw e;
        }
        return _this;
    }

    _createClass(Entrypoint, [{
        key: "events",
        value: function events() {
            debug('No events !');
        }
    }, {
        key: "sensors",
        value: function sensors() {
            debug('No metrics !');
        }
    }, {
        key: "actuators",
        value: function actuators() {
            debug('No metrics !');
        }
    }, {
        key: "onStart",
        value: function onStart(cb) {
            throw new Error('Entrypoint onStart() not specified');
        }
    }, {
        key: "onStop",
        value: function onStop(err, cb, code, signal) {
            cb(); // by default only execute callback
        }
    }, {
        key: "conf",
        value: function conf() {
            return this.defaultConf;
        }
    }]);

    return Entrypoint;
}(pmx_1.default);

exports.default = Entrypoint;
//# sourceMappingURL=entrypoint.js.map