"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var debug_1 = require("debug");
var debug = debug_1.default('axm:configuration');
var serviceManager_1 = require("./serviceManager");
var autocast_1 = require("./utils/autocast");
var path = require("path");
var fs = require("fs");
var util = require("util");
var prefix = __dirname.replace(/\\/g, '/').indexOf('/build/') >= 0 ? '../../../' : '../';
var pkg = require(prefix + '/package.json');

var Configuration = function () {
    function Configuration() {
        _classCallCheck(this, Configuration);
    }

    _createClass(Configuration, null, [{
        key: "configureModule",
        value: function configureModule(opts) {
            if (serviceManager_1.ServiceManager.get('transport')) serviceManager_1.ServiceManager.get('transport').setOptions(opts);
        }
    }, {
        key: "findPackageJson",
        value: function findPackageJson() {
            require.main = Configuration.getMain();
            if (!require.main) {
                return;
            }
            var pkgPath = path.resolve(path.dirname(require.main.filename), 'package.json');
            try {
                fs.statSync(pkgPath);
            } catch (e) {
                try {
                    pkgPath = path.resolve(path.dirname(require.main.filename), '..', 'package.json');
                    fs.statSync(pkgPath);
                } catch (e) {
                    debug('Cannot find package.json');
                    return null;
                }
                return pkgPath;
            }
            return pkgPath;
        }
    }, {
        key: "init",
        value: function init(conf, doNotTellPm2) {
            var packageFilepath = Configuration.findPackageJson();
            var packageJson = void 0;
            if (!conf.module_conf) {
                conf.module_conf = {};
            }
            conf.pmx_version = pkg.version || null;
            if (conf.isModule === true) {
                /**
                 * Merge package.json metadata
                 */
                try {
                    packageJson = require(packageFilepath || '');
                    conf.module_version = packageJson.version;
                    conf.module_name = packageJson.name;
                    conf.description = packageJson.description;
                    if (packageJson.config) {
                        conf = util['_extend'](conf, packageJson.config);
                        conf.module_conf = packageJson.config;
                    }
                } catch (e) {
                    throw new Error(e);
                }
            } else {
                conf.module_name = process.env.name || 'outside-pm2';
                try {
                    packageJson = require(packageFilepath || '');
                    conf.module_version = packageJson.version;
                    if (packageJson.config) {
                        conf = util['_extend'](conf, packageJson.config);
                        conf.module_conf = packageJson.config;
                    }
                } catch (e) {
                    debug(e.message);
                }
            }
            /**
             * If custom variables has been set, merge with returned configuration
             */
            try {
                if (process.env[conf.module_name]) {
                    var castedConf = new autocast_1.default().autocast(JSON.parse(process.env[conf.module_name] || ''));
                    conf = util['_extend'](conf, castedConf);
                    // Do not display probe configuration in Keymetrics
                    delete castedConf.probes;
                    // This is the configuration variable modifiable from keymetrics
                    conf.module_conf = JSON.parse(JSON.stringify(util['_extend'](conf.module_conf, castedConf)));
                    // Obfuscate passwords
                    Object.keys(conf.module_conf).forEach(function (key) {
                        if ((key === 'password' || key === 'passwd') && conf.module_conf[key].length >= 1) {
                            conf.module_conf[key] = 'Password hidden';
                        }
                    });
                }
            } catch (e) {
                debug(e);
            }
            if (doNotTellPm2 === true) return conf;
            Configuration.configureModule(conf);
            return conf;
        }
    }, {
        key: "getMain",
        value: function getMain() {
            return require.main || { filename: './somefile.js' };
        }
    }]);

    return Configuration;
}();

exports.default = Configuration;
//# sourceMappingURL=configuration.js.map