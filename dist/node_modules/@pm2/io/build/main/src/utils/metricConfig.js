"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var merge = require("deepmerge");

var MetricConfig = function () {
    function MetricConfig() {
        _classCallCheck(this, MetricConfig);
    }

    _createClass(MetricConfig, null, [{
        key: "getConfig",
        value: function getConfig(config, defaultConf) {
            if (!config || config === true) {
                config = defaultConf;
            } else if (config !== 'all') {
                config = merge(defaultConf, config);
            }
            return config;
        }
    }, {
        key: "initProbes",
        value: function initProbes(allPossibleMetrics, config, metricFeature) {
            var probes = {};
            for (var metricName in allPossibleMetrics) {
                if (allPossibleMetrics.hasOwnProperty(metricName) && (config === 'all' || config[metricName] === true)) {
                    probes[metricName] = metricFeature.metric(allPossibleMetrics[metricName]);
                }
            }
            return probes;
        }
    }, {
        key: "setProbesValue",
        value: function setProbesValue(allPossibleMetrics, metrics, probes, defaultUnit) {
            if (!metrics || !probes) return;
            for (var metricName in metrics) {
                if (metrics.hasOwnProperty(metricName) && probes.hasOwnProperty(metricName)) {
                    var value = allPossibleMetrics[metricName].unit === defaultUnit ? Math.round(metrics[metricName] / 1000) : metrics[metricName];
                    probes[metricName].set(value);
                }
            }
        }
    }, {
        key: "buildConfig",
        value: function buildConfig(config) {
            if (typeof config === 'string') {
                config = {
                    name: config
                };
            }
            return config;
        }
    }]);

    return MetricConfig;
}();

exports.default = MetricConfig;
//# sourceMappingURL=metricConfig.js.map