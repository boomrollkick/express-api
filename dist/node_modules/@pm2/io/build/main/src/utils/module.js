"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var fs = require("fs");
var Debug = require("debug");
var path = require("path");
var debug = Debug('axm:module');

var ModuleUtils = function () {
    function ModuleUtils() {
        _classCallCheck(this, ModuleUtils);
    }

    _createClass(ModuleUtils, null, [{
        key: "getModulePath",
        value: function getModulePath(moduleName) {
            return tslib_1.__awaiter(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                return regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                return _context.abrupt("return", new Promise(function (resolve, reject) {
                                    ModuleUtils.detectModule(moduleName, function (err, path) {
                                        if (err) {
                                            debug(err);
                                            return reject(err);
                                        }
                                        return resolve(path);
                                    });
                                }));

                            case 1:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));
        }
    }, {
        key: "loadModule",
        value: function loadModule(modulePath, moduleName, args) {
            var module = void 0;
            try {
                if (args) {
                    module = require(modulePath).apply(this, args);
                } else {
                    module = require(modulePath);
                }
            } catch (e) {
                debug("Error when requiring " + moduleName + " on path", modulePath);
                debug(e.message);
                return e;
            }
            debug(moduleName + " successfully enabled");
            return module;
        }
    }, {
        key: "detectModule",
        value: function detectModule(moduleName, cb) {
            var module = this._getModule() || { paths: ['./node_modules', '/node_modules'] };
            var requirePaths = module.paths.slice();
            ModuleUtils._lookForModule(requirePaths, moduleName, cb);
        }
    }, {
        key: "_getModule",
        value: function _getModule() {
            return require.main;
        }
    }, {
        key: "_lookForModule",
        value: function _lookForModule(requirePaths, moduleName, cb) {
            if (!requirePaths[0]) {
                debug('[x] %s NOT FOUND', moduleName);
                return cb(new Error(moduleName + ' not found'));
            }
            var profilerPath = path.join(requirePaths[0], moduleName);
            debug('Checking %s in path %s', moduleName, profilerPath);
            fs.access(profilerPath, (fs.constants || fs).R_OK, function (err) {
                if (!err) {
                    debug('[+] %s detected in path %s', moduleName, profilerPath);
                    return cb(null, profilerPath);
                }
                debug('[-] %s not found in path %s', moduleName, profilerPath);
                requirePaths.shift();
                return ModuleUtils._lookForModule(requirePaths, moduleName, cb);
            });
        }
    }]);

    return ModuleUtils;
}();

exports.default = ModuleUtils;
//# sourceMappingURL=module.js.map