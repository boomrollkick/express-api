{"version":3,"sources":["../../../../../src/node_modules/@pm2/agent/src/PM2Client.js"],"names":["axon","require","cst","rpc","log","EventEmitter","PM2Interface","module","exports","opts","subSocket","sub_port","DAEMON_PUB_PORT","rpcSocket","rpc_port","DAEMON_RPC_PORT","sub","socket","sub_sock","connect","bus","req","rpc_sock","rpc_client","Client","on","generateMethods","pm2Interface","emit","close","cb","methods","err","Object","keys","forEach","key","method","name","self","args","Array","prototype","slice","call","arguments","unshift","apply","parameters","Error","data","msgProcess"],"mappings":"AAAA;;;;;;;;;;AAEA,IAAMA,OAAOC,QAAQ,UAAR,CAAb;AACA,IAAMC,MAAMD,QAAQ,iBAAR,CAAZ;AACA,IAAME,MAAMF,QAAQ,cAAR,CAAZ;AACA,IAAMG,MAAMH,QAAQ,OAAR,EAAiB,uBAAjB,CAAZ;AACA,IAAMI,eAAeJ,QAAQ,QAAR,EAAkBI,YAAvC;AACA,IAAMC,eAAeL,QAAQ,gBAAR,CAArB;;AAEA;;;;;;AAMAM,OAAOC,OAAP;AAAA;;AACE,qBAAaC,IAAb,EAAmB;AAAA;;AAAA;;AAEjB,QAAMC,YAAaD,QAAQA,KAAKE,QAAd,IAA2BT,IAAIU,eAAjD;AACA,QAAMC,YAAaJ,QAAQA,KAAKK,QAAd,IAA2BZ,IAAIa,eAAjD;;AAEA,QAAMC,MAAMhB,KAAKiB,MAAL,CAAY,aAAZ,CAAZ;AACA,UAAKC,QAAL,GAAgBF,IAAIG,OAAJ,CAAYT,SAAZ,CAAhB;AACA,UAAKU,GAAL,GAAWJ,GAAX;;AAEA,QAAMK,MAAMrB,KAAKiB,MAAL,CAAY,KAAZ,CAAZ;AACA,UAAKK,QAAL,GAAgBD,IAAIF,OAAJ,CAAYN,SAAZ,CAAhB;AACA,UAAKU,UAAL,GAAkB,IAAIpB,IAAIqB,MAAR,CAAeH,GAAf,CAAlB;;AAEA,UAAKlB,GAAL,GAAW,EAAX;;AAEA,UAAKmB,QAAL,CAAcG,EAAd,CAAiB,SAAjB,EAA4B,aAAK;AAC/BrB,UAAI,iDAAJ;AACA,YAAKsB,eAAL,CAAqB,aAAK;AACxB,cAAKC,YAAL,GAAoB,IAAIrB,YAAJ,CAAiB,MAAKH,GAAtB,CAApB;AACA,cAAKyB,IAAL,CAAU,OAAV;AACD,OAHD;AAID,KAND;;AAQA,UAAKN,QAAL,CAAcG,EAAd,CAAiB,OAAjB,EAA0B,aAAK;AAC7BrB,UAAI,gBAAJ;AACA,YAAKwB,IAAL,CAAU,QAAV;AACD,KAHD;;AAKA,UAAKN,QAAL,CAAcG,EAAd,CAAiB,mBAAjB,EAAsC,aAAK;AACzCrB,UAAI,sBAAJ;AACA,YAAKwB,IAAL,CAAU,cAAV;AACD,KAHD;;AAKA,UAAKV,QAAL,CAAcO,EAAd,CAAiB,SAAjB,EAA4B,aAAK;AAC/BrB,UAAI,WAAJ;AACA,YAAKwB,IAAL,CAAU,WAAV;AACD,KAHD;;AAKA,UAAKV,QAAL,CAAcO,EAAd,CAAiB,OAAjB,EAA0B,aAAK;AAC7BrB,UAAI,YAAJ;AACA,YAAKwB,IAAL,CAAU,YAAV;AACD,KAHD;;AAKA,UAAKV,QAAL,CAAcO,EAAd,CAAiB,mBAAjB,EAAsC,aAAK;AACzCrB,UAAI,kBAAJ;AACA,YAAKwB,IAAL,CAAU,kBAAV;AACD,KAHD;AA3CiB;AA+ClB;;AAED;;;;;;AAlDF;AAAA;AAAA,iCAsDgB;AACZ,WAAKV,QAAL,CAAcW,KAAd;AACA,WAAKP,QAAL,CAAcO,KAAd;AACD;;AAED;;;;;AA3DF;AAAA;AAAA,oCA+DmBC,EA/DnB,EA+DuB;AAAA;;AACnB1B,UAAI,uCAAJ;AACA,WAAKmB,UAAL,CAAgBQ,OAAhB,CAAwB,UAACC,GAAD,EAAMD,OAAN,EAAkB;AACxC,YAAIC,GAAJ,EAAS,OAAOF,GAAGE,GAAH,CAAP;AACTC,eAAOC,IAAP,CAAYH,OAAZ,EAAqBI,OAArB,CAA6B,UAACC,GAAD,EAAS;AACpC,cAAIC,SAASN,QAAQK,GAAR,CAAb;;AAEAhC,cAAI,wBAAJ,EAA8BiC,OAAOC,IAArC;;AAEA,WAAC,UAACA,IAAD,EAAU;AACT,gBAAMC,OAAO,MAAb;AACA,mBAAKpC,GAAL,CAASmC,IAAT,IAAiB,YAAY;AAC3B,kBAAIE,OAAOC,MAAMC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BC,SAA3B,CAAX;AACAL,mBAAKM,OAAL,CAAaR,IAAb;AACAC,mBAAKhB,UAAL,CAAgBqB,IAAhB,CAAqBG,KAArB,CAA2BR,KAAKhB,UAAhC,EAA4CiB,IAA5C;AACD,aAJD;AAKD,WAPD,EAOGH,OAAOC,IAPV;AAQD,SAbD;AAcA,eAAOR,IAAP;AACD,OAjBD;AAkBD;AAnFH;AAAA;AAAA,2BAqFUO,MArFV,EAqFkBW,UArFlB,EAqF8BlB,EArF9B,EAqFkC;AAC9B1B,UAAI,gBAAJ,EAAsBiC,MAAtB,EAA8BW,UAA9B;AACA,UAAI,KAAKrB,YAAL,CAAkBU,MAAlB,MAA8B,WAAlC,EAA+C;AAC7C,eAAOP,GAAG,IAAImB,KAAJ,CAAU,8BAAV,CAAH,CAAP;AACD;AACD,WAAKtB,YAAL,CAAkBU,MAAlB,EAA0BW,UAA1B,EAAsClB,EAAtC;AACD;AA3FH;AAAA;AAAA,+BA6FcoB,IA7Fd,EA6FoBpB,EA7FpB,EA6FwB;AACpB,WAAK3B,GAAL,CAASgD,UAAT,CAAoBD,IAApB,EAA0BpB,EAA1B;AACD;AA/FH;;AAAA;AAAA,EAAyCzB,YAAzC","file":"PM2Client.js","sourcesContent":["'use strict'\n\nconst axon = require('pm2-axon')\nconst cst = require('../constants.js')\nconst rpc = require('pm2-axon-rpc')\nconst log = require('debug')('interactor:pm2:client')\nconst EventEmitter = require('events').EventEmitter\nconst PM2Interface = require('./PM2Interface')\n\n/**\n * PM2 API Wrapper used to setup connection with the daemon\n * @param {Object} opts options\n * @param {String} opts.sub_port socket file of the PM2 bus [optionnal]\n * @param {String} opts.rpc_port socket file of the PM2 RPC server [optionnal]\n */\nmodule.exports = class PM2Client extends EventEmitter {\n  constructor (opts) {\n    super()\n    const subSocket = (opts && opts.sub_port) || cst.DAEMON_PUB_PORT\n    const rpcSocket = (opts && opts.rpc_port) || cst.DAEMON_RPC_PORT\n\n    const sub = axon.socket('sub-emitter')\n    this.sub_sock = sub.connect(subSocket)\n    this.bus = sub\n\n    const req = axon.socket('req')\n    this.rpc_sock = req.connect(rpcSocket)\n    this.rpc_client = new rpc.Client(req)\n\n    this.rpc = {}\n\n    this.rpc_sock.on('connect', _ => {\n      log('PM2 API Wrapper connected to PM2 Daemon via RPC')\n      this.generateMethods(_ => {\n        this.pm2Interface = new PM2Interface(this.rpc)\n        this.emit('ready')\n      })\n    })\n\n    this.rpc_sock.on('close', _ => {\n      log('pm2 rpc closed')\n      this.emit('closed')\n    })\n\n    this.rpc_sock.on('reconnect attempt', _ => {\n      log('pm2 rpc reconnecting')\n      this.emit('reconnecting')\n    })\n\n    this.sub_sock.on('connect', _ => {\n      log('bus ready')\n      this.emit('bus:ready')\n    })\n\n    this.sub_sock.on('close', _ => {\n      log('bus closed')\n      this.emit('bus:closed')\n    })\n\n    this.sub_sock.on('reconnect attempt', _ => {\n      log('bus reconnecting')\n      this.emit('bus:reconnecting')\n    })\n  }\n\n  /**\n   * Disconnect socket connections. This will allow Node to exit automatically.\n   * Further calls to PM2 from this object will throw an error.\n   */\n  disconnect () {\n    this.sub_sock.close()\n    this.rpc_sock.close()\n  }\n\n  /**\n   * Generate method by requesting exposed methods by PM2\n   * You can now control/interact with PM2\n   */\n  generateMethods (cb) {\n    log('Requesting and generating RPC methods')\n    this.rpc_client.methods((err, methods) => {\n      if (err) return cb(err)\n      Object.keys(methods).forEach((key) => {\n        let method = methods[key]\n\n        log('+-- Creating %s method', method.name);\n\n        ((name) => {\n          const self = this\n          this.rpc[name] = function () {\n            let args = Array.prototype.slice.call(arguments)\n            args.unshift(name)\n            self.rpc_client.call.apply(self.rpc_client, args)\n          }\n        })(method.name)\n      })\n      return cb()\n    })\n  }\n\n  remote (method, parameters, cb) {\n    log('remote send %s', method, parameters)\n    if (this.pm2Interface[method] === 'undefined') {\n      return cb(new Error('Deprecated or invalid method'))\n    }\n    this.pm2Interface[method](parameters, cb)\n  }\n\n  msgProcess (data, cb) {\n    this.rpc.msgProcess(data, cb)\n  }\n}\n"]}