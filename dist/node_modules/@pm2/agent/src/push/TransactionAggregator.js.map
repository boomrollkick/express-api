{"version":3,"sources":["../../../../../../src/node_modules/@pm2/agent/src/push/TransactionAggregator.js"],"names":["cst","require","log","Utility","fclone","Histogram","module","exports","pushInteractor","processes","stackParser","_stackParser","LABELS","SPANS_DB","REGEX_JSON_CLEANUP","init","_ipm2","bus","on","data","event","process","name","rev","versioning","revision","resetAggregation","server","opts","MACHINE_NAME","launchWorker","appName","meta","initialization_timeout","clearTimeout","clearInterval","notifier","initializeRouteMeta","start","Date","now","setInterval","elapsed","AGGREGATION_DURATION","msg","learning_duration","transport","send","setTimeout","Object","keys","forEach","pm_id","routes","trace_count","http_meter","EWMA","db_meter","histogram","measurement","db_histograms","packet","spans","labels","validateData","newTrace","path","HTTP_PATH_LABEL_KEY","censorSpans","filter","span","endTime","startTime","mean","Math","round","kind","update","i","len","length","indexOf","substr","matched","matchPath","mergeTrace","aggregated","trace","variances","meter","merge","variance","projectId","traceId","parseStacktrace","push","percentiles","map","p5","p95","value","p75","p99","min","getMin","max","getMax","count","getCount","updateSpanDuration","stacktrace","compareList","newSpans","one","two","split","route","segments","j","isIdentifier","join","undefined","_worker","normalized","prepareAggregationforShipping","key","TRACE_FLUSH_INTERVAL","rate","http_percentiles","median","db_percentiles","sort","a","b","slice","routeCopy","tmp","id","match","DEBUG","results","result","spanId","parentSpanId","values","replace","JSON","parse","e","stack_frame","Array","callsite","context"],"mappings":"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","file":"TransactionAggregator.js","sourcesContent":["'use strict'\n\nconst cst = require('../../constants.js')\nconst log = require('debug')('interactor:aggregator')\nconst Utility = require('../Utility.js')\nconst fclone = require('fclone')\nconst Histogram = require('../utils/probes/Histogram')\n\n/**\n *\n * # Data structure sent to interactor\n *\n * {\n *  'process_name': {\n *    process : {},         // PM2 process meta data\n *    data : {\n *      routes : [          // array of all routes ordered by count\n *        {\n *          path: '/',       // path of the route\n *          meta: {\n *            count: 50,     // count of this route\n *            max: 300,      // max latency of this route\n *            min: 50,       // min latency of this route\n *            mean: 120      // mean latency of this route\n *          }\n *          variances:  [{  // array of variance order by count\n *           spans : [\n *              ...         // transactions\n *           ],\n *           count: 50,     // count of this variance\n *           max: 300,      // max latency of this variance\n *           min: 50,       // min latency of this variance\n *           mean: 120      // mean latency of this variance\n *          }]\n *        }\n *      ],\n *      meta : {\n *        trace_count : 50,  // trace number\n *        mean_latency      : 40,  // global app latency in ms\n *        http_meter        : 30,  // global app req per minutes\n *        db_meter          : 20,  // number of database transaction per min\n *      }\n *    }\n *   }\n * }\n */\n\nmodule.exports = class TransactionAggregator {\n  constructor (pushInteractor) {\n    this.processes = {}\n    this.stackParser = pushInteractor._stackParser\n    this.pushInteractor = pushInteractor\n\n    this.LABELS = {\n      'HTTP_RESPONSE_CODE_LABEL_KEY': 'http/status_code',\n      'HTTP_URL_LABEL_KEY': 'http/url',\n      'HTTP_METHOD_LABEL_KEY': 'http/method',\n      'HTTP_RESPONSE_SIZE_LABEL_KEY': 'http/response/size',\n      'STACK_TRACE_DETAILS_KEY': 'stacktrace',\n      'ERROR_DETAILS_NAME': 'error/name',\n      'ERROR_DETAILS_MESSAGE': 'error/message',\n      'HTTP_SOURCE_IP': 'http/source/ip',\n      'HTTP_PATH_LABEL_KEY': 'http/path'\n    }\n    this.SPANS_DB = ['redis', 'mysql', 'pg', 'mongo', 'outbound_http']\n    this.REGEX_JSON_CLEANUP = /\":(?!\\[|{)\\\\\"[^\"]*\\\\\"|\":([\"'])(?:(?=(\\\\?))\\2.)*?\\1|\":(?!\\[|{)[^,}\\]]*|\":\\[[^{]*]/g\n\n    this.init()\n  }\n\n  /**\n   * First method to call in real environment\n   * - Listen to restart event for initialization period\n   * - Clear aggregation on process stop\n   * - Launch worker to attach data to be pushed to KM\n   */\n  init () {\n    // New Process Online, reset & wait a bit before processing\n    this.pushInteractor._ipm2.bus.on('process:event', (data) => {\n      if (data.event !== 'online' || !this.processes[data.process.name]) return false\n\n      let rev = (data.process.versioning && data.process.versioning.revision)\n        ? data.process.versioning.revision : null\n\n      this.resetAggregation(data.process.name, {\n        rev: rev,\n        server: this.pushInteractor.opts.MACHINE_NAME\n      })\n    })\n\n    // Process getting offline, delete aggregation\n    this.pushInteractor._ipm2.bus.on('process:event', (data) => {\n      if (data.event !== 'stop' || !this.processes[data.process.name]) return false\n      log('Deleting aggregation for %s', data.process.name)\n      delete this.processes[data.process.name]\n    })\n\n    this.launchWorker()\n  }\n\n  /**\n   * Reset aggregation for target app_name\n   */\n  resetAggregation (appName, meta) {\n    log('Reseting agg for app:%s meta:%j', appName, meta)\n\n    if (this.processes[appName].initialization_timeout) {\n      log('Reseting initialization timeout app:%s', appName)\n      clearTimeout(this.processes[appName].initialization_timeout)\n      clearInterval(this.processes[appName].notifier)\n      this.processes[appName].notifier = null\n    }\n\n    this.processes[appName] = this.initializeRouteMeta({\n      name: appName,\n      rev: meta.rev,\n      server: meta.server\n    })\n\n    let start = Date.now()\n    this.processes[appName].notifier = setInterval(_ => {\n      let elapsed = Date.now() - start\n      // failsafe\n      if (elapsed / 1000 > cst.AGGREGATION_DURATION) {\n        clearInterval(this.processes[appName].notifier)\n        this.processes[appName].notifier = null\n      }\n\n      let msg = {\n        data: {\n          learning_duration: cst.AGGREGATION_DURATION,\n          elapsed: elapsed\n        },\n        process: this.processes[appName].process\n      }\n      this.pushInteractor && this.pushInteractor.transport.send('axm:transaction:learning', msg)\n    }, 5000)\n\n    this.processes[appName].initialization_timeout = setTimeout(_ => {\n      log('Initialization timeout finished for app:%s', appName)\n      clearInterval(this.processes[appName].notifier)\n      this.processes[appName].notifier = null\n      this.processes[appName].initialization_timeout = null\n    }, cst.AGGREGATION_DURATION)\n  }\n\n  /**\n   * Clear aggregated data for all process\n   */\n  clearData () {\n    Object.keys(this.processes).forEach((process) => {\n      this.resetAggregation(process, this.processes[process].process)\n    })\n  }\n\n  /**\n   * Generate new entry for application\n   *\n   * @param {Object} process process meta\n   */\n  initializeRouteMeta (process) {\n    if (process.pm_id) delete process.pm_id\n\n    return {\n      routes: {},\n      meta: {\n        trace_count: 0,\n        http_meter: new Utility.EWMA(),\n        db_meter: new Utility.EWMA(),\n        histogram: new Histogram({ measurement: 'median' }),\n        db_histograms: {}\n      },\n      process: process\n    }\n  }\n\n  getAggregation () {\n    return this.processes\n  }\n\n  validateData (packet) {\n    if (!packet || !packet.data) {\n      log('Packet malformated', packet)\n      return false\n    }\n\n    if (!packet.process) {\n      log('Got packet without process: %j', packet)\n      return false\n    }\n\n    if (!packet.data.spans || !packet.data.spans[0]) {\n      log('Trace without spans: %s', Object.keys(packet.data))\n      return false\n    }\n\n    if (!packet.data.spans[0].labels) {\n      log('Trace spans without labels: %s', Object.keys(packet.data.spans))\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Main method to aggregate and compute stats for traces\n   *\n   * @param {Object} packet\n   * @param {Object} packet.process  process metadata\n   * @param {Object} packet.data     trace\n   */\n  aggregate (packet) {\n    if (this.validateData(packet) === false) return false\n\n    const newTrace = packet.data\n    const appName = packet.process.name\n\n    if (!this.processes[appName]) {\n      this.processes[appName] = this.initializeRouteMeta(packet.process)\n    }\n\n    let process = this.processes[appName]\n\n    // Get http path of current span\n    let path = newTrace.spans[0].labels[this.LABELS.HTTP_PATH_LABEL_KEY]\n\n    // Cleanup spans\n    this.censorSpans(newTrace.spans)\n\n    // remove spans with startTime == endTime\n    newTrace.spans = newTrace.spans.filter((span) => {\n      return span.endTime !== span.startTime\n    })\n\n    // compute duration of child spans\n    newTrace.spans.forEach((span) => {\n      span.mean = Math.round(new Date(span.endTime) - new Date(span.startTime))\n      delete span.endTime\n    })\n\n    // Update app meta (mean_latency, http_meter, db_meter, trace_count)\n    newTrace.spans.forEach((span) => {\n      if (!span.name || !span.kind) return false\n\n      if (span.kind === 'RPC_SERVER') {\n        process.meta.histogram.update(span.mean)\n        return process.meta.http_meter.update()\n      }\n\n      // Override outbount http queries for processing\n      if (span.labels && span.labels['http/method'] && span.labels['http/status_code']) {\n        span.labels['service'] = span.name\n        span.name = 'outbound_http'\n      }\n\n      for (let i = 0, len = this.SPANS_DB.length; i < len; i++) {\n        if (span.name.indexOf(this.SPANS_DB[i]) > -1) {\n          process.meta.db_meter.update()\n          if (!process.meta.db_histograms[this.SPANS_DB[i]]) {\n            process.meta.db_histograms[this.SPANS_DB[i]] = new Histogram({ measurement: 'mean' })\n          }\n          process.meta.db_histograms[this.SPANS_DB[i]].update(span.mean)\n          break\n        }\n      }\n    })\n\n    process.meta.trace_count++\n\n    /**\n     * Handle traces aggregation\n     */\n    if (path[0] === '/' && path !== '/') {\n      path = path.substr(1, path.length - 1)\n    }\n\n    let matched = this.matchPath(path, process.routes)\n\n    if (!matched) {\n      process.routes[path] = []\n      this.mergeTrace(process.routes[path], newTrace, process)\n    } else {\n      this.mergeTrace(process.routes[matched], newTrace, process)\n    }\n\n    return this.processes\n  }\n\n  /**\n   * Merge new trace and compute mean, min, max, count\n   *\n   * @param {Object}  aggregated previous aggregated route\n   * @param {Object}  trace\n   */\n  mergeTrace (aggregated, trace, process) {\n    if (!aggregated || !trace) return\n\n    // if the trace doesn't any spans stop aggregation here\n    if (trace.spans.length === 0) return\n\n    // create data structure if needed\n    if (!aggregated.variances) aggregated.variances = []\n    if (!aggregated.meta) {\n      aggregated.meta = {\n        histogram: new Histogram({ measurement: 'median' }),\n        meter: new Utility.EWMA()\n      }\n    }\n\n    aggregated.meta.histogram.update(trace.spans[0].mean)\n    aggregated.meta.meter.update()\n\n    const merge = (variance) => {\n      // no variance found so its a new one\n      if (variance == null) {\n        delete trace.projectId\n        delete trace.traceId\n        trace.histogram = new Histogram({ measurement: 'median' })\n        trace.histogram.update(trace.spans[0].mean)\n\n        trace.spans.forEach((span) => {\n          span.histogram = new Histogram({ measurement: 'median' })\n          span.histogram.update(span.mean)\n          delete span.mean\n        })\n\n        // parse strackrace\n        this.parseStacktrace(trace.spans)\n        aggregated.variances.push(trace)\n      } else {\n        // check to see if request is anormally slow, if yes send it as inquisitor\n        if (trace.spans[0].mean > variance.histogram.percentiles([0.95])[0.95] &&\n          typeof pushInteractor !== 'undefined' && !process.initialization_timeout) {\n          // serialize and add metadata\n          this.parseStacktrace(trace.spans)\n          let data = {\n            trace: fclone(trace.spans),\n            variance: fclone(variance.spans.map((span) => {\n              return {\n                labels: span.labels,\n                kind: span.kind,\n                name: span.name,\n                startTime: span.startTime,\n                percentiles: {\n                  p5: variance.histogram.percentiles([0.5])[0.5],\n                  p95: variance.histogram.percentiles([0.95])[0.95]\n                }\n              }\n            })),\n            meta: {\n              value: trace.spans[0].mean,\n              percentiles: {\n                p5: variance.histogram.percentiles([0.5])[0.5],\n                p75: variance.histogram.percentiles([0.75])[0.75],\n                p95: variance.histogram.percentiles([0.95])[0.95],\n                p99: variance.histogram.percentiles([0.99])[0.99]\n              },\n              min: variance.histogram.getMin(),\n              max: variance.histogram.getMax(),\n              count: variance.histogram.getCount()\n            },\n            process: process.process\n          }\n          this.pushInteractor.transport.send('axm:transaction:outlier', data)\n        }\n\n        // variance found, merge spans\n        variance.histogram.update(trace.spans[0].mean)\n\n        // update duration of spans to be mean\n        this.updateSpanDuration(variance.spans, trace.spans, variance.count)\n\n        // delete stacktrace before merging\n        trace.spans.forEach((span) => {\n          delete span.labels.stacktrace\n        })\n      }\n    }\n\n    // for every variance, check spans same variance\n    for (let i = 0; i < aggregated.variances.length; i++) {\n      if (this.compareList(aggregated.variances[i].spans, trace.spans)) {\n        return merge(aggregated.variances[i])\n      }\n    }\n    // else its a new variance\n    return merge(null)\n  }\n\n  /**\n   * Parkour simultaneously both spans list to update value of the first one using value of the second one\n   * The first should be variance already aggregated for which we want to merge the second one\n   * The second one is a new trace, so we need to re-compute mean/min/max time for each spans\n   */\n  updateSpanDuration (spans, newSpans) {\n    for (let i = 0, len = spans.length; i < len; i++) {\n      if (!newSpans[i]) continue\n      spans[i].histogram.update(newSpans[i].mean)\n    }\n  }\n\n  /**\n   * Compare two spans list by going down on each span and comparing child and attribute\n   */\n  compareList (one, two) {\n    if (one.length !== two.length) return false\n\n    for (let i = 0, len = one; i < len; i++) {\n      if (one[i].name !== two[i].name) return false\n      if (one[i].kind !== two[i].kind) return false\n      if (!one[i].labels && two[i].labels) return false\n      if (one[i].labels && !two[i].labels) return false\n      if (one[i].labels.length !== two[i].labels.length) return false\n    }\n    return true\n  }\n\n  /**\n   * Will return the route if we found an already matched route\n   */\n  matchPath (path, routes) {\n    // empty route is / without the fist slash\n    if (!path || !routes) return false\n    if (path === '/') return routes[path] ? path : null\n\n    // remove the last slash if exist\n    if (path[path.length - 1] === '/') {\n      path = path.substr(0, path.length - 1)\n    }\n\n    // split to get array of segment\n    path = path.split('/')\n\n    // if the path has only one segment, we just need to compare the key\n    if (path.length === 1) return routes[path[0]] ? routes[path[0]] : null\n\n    // check in routes already stored for match\n    let keys = Object.keys(routes)\n    for (let i = 0, len = keys.length; i < len; i++) {\n      let route = keys[i]\n      let segments = route.split('/')\n\n      if (segments.length !== path.length) continue\n\n      for (let j = path.length - 1; j >= 0; j--) {\n        // different segment, try to find if new route or not\n        if (path[j] !== segments[j]) {\n          // if the aggregator already have matched that segment with a wildcard and the next segment is the same\n          if (this.isIdentifier(path[j]) && segments[j] === '*' && path[j - 1] === segments[j - 1]) {\n            return segments.join('/')\n          // case a let in url match, so we continue because they must be other let in url\n          } else if (path[j - 1] !== undefined && path[j - 1] === segments[j - 1] && this.isIdentifier(path[j]) && this.isIdentifier(segments[j])) {\n            segments[j] = '*'\n            // update routes in cache\n            routes[segments.join('/')] = routes[route]\n            delete routes[keys[i]]\n            return segments.join('/')\n          } else {\n            break\n          }\n        }\n\n        // if finish to iterate over segment of path, we must be on the same route\n        if (j === 0) return segments.join('/')\n      }\n    }\n  }\n\n  launchWorker () {\n    this._worker = setInterval(_ => {\n      let normalized = this.prepareAggregationforShipping()\n      Object.keys(normalized).forEach((key) => {\n        this.pushInteractor.transport.send('axm:transaction', normalized[key])\n      })\n    }, cst.TRACE_FLUSH_INTERVAL)\n  }\n\n  /**\n   * Normalize aggregation\n   */\n  prepareAggregationforShipping () {\n    let normalized = {}\n\n    // Iterate each applications\n    Object.keys(this.processes).forEach((appName) => {\n      let process = this.processes[appName]\n      let routes = process.routes\n\n      if (process.initialization_timeout) {\n        log('Waiting for app %s to be initialized', appName)\n        return null\n      }\n\n      normalized[appName] = {\n        data: {\n          routes: [],\n          meta: fclone({\n            trace_count: process.meta.trace_count,\n            http_meter: Math.round(process.meta.http_meter.rate(1000) * 100) / 100,\n            db_meter: Math.round(process.meta.db_meter.rate(1000) * 100) / 100,\n            http_percentiles: {\n              median: process.meta.histogram.percentiles([0.5])[0.5],\n              p95: process.meta.histogram.percentiles([0.95])[0.95],\n              p99: process.meta.histogram.percentiles([0.99])[0.99]\n            },\n            db_percentiles: {}\n          })\n        },\n        process: process.process\n      }\n\n      // compute percentiles for each db spans if they exist\n      this.SPANS_DB.forEach((name) => {\n        let histogram = process.meta.db_histograms[name]\n        if (!histogram) return\n        normalized[appName].data.meta.db_percentiles[name] = fclone(histogram.percentiles([0.5])[0.5])\n      })\n\n      Object.keys(routes).forEach((path) => {\n        let data = routes[path]\n\n        // hard check for invalid data\n        if (!data.variances || data.variances.length === 0) return\n\n        // get top 5 variances of the same route\n        const variances = data.variances.sort((a, b) => {\n          return b.count - a.count\n        }).slice(0, 5)\n\n        // create a copy without reference to stored one\n        let routeCopy = {\n          path: path === '/' ? '/' : '/' + path,\n          meta: fclone({\n            min: data.meta.histogram.getMin(),\n            max: data.meta.histogram.getMax(),\n            count: data.meta.histogram.getCount(),\n            meter: Math.round(data.meta.meter.rate(1000) * 100) / 100,\n            median: data.meta.histogram.percentiles([0.5])[0.5],\n            p95: data.meta.histogram.percentiles([0.95])[0.95]\n          }),\n          variances: []\n        }\n\n        variances.forEach((variance) => {\n          // hard check for invalid data\n          if (!variance.spans || variance.spans.length === 0) return\n\n          // deep copy of variances data\n          let tmp = fclone({\n            spans: [],\n            count: variance.histogram.getCount(),\n            min: variance.histogram.getMin(),\n            max: variance.histogram.getMax(),\n            median: variance.histogram.percentiles([0.5])[0.5],\n            p95: variance.histogram.percentiles([0.95])[0.95]\n          })\n\n          // get data for each span\n          variance.spans.forEach((span) => {\n            tmp.spans.push(fclone({\n              name: span.name,\n              labels: span.labels,\n              kind: span.kind,\n              startTime: span.startTime,\n              min: span.histogram.getMin(),\n              max: span.histogram.getMax(),\n              median: span.histogram.percentiles([0.5])[0.5]\n            }))\n          })\n          // push serialized into normalized data\n          routeCopy.variances.push(tmp)\n        })\n        // push the route into normalized data\n        normalized[appName].data.routes.push(routeCopy)\n      })\n    })\n\n    return normalized\n  }\n\n  /**\n   * Check if the string can be a id of some sort\n   *\n   * @param {String} id\n   */\n  isIdentifier (id) {\n    id = typeof (id) !== 'string' ? id + '' : id\n\n    // uuid v1/v4 with/without dash\n    if (id.match(/[0-9a-f]{8}-[0-9a-f]{4}-[14][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}|[0-9a-f]{12}[14][0-9a-f]{19}/i)) {\n      return true\n    // if number\n    } else if (id.match(/\\d+/)) {\n      return true\n    // if suit of nbr/letters\n    } else if (id.match(/[0-9]+[a-z]+|[a-z]+[0-9]+/)) {\n      return true\n    // if match pattern with multiple char spaced by . - _ @\n    } else if (id.match(/((?:[0-9a-zA-Z]+[@\\-_.][0-9a-zA-Z]+|[0-9a-zA-Z]+[@\\-_.]|[@\\-_.][0-9a-zA-Z]+)+)/)) {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Cleanup trace data\n   * - delete result(s)\n   * - replace labels value with a question mark\n   *\n   * @param {Object} spans list of span for a trace\n   */\n  censorSpans (spans) {\n    if (!spans) return log('spans is null')\n    if (cst.DEBUG) return\n\n    spans.forEach((span) => {\n      if (!span.labels) return\n\n      delete span.labels.results\n      delete span.labels.result\n      delete span.spanId\n      delete span.parentSpanId\n      delete span.labels.values\n\n      Object.keys(span.labels).forEach((key) => {\n        if (typeof (span.labels[key]) === 'string' && key !== 'stacktrace') {\n          span.labels[key] = span.labels[key].replace(this.REGEX_JSON_CLEANUP, '\\\": \\\"?\\\"') // eslint-disable-line\n        }\n      })\n    })\n  }\n\n  /**\n   * Parse stackrace of spans to extract and normalize data\n   *\n   * @param {Object} spans list of span for a trace\n   */\n  parseStacktrace (spans) {\n    if (!spans) return log('spans is null')\n\n    spans.forEach((span) => {\n      // if empty make sure that it doesnt exist\n      if (!span ||\n          !span.labels ||\n          !span.labels.stacktrace ||\n          typeof (span.labels.stacktrace) !== 'string') return\n\n      // you never know what come through that door\n      try {\n        span.labels.stacktrace = JSON.parse(span.labels.stacktrace)\n      } catch (e) {\n        return\n      }\n\n      if (!span.labels.stacktrace || !(span.labels.stacktrace.stack_frame instanceof Array)) return\n      // parse the stacktrace\n      let result = this.stackParser.parse(span.labels.stacktrace.stack_frame)\n      if (result) {\n        span.labels['source/file'] = result.callsite || undefined\n        span.labels['source/context'] = result.context || undefined\n      }\n    })\n\n    spans.forEach((span) => {\n      if (!span || !span.labels) return\n      delete span.labels.stacktrace\n    })\n  }\n}\n"]}