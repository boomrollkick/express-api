'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var os = require('os');
var crypto = require('crypto');
var moment = require('moment');
var url = require('url');

var interfaceType = {
  v4: {
    default: '127.0.0.1',
    family: 'IPv4'
  },
  v6: {
    default: '::1',
    family: 'IPv6'
  }

  /**
   * Search for public network adress
   * @param {String} type the type of network interface, can be either 'v4' or 'v6'
   */
};var retrieveAddress = function retrieveAddress(type) {
  var interfce = interfaceType[type];
  var ret = interfce.default;
  var interfaces = os.networkInterfaces();

  Object.keys(interfaces).forEach(function (el) {
    interfaces[el].forEach(function (el2) {
      if (!el2.internal && el2.family === interfce.family) {
        ret = el2.address;
      }
    });
  });
  return ret;
};

/**
 * Simple cache implementation
 *
 * @param {Object} opts cache options
 * @param {Function} opts.miss function called when a key isn't found in the cache
 */

var Cache = function () {
  function Cache(opts) {
    _classCallCheck(this, Cache);

    this._cache = {};
    this._miss = opts.miss;
    this._ttl_time = opts.ttl;
    this._ttl = {};

    if (opts.ttl) {
      this._worker = setInterval(this.worker.bind(this), 1000);
    }
  }

  _createClass(Cache, [{
    key: 'worker',
    value: function worker() {
      var keys = Object.keys(this._ttl);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = this._ttl[key];
        if (moment().isAfter(value)) {
          delete this._cache[key];
          delete this._ttl[key];
        }
      }
    }

    /**
     * Get a value from the cache
     *
     * @param {String} key
     */

  }, {
    key: 'get',
    value: function get(key) {
      if (!key) return null;
      var value = this._cache[key];
      if (value) return value;

      value = this._miss(key);

      if (value) {
        this.set(key, value);
      }
      return value;
    }

    /**
     * Set a value in the cache
     *
     * @param {String} key
     * @param {Mixed} value
     */

  }, {
    key: 'set',
    value: function set(key, value) {
      if (!key || !value) return false;
      this._cache[key] = value;
      if (this._ttl_time) {
        this._ttl[key] = moment().add(this._ttl_time, 'seconds');
      }
      return true;
    }
  }, {
    key: 'reset',
    value: function reset() {
      this._cache = null;
      this._cache = {};
      this._ttl = null;
      this._ttl = {};
    }
  }]);

  return Cache;
}();

/**
 * StackTraceParser is used to parse callsite from stacktrace
 * and get from FS the context of the error (if available)
 *
 * @param {Cache} cache cache implementation used to query file from FS and get context
 */


var StackTraceParser = function () {
  function StackTraceParser(opts) {
    _classCallCheck(this, StackTraceParser);

    this._cache = opts.cache;
    this._context_size = opts.context;
  }

  _createClass(StackTraceParser, [{
    key: 'isAbsolute',
    value: function isAbsolute(path) {
      if (process.platform === 'win32') {
        // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
        var splitDeviceRe = /^([a-zA-Z]:|[\\/]{2}[^\\/]+[\\/]+[^\\/]+)?([\\/])?([\s\S]*?)$/;
        var result = splitDeviceRe.exec(path);
        var device = result[1] || '';
        var isUnc = Boolean(device && device.charAt(1) !== ':');
        // UNC paths are always absolute
        return Boolean(result[2] || isUnc);
      } else {
        return path.charAt(0) === '/';
      }
    }
  }, {
    key: 'parse',
    value: function parse(stack) {
      if (!stack || stack.length === 0) return false;

      for (var i = 0, len = stack.length; i < len; i++) {
        var callsite = stack[i];

        // avoid null values
        if ((typeof callsite === 'undefined' ? 'undefined' : _typeof(callsite)) !== 'object') continue;
        if (!callsite.file_name || !callsite.line_number) continue;

        var type = this.isAbsolute(callsite.file_name) || callsite.file_name[0] === '.' ? 'user' : 'core';

        // only use the callsite if its inside user space
        if (!callsite || type === 'core' || callsite.file_name.indexOf('node_modules') > -1 || callsite.file_name.indexOf('vxx') > -1) {
          continue;
        }

        // get the whole context (all lines) and cache them if necessary
        var context = this._cache.get(callsite.file_name);
        var source = [];
        if (context && context.length > 0) {
          // get line before the call
          var preLine = callsite.line_number - this._context_size - 1;
          var pre = context.slice(preLine > 0 ? preLine : 0, callsite.line_number - 1);
          if (pre && pre.length > 0) {
            pre.forEach(function (line) {
              source.push(line.replace(/\t/g, '  '));
            });
          }
          // get the line where the call has been made
          if (context[callsite.line_number - 1]) {
            source.push(context[callsite.line_number - 1].replace(/\t/g, '  ').replace('  ', '>>'));
          }
          // and get the line after the call
          var postLine = callsite.line_number + this._context_size;
          var post = context.slice(callsite.line_number, postLine);
          if (post && post.length > 0) {
            post.forEach(function (line) {
              source.push(line.replace(/\t/g, '  '));
            });
          }
        }
        return {
          context: source.length > 0 ? source.join('\n') : 'cannot retrieve source context',
          callsite: [callsite.file_name, callsite.line_number].join(':')
        };
      }
      return false;
    }
  }, {
    key: 'attachContext',
    value: function attachContext(error) {
      if (!error) return error;

      // if pmx attached callsites we can parse them to retrieve the context
      if (_typeof(error.stackframes) === 'object') {
        var result = this.parse(error.stackframes);
        // no need to send it since there is already the stacktrace
        delete error.stackframes;
        delete error.__error_callsites;

        if (result) {
          error.callsite = result.callsite;
          error.context = result.context;
        }
      }
      // if the stack is here we can parse it directly from the stack string
      // only if the context has been retrieved from elsewhere
      if (typeof error.stack === 'string' && !error.callsite) {
        var siteRegex = /(\/[^\\\n]*)/g;
        var tmp = void 0;
        var stack = [];

        // find matching groups
        while (tmp = siteRegex.exec(error.stack)) {
          stack.push(tmp[1]);
        }

        // parse each callsite to match the format used by the stackParser
        stack = stack.map(function (callsite) {
          // remove the trailing ) if present
          if (callsite[callsite.length - 1] === ')') {
            callsite = callsite.substr(0, callsite.length - 1);
          }
          var location = callsite.split(':');

          return location.length < 3 ? callsite : {
            file_name: location[0],
            line_number: parseInt(location[1])
          };
        });

        var finalCallsite = this.parse(stack);
        if (finalCallsite) {
          error.callsite = finalCallsite.callsite;
          error.context = finalCallsite.context;
        }
      }
      return error;
    }
  }]);

  return StackTraceParser;
}();

// EWMA = ExponentiallyWeightedMovingAverage from
// https://github.com/felixge/node-measured/blob/master/lib/util/ExponentiallyMovingWeightedAverage.js
// Copyright Felix GeisendÃ¶rfer <felix@debuggable.com> under MIT license


var EWMA = function () {
  function EWMA() {
    var _this = this;

    _classCallCheck(this, EWMA);

    this._timePeriod = 60000;
    this._tickInterval = 5000;
    this._alpha = 1 - Math.exp(-this._tickInterval / this._timePeriod);
    this._count = 0;
    this._rate = 0;
    this._interval = setInterval(function (_) {
      _this.tick();
    }, this._tickInterval);
    this._interval.unref();
  }

  _createClass(EWMA, [{
    key: 'update',
    value: function update(n) {
      this._count += n || 1;
    }
  }, {
    key: 'tick',
    value: function tick() {
      var instantRate = this._count / this._tickInterval;
      this._count = 0;
      this._rate += this._alpha * (instantRate - this._rate);
    }
  }, {
    key: 'rate',
    value: function rate(timeUnit) {
      return (this._rate || 0) * timeUnit;
    }
  }]);

  return EWMA;
}();

var Cipher = function () {
  function Cipher() {
    _classCallCheck(this, Cipher);
  }

  _createClass(Cipher, null, [{
    key: 'decipherMessage',


    /**
     * Decipher data using 256 bits key (AES)
     * @param {Hex} data input data
     * @param {String} key 256 bits key
     * @return {Object} deciphered data parsed as json object
     */
    value: function decipherMessage(msg, key) {
      try {
        var decipher = crypto.createDecipher(Cipher.CIPHER_ALGORITHM, key);
        var decipheredMessage = decipher.update(msg, 'hex', 'utf8');
        decipheredMessage += decipher.final('utf8');
        return JSON.parse(decipheredMessage);
      } catch (err) {
        console.error(err);
        return null;
      }
    }

    /**
     * Cipher data using 256 bits key (AES)
     * @param {String} data input data
     * @param {String} key 256 bits key
     * @return {Hex} ciphered data
     */

  }, {
    key: 'cipherMessage',
    value: function cipherMessage(data, key) {
      try {
        // stringify if not already done (fail safe)
        if (typeof data !== 'string') {
          data = JSON.stringify(data);
        }

        var cipher = crypto.createCipher(Cipher.CIPHER_ALGORITHM, key);
        var cipheredData = cipher.update(data, 'utf8', 'hex');
        cipheredData += cipher.final('hex');
        return cipheredData;
      } catch (err) {
        console.error(err);
      }
    }
  }, {
    key: 'CIPHER_ALGORITHM',
    get: function get() {
      return 'aes256';
    }
  }]);

  return Cipher;
}();

/**
 * HTTP wrapper
 */


var HTTPClient = function () {
  function HTTPClient() {
    _classCallCheck(this, HTTPClient);
  }

  _createClass(HTTPClient, [{
    key: 'getModule',

    /**
     * Return native module (HTTP/HTTPS)
     * @param {String} url
     */
    value: function getModule(url) {
      return url.match(/https:\/\//) ? require('https') : require('http');
    }
    /**
     * Send an HTTP request and return data or error if status > 200
     * @param {Object} opts
     * @param {String} opts.url
     * @param {String} opts.method
     * @param {Object} [opts.data]
     * @param {Object} [opts.headers]
     * @param {Function} cb invoked with <err, body>
     */

  }, {
    key: 'open',
    value: function open(opts, cb) {
      var http = this.getModule(opts.url);
      var parsedUrl = url.parse(opts.url);
      var data = null;
      var options = {
        hostname: parsedUrl.hostname,
        path: parsedUrl.path,
        port: parsedUrl.port,
        method: opts.method,
        headers: opts.headers
      };

      if (opts.data) {
        data = JSON.stringify(opts.data);
        options.headers = Object.assign({
          'Content-Type': 'application/json',
          'Content-Length': data.length
        }, opts.headers);
      }

      var req = http.request(options, function (res) {
        var body = '';

        res.setEncoding('utf8');
        res.on('data', function (chunk) {
          body += chunk.toString();
        });
        res.on('end', function () {
          try {
            var jsonData = JSON.parse(body);
            return cb(null, jsonData);
          } catch (err) {
            return cb(err);
          }
        });
      });
      req.on('error', cb);

      if (data) {
        req.write(data);
      }
      req.end();
    }
  }]);

  return HTTPClient;
}();

module.exports = {
  EWMA: EWMA,
  Cache: Cache,
  StackTraceParser: StackTraceParser,
  serialize: require('fclone'),
  network: {
    v4: retrieveAddress('v4'),
    v6: retrieveAddress('v6')
  },
  HTTPClient: HTTPClient,
  Cipher: Cipher,
  clone: require('fclone')
};
//# sourceMappingURL=Utility.js.map