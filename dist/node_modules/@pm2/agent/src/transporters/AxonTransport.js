'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var axon = require('pm2-axon');
var nssocket = require('nssocket');
var log = require('debug')('interactor:axon');
var cst = require('../../constants.js');
var Utility = require('../Utility.js');
var url = require('url');
var async = require('async');
var DataRetriever = require('../push/DataRetriever.js');
var Transporter = require('./Transporter');

/**
 * Axon Transport used to communicate with KM
 * @param {Object} opts options
 * @param {Daemon} daemon Interactor instance
 */
module.exports = function (_Transporter) {
  _inherits(AxonTransport, _Transporter);

  function AxonTransport(opts, daemon) {
    _classCallCheck(this, AxonTransport);

    var _this = _possibleConstructorReturn(this, (AxonTransport.__proto__ || Object.getPrototypeOf(AxonTransport)).call(this));

    log('AxonTransporter constructed');
    _this.opts = opts;
    _this._daemon = daemon;
    _this._socket = null;
    _this._axon = null;
    _this.buffer = {};
    _this.axonReconnectCounter = 0;

    _this._pushWorker = setInterval(_this._send.bind(_this), cst.STATUS_INTERVAL);
    return _this;
  }

  /**
   * Connect the axon client to a url
   * @param {String} url where the client will connect
   * @param {Function} cb invoked with <err>
   */


  _createClass(AxonTransport, [{
    key: 'connect',
    value: function connect(urls, cb) {
      var _this2 = this;

      log('Connecting axon transporter...');
      var self = this;
      if (typeof urls === 'function') {
        cb = urls;
        urls = this.urls;
      }
      this.urls = urls;
      var pullUrl = url.parse(urls.pull);
      var pullHost = pullUrl.hostname;
      var pullPort = pullUrl.port;
      var pushUrl = url.parse(urls.push);
      var pushHost = pushUrl.hostname;
      var pushPort = pushUrl.port;

      this._axon = axon.socket('pub');

      // Create connection to reverse interaction server
      this._socket = new nssocket.NsSocket({
        type: 'tcp4',
        reconnect: false,
        maxListeners: 50
      });
      // Authenticate request on reverse server
      this._socket.data('ask', function () {
        log('Authenticate axon transporter');
        var data = _this2._daemon.getSystemMetadata();
        for (var key in data) {
          data[key.toLowerCase()] = data[key];
          delete data[key];
        }
        data = Utility.Cipher.cipherMessage(JSON.stringify(data), _this2.opts.SECRET_KEY);

        // Send response
        if (!_this2._socket) return false; // disconnected before
        _this2._socket.send('ask:rep', {
          data: data,
          public_key: _this2.opts.PUBLIC_KEY
        });
        return false;
      });

      // Errors / close
      this._socket.on('close', function (_) {
        log('Got a close on nssocket connection');
        _this2._onClose();
      });
      this._socket.on('error', function (err) {
        log('Got an error on nssocket connection: ' + err.message);
        _this2._onError(err);
      });
      this._axon.on('close', function (_) {
        log('Got a close on axon connection');
      });
      this._axon.on('error', function (err) {
        log('Got an error on axon connection: ' + err.message);
      });
      this._axon.on('reconnect attempt', function (_) {
        log('Axon is trying to reconnect');
      });

      // Setup listener
      this._socket.data('*', function (data) {
        // Call _onMessage() with event and data as params
        // Apply self to use this as transport
        return self._onMessage.apply(self, [this, data]); // eslint-disable-line
      });

      // Connect to interaction/reverse server
      log('Connect axon with ' + pushHost + ':' + pushPort + ' and nssocket with ' + pullHost + ':' + pullPort);
      async.parallel([function (next) {
        return _this2._axon.connect(parseInt(pushPort), pushHost, next);
      }, function (next) {
        return _this2._socket.connect(parseInt(pullPort), pullHost, next);
      }], cb);
    }

    /**
     * Disconnect clients
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      log('Disconnect axon transporter');
      if (this._socket) {
        log('Destroy pull socket on axon transporter');
        this._socket.destroy();
      }
      if (this._axon) {
        log('Destroy push axon on axon transporter');
        this._axon.close();
      }
      this._axon = null;
      this._socket = null;
    }

    /**
     * Are push and reverse connections ready
     * @return {Boolean}
     */

  }, {
    key: 'isConnected',
    value: function isConnected() {
      var isNsSocketConnected = this._socket && this._socket.connected;
      var isAxonConnected = this._axon && this._axon.socks && this._axon.socks[0];
      if (!isNsSocketConnected) log('Nssocket is not connected anymore');
      if (!isAxonConnected) log('Axon is not connected anymore (Buffer: ' + (this._axon && this._axon.socks && this._axon.socks[0] ? this._axon.sock.socks[0].bufferSize : 0) + ')');
      return isNsSocketConnected && isAxonConnected;
    }

    /**
     * Send data to buffer
     * @param {String} channel
     * @param {Object} data
     */

  }, {
    key: 'send',
    value: function send(channel, data) {
      // Handle bad packet
      if (!channel || !data) return log('Trying to send message without all necessary fields');
      // Handle status
      if (channel === 'status' || channel === 'monitoring') return log('Status messages are handled manually with axon.');
      // Handle custom channels
      if (channel === 'profiling') return this.sendFile(data);
      if (channel.indexOf('trigger:') !== -1) return this.sendViaNssocket(channel, data);

      log('Sending packet to buffer over for channel %s', channel);
      if (!this.buffer[channel]) this.buffer[channel] = [];
      return this.buffer[channel].push(data);
    }

    /**
     * Send file
     * @param {Object} data
     */

  }, {
    key: 'sendFile',
    value: function sendFile(data) {
      if (!this.isConnected()) return log("Can't send file, axon is not connected");
      var meta = {
        pm_id: data.pm_id,
        name: data.name,
        server_name: data.server_name,
        public_key: data.public_key,
        type: data.type
      };
      meta[data.type] = true;

      return this._axon.send(JSON.stringify(meta), data.data);
    }

    /**
     * Prepare packet, add status
     * @param {Function} next
     */

  }, {
    key: 'preparePacket',
    value: function preparePacket(next) {
      var _this3 = this;

      if (typeof this._daemon.getPM2Client().rpc.getMonitorData !== 'function') return next(new Error('Not able to connect to PM2'));
      this._daemon.getPM2Client().rpc.getMonitorData({}, function (err, processes) {
        if (err || !processes) return next(err || new Error('Not able to retrieve PM2 processes'));

        log('Add status to packet');
        processes = processes.filter(function (proc) {
          return proc.pm2_env._km_monitored !== false;
        });
        _this3.buffer['status'] = {
          data: DataRetriever.status(processes, _this3.opts),
          server_name: _this3.opts.MACHINE_NAME,
          internal_ip: _this3.opts.internal_ip,
          rev_con: true
        };
        _this3.buffer.server_name = _this3.opts.MACHINE_NAME;
        return next();
      });
    }

    /**
     * Send buffer to endpoints
     */

  }, {
    key: '_send',
    value: function _send() {
      var _this4 = this;

      log('Sending data to endpoints (Buffer size: ' + Object.keys(this.buffer).length + ' keys [' + Object.keys(this.buffer).join(', ') + '])');
      if (!this.isConnected()) return log("Axon is not connected, can't send any data.");

      // Handle axon buffer size
      if (this._axon.socks[0].bufferSize > 290000) {
        this.buffer = {}; // reset buffer
        log('Axon buffer is too high (' + this._axon.socks[0].bufferSize + '), stop sending data to it.');
        if (++this.axonReconnectCounter > 20) {
          log('Forcing axon reconnection');
          this.axonReconnectCounter = 0;
          this.reconnect(this.urls, function (_) {
            log('Axon is now reconnected');
          });
        }
        return false;
      }

      // Send status with packet
      this.preparePacket(function (err) {
        if (err) return log('Got an error on packet preparation: ' + err.message);

        var packet = {
          public_key: _this4.opts.PUBLIC_KEY,
          data: Utility.Cipher.cipherMessage(_this4.buffer, _this4.opts.SECRET_KEY)
        };
        _this4.buffer = {}; // reset buffer
        return _this4._axon.sendv2(JSON.stringify(packet), function (_) {
          log('Buffer was sended.');
          packet = null;
        });
      });
    }

    /**
     * Send via nssocket
     */

  }, {
    key: 'sendViaNssocket',
    value: function sendViaNssocket(channel, data) {
      if (!this.isConnected()) return log("Can't send file, nssocket is not connected");
      return this._socket.send(channel, data);
    }

    /**
     * Broadcast the close event from websocket connection
     * @private
     * @param {Integer} code
     * @param {String} reason
     */

  }, {
    key: '_onMessage',
    value: function _onMessage(event, data) {
      if (!data) return;
      data = Utility.Cipher.decipherMessage(data, this.opts.SECRET_KEY);
      if (!data) return;

      // ensure that all required field are present
      var eventName = event.event.join(':').substr('data:'.length);
      log('Received event %s from reverse server, emit it', eventName);
      this.emit(eventName, data);
    }
  }]);

  return AxonTransport;
}(Transporter);
//# sourceMappingURL=AxonTransport.js.map