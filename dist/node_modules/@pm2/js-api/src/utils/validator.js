
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function RequestValidator() {
    _classCallCheck(this, RequestValidator);
  }

  _createClass(RequestValidator, null, [{
    key: 'extract',

    /**
     * Extract httpOptions from the endpoint definition
     * and the data given by the user
     *
     * @param {Object} endpoint endpoint definition
     * @param {Array} args arguments given by the user
     * @return {Promise} resolve to the http options need to make the request
     */
    value: function extract(endpoint, args) {
      var isDefined = function isDefined(val) {
        return val !== null && typeof val !== 'undefined';
      };

      return new Promise(function (resolve, reject) {
        var httpOpts = {
          params: {},
          data: {},
          url: endpoint.route.name + '',
          method: endpoint.route.type,
          authentication: endpoint.authentication || false
        };

        switch (endpoint.route.type) {
          // GET request, we assume data will only be in the query or url params
          case 'GET':
            {
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = (endpoint.params || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var param = _step.value;

                  var value = args.shift();
                  // params should always be a string since they will be replaced in the url
                  if (typeof value !== 'string' && param.optional === false) {
                    return reject(new Error('Expected to receive string argument for ' + param.name + ' to match but got ' + value));
                  }
                  if (value) {
                    // if value is given, use it
                    httpOpts.url = httpOpts.url.replace(param.name, value);
                  } else if (param.optional === false && param.defaultvalue !== null) {
                    // use default value if available
                    httpOpts.url = httpOpts.url.replace(param.name, param.defaultvalue);
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = (endpoint.query || [])[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var _param = _step2.value;

                  var _value = args.shift();
                  // query should always be a string since they will be replaced in the url
                  if (typeof _value !== 'string' && _param.optional === false) {
                    return reject(new Error('Expected to receive string argument for ' + _param.name + ' query but got ' + _value));
                  }
                  // set query value
                  if (_value) {
                    // if value is given, use it
                    httpOpts.params[_param.name] = _value;
                  } else if (_param.optional === false && _param.defaultvalue !== null) {
                    // use default value if available
                    httpOpts.params[_param.name] = _param.defaultvalue;
                  }
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }

              break;
            }
          // for PUT, POST and PATCH request, only params and body are authorized
          case 'PUT':
          case 'POST':
          case 'PATCH':
            {
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = (endpoint.params || [])[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var _param2 = _step3.value;

                  var _value2 = args.shift();
                  // params should always be a string since they will be replaced in the url
                  if (typeof _value2 !== 'string' && _param2.optional === false) {
                    return reject(new Error('Expected to receive string argument for ' + _param2.name + ' to match but got ' + _value2));
                  }
                  // replace param in url
                  if (_value2) {
                    // if value is given, use it
                    httpOpts.url = httpOpts.url.replace(_param2.name, _value2);
                  } else if (_param2.optional === false && _param2.defaultvalue !== null) {
                    // use default value if available
                    httpOpts.url = httpOpts.url.replace(_param2.name, _param2.defaultvalue);
                  }
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }

              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                for (var _iterator4 = (endpoint.query || [])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var _param3 = _step4.value;

                  var _value3 = args.shift();
                  // query should always be a string since they will be replaced in the url
                  if (typeof _value3 !== 'string' && _param3.optional === false) {
                    return reject(new Error('Expected to receive string argument for ' + _param3.name + ' query but got ' + _value3));
                  }
                  // set query value
                  if (_value3) {
                    // if value is given, use it
                    httpOpts.params[_param3.name] = _value3;
                  } else if (_param3.optional === false && _param3.defaultvalue !== null) {
                    // use default value if available
                    httpOpts.params[_param3.name] = _param3.defaultvalue;
                  }
                }
                // if we don't have any arguments, break
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }

              if (args.length === 0) break;
              var data = args[0];
              if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object' && endpoint.body.length > 0) {
                return reject(new Error('Expected to receive an object for post data but received ' + (typeof data === 'undefined' ? 'undefined' : _typeof(data))));
              }
              var _iteratorNormalCompletion5 = true;
              var _didIteratorError5 = false;
              var _iteratorError5 = undefined;

              try {
                for (var _iterator5 = (endpoint.body || [])[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                  var field = _step5.value;

                  // verify that the mandatory field are here
                  if (!isDefined(data[field.name]) && field.optional === false && field.defaultvalue === null) {
                    return reject(new Error('Missing mandatory field ' + field.name + ' to make a POST request on ' + endpoint.route.name));
                  }
                  // verify that the mandatory field are the good type
                  if (_typeof(data[field.name]) !== field.type && field.optional === false && field.defaultvalue === null) {
                    // eslint-disable-line 
                    return reject(new Error('Invalid type for field ' + field.name + ', expected ' + field.type + ' but got ' + _typeof(data[field.name])));
                  }

                  // add it to the request only when its present
                  if (isDefined(data[field.name])) {
                    httpOpts.data[field.name] = data[field.name];
                  }

                  // or else its not optional and has a default value
                  if (field.optional === false && field.defaultvalue !== null) {
                    httpOpts.data[field.name] = field.defaultvalue;
                  }
                }
              } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion5 && _iterator5.return) {
                    _iterator5.return();
                  }
                } finally {
                  if (_didIteratorError5) {
                    throw _iteratorError5;
                  }
                }
              }

              break;
            }
          // DELETE can have params or query parameters
          case 'DELETE':
            {
              var _iteratorNormalCompletion6 = true;
              var _didIteratorError6 = false;
              var _iteratorError6 = undefined;

              try {
                for (var _iterator6 = (endpoint.params || [])[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                  var _param4 = _step6.value;

                  var _value4 = args.shift();
                  // params should always be a string since they will be replaced in the url
                  if (typeof _value4 !== 'string' && _param4.optional === false) {
                    return reject(new Error('Expected to receive string argument for ' + _param4.name + ' to match but got ' + _value4));
                  }
                  // replace param in url
                  if (_value4) {
                    // if value is given, use it
                    httpOpts.url = httpOpts.url.replace(_param4.name, _value4);
                  } else if (_param4.optional === false && _param4.defaultvalue !== null) {
                    // use default value if available
                    httpOpts.url = httpOpts.url.replace(_param4.name, _param4.defaultvalue);
                  }
                }
              } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion6 && _iterator6.return) {
                    _iterator6.return();
                  }
                } finally {
                  if (_didIteratorError6) {
                    throw _iteratorError6;
                  }
                }
              }

              var _iteratorNormalCompletion7 = true;
              var _didIteratorError7 = false;
              var _iteratorError7 = undefined;

              try {
                for (var _iterator7 = (endpoint.query || [])[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                  var _param5 = _step7.value;

                  var _value5 = args.shift();
                  // query should always be a string
                  if (typeof _value5 !== 'string' && _param5.optional === false) {
                    return reject(new Error('Expected to receive string argument for ' + _param5.name + ' query but got ' + _value5));
                  }
                  // replace param in url
                  if (_value5) {
                    // if value is given, use it
                    httpOpts.params[_param5.name] = _value5;
                  } else if (_param5.optional === false && _param5.defaultvalue !== null) {
                    // use default value if available
                    httpOpts.params[_param5.name] = _param5.defaultvalue;
                  }
                }
              } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion7 && _iterator7.return) {
                    _iterator7.return();
                  }
                } finally {
                  if (_didIteratorError7) {
                    throw _iteratorError7;
                  }
                }
              }

              break;
            }
          default:
            {
              return reject(new Error('Invalid endpoint declaration, invalid method ' + endpoint.route.type + ' found'));
            }
        }
        return resolve(httpOpts);
      });
    }
  }]);

  return RequestValidator;
}();
//# sourceMappingURL=validator.js.map