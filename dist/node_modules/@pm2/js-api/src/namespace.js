
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Endpoint = require('./endpoint');
var logger = require('debug')('kmjs:namespace');

module.exports = function () {
  function Namespace(mapping, opts) {
    _classCallCheck(this, Namespace);

    logger('initialization namespace ' + opts.name);
    this.name = opts.name;
    this.http = opts.http;
    this.endpoints = [];
    this.namespaces = [];

    logger('building namespace ' + opts.name);
    for (var name in mapping) {
      var child = mapping[name];
      if ((typeof mapping === 'undefined' ? 'undefined' : _typeof(mapping)) === 'object' && !child.route) {
        // ignore the 'default' namespace that should bind to the parent namespace
        if (name === 'default') {
          // create the namespace
          var defaultNamespace = new Namespace(child, { name: name, http: this.http, services: opts.services });
          this.namespaces.push(defaultNamespace);
          // bind property of the default namespace to this namespace
          for (var key in defaultNamespace) {
            if (key === 'name' || key === 'opts') continue;
            this[key] = defaultNamespace[key];
          }
          continue;
        }
        // if the parent namespace is a object, the child are namespace too
        this.addNamespace(new Namespace(child, { name: name, http: this.http, services: opts.services }));
      } else {
        // otherwise its an endpoint
        if (child.service && opts.services && opts.services[child.service.name]) {
          child.service.baseURL = opts.services[child.service.name];
        }
        this.addEndpoint(new Endpoint(child));
      }
    }

    // logging namespaces
    if (this.namespaces.length > 0) {
      logger('namespace ' + this.name + ' contains namespaces : \n' + this.namespaces.map(function (namespace) {
        return namespace.name;
      }).join('\n') + '\n');
    }

    // logging endpoints
    if (this.endpoints.length > 0) {
      logger('Namespace ' + this.name + ' contains endpoints : \n' + this.endpoints.map(function (endpoint) {
        return endpoint.route.name;
      }).join('\n') + '\n');
    }
  }

  _createClass(Namespace, [{
    key: 'addNamespace',
    value: function addNamespace(namespace) {
      if (!namespace || namespace.name === this.name) {
        throw new Error('A namespace must not have the same name as the parent namespace');
      }
      if (!(namespace instanceof Namespace)) {
        throw new Error('addNamespace only accept Namespace instance');
      }

      this.namespaces.push(namespace);
      this[namespace.name] = namespace;
    }
  }, {
    key: 'addEndpoint',
    value: function addEndpoint(endpoint) {
      if (!endpoint || endpoint.name === this.name) {
        throw new Error('A endpoint must not have the same name as a namespace');
      }
      if (!(endpoint instanceof Endpoint)) {
        throw new Error('addNamespace only accept Namespace instance');
      }

      this.endpoints.push(endpoint);
      this[endpoint.name] = endpoint.build(this.http);
    }
  }]);

  return Namespace;
}();
//# sourceMappingURL=namespace.js.map