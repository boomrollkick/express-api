
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AuthStrategy = require('./strategy.js');
var http = require('http');
var fs = require('fs');
var url = require('url');
var exec = require('child_process').exec;
var async = require('async');
var path = require('path');
var os = require('os');

module.exports = function (_AuthStrategy) {
  _inherits(EmbedStrategy, _AuthStrategy);

  function EmbedStrategy() {
    _classCallCheck(this, EmbedStrategy);

    return _possibleConstructorReturn(this, (EmbedStrategy.__proto__ || Object.getPrototypeOf(EmbedStrategy)).apply(this, arguments));
  }

  _createClass(EmbedStrategy, [{
    key: 'retrieveTokens',

    // try to find a token
    value: function retrieveTokens(km, cb) {
      var _this2 = this;

      var verifyToken = function verifyToken(refresh) {
        return km.auth.retrieveToken({
          client_id: _this2.client_id,
          refresh_token: refresh
        });
      };
      async.tryEach([
      // try to find the token via the environement
      function (next) {
        if (!process.env.KM_TOKEN) {
          return next(new Error('No token in env'));
        }
        verifyToken(process.env.KM_TOKEN).then(function (res) {
          return next(null, res.data);
        }).catch(next);
      },
      // try to find it in the file system
      function (next) {
        fs.readFile(path.resolve(os.homedir(), '.keymetrics-tokens'), function (err, tokens) {
          if (err) return next(err);

          // verify that the token is valid
          tokens = JSON.parse(tokens || '{}');
          if (new Date(tokens.expire_at) > new Date(new Date().toISOString())) {
            return next(null, tokens);
          }

          verifyToken(tokens.refresh_token).then(function (res) {
            return next(null, res.data);
          }).catch(next);
        });
      },
      // otherwise make the whole flow
      function (next) {
        return _this2.launch(function (data) {
          // verify that the token is valid
          verifyToken(data.access_token).then(function (res) {
            return next(null, res.data);
          }).catch(next);
        });
      }], function (err, result) {
        if (result.refresh_token) {
          var file = path.resolve(os.homedir(), '.keymetrics-tokens');
          fs.writeFile(file, JSON.stringify(result), function () {
            return cb(err, result);
          });
        } else {
          return cb(err, result);
        }
      });
    }
  }, {
    key: 'launch',
    value: function launch(cb) {
      var _this3 = this;

      var shutdown = false;
      var server = http.createServer(function (req, res) {
        // only handle one request
        if (shutdown === true) return res.end();
        shutdown = true;

        var query = url.parse(req.url, true).query;

        res.write(' You can go back to your terminal now :) ');
        res.end();
        server.close();
        return cb(query);
      });
      server.listen(43532, function () {
        _this3.open('' + _this3.oauth_endpoint + _this3.oauth_query);
      });
    }
  }, {
    key: 'open',
    value: function open(target, appName, callback) {
      var opener = void 0;
      var escape = function escape(s) {
        return s.replace(/"/g, '\\"');
      };

      if (typeof appName === 'function') {
        callback = appName;
        appName = null;
      }

      switch (process.platform) {
        case 'darwin':
          {
            opener = appName ? 'open -a "' + escape(appName) + '"' : 'open';
            break;
          }
        case 'win32':
          {
            opener = appName ? 'start "" ' + escape(appName) + '"' : 'start ""';
            break;
          }
        default:
          {
            opener = appName ? escape(appName) : 'xdg-open';
            break;
          }
      }

      if (process.env.SUDO_USER) {
        opener = 'sudo -u ' + process.env.SUDO_USER + ' ' + opener;
      }
      return exec(opener + ' "' + escape(target) + '"', callback);
    }
  }, {
    key: 'deleteTokens',
    value: function deleteTokens(km) {
      return new Promise(function (resolve, reject) {
        // revoke the refreshToken
        km.auth.revoke().then(function (res) {
          // remove the token from the filesystem
          var file = path.resolve(os.homedir(), '.keymetrics-tokens');
          fs.unlinkSync(file);
          return resolve(res);
        }).catch(reject);
      });
    }
  }]);

  return EmbedStrategy;
}(AuthStrategy);
//# sourceMappingURL=embed_strategy.js.map