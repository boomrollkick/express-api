
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var axios = require('axios');
var AuthStrategy = require('./auth_strategies/strategy');
var constants = require('../constants');
var logger = require('debug')('kmjs:network');
var loggerHttp = require('debug')('kmjs:network:http');
var loggerWS = require('debug')('kmjs:network:ws');
var WS = require('./utils/websocket');
var EventEmitter = require('eventemitter2');
var async = require('async');

var BUFFERIZED = -1;

module.exports = function () {
  function NetworkWrapper(km, opts) {
    _classCallCheck(this, NetworkWrapper);

    logger('init network manager');
    opts.baseURL = opts.services.API || 'https://api.keymetrics.io';
    this.opts = opts;
    this.tokens = {
      refresh_token: null,
      access_token: null
    };
    this.km = km;
    this._queue = [];
    this._axios = axios.create(opts);
    this._websockets = [];
    this._endpoints = new Map();

    this.apiDateLag = 0;

    this.realtime = new EventEmitter({
      wildcard: true,
      delimiter: ':',
      newListener: false,
      maxListeners: 20
    });
    this.realtime.subscribe = this.subscribe.bind(this);
    this.realtime.unsubscribe = this.unsubscribe.bind(this);
    this.authenticated = false;
    this._setupDateLag();
  }

  _createClass(NetworkWrapper, [{
    key: '_setupDateLag',
    value: function _setupDateLag() {
      var _this = this;

      var updateApiDateLag = function updateApiDateLag(response) {
        if (response && response.headers && response.headers.date) {
          var headerDate = new Date(response.headers.date);
          var clientDate = new Date();

          // The header date is likely to be truncated to the second, so truncate the client date too
          headerDate.setMilliseconds(0);
          clientDate.setMilliseconds(0);

          _this.apiDateLag = headerDate - clientDate;
        }
      };

      this._axios.interceptors.response.use(function (response) {
        updateApiDateLag(response);
        return response;
      }, function (error) {
        updateApiDateLag(error.response);
        return Promise.reject(error);
      });
    }
  }, {
    key: '_queueUpdater',
    value: function _queueUpdater() {
      if (this.authenticated === false) return;

      if (this._queue.length > 0) {
        logger('Emptying requests queue (size: ' + this._queue.length + ')');
      }

      // when we are authenticated we can clear the queue
      while (this._queue.length > 0) {
        var promise = this._queue.shift();
        // make the request
        this.request(promise.request).then(promise.resolve, promise.reject);
      }
    }

    /**
     * Resolve the endpoint of the node to make the request to
     * because each bucket might be on a different node
     * @param {String} bucketID the bucket id
     *
     * @return {Promise}
     */

  }, {
    key: '_resolveBucketEndpoint',
    value: function _resolveBucketEndpoint(bucketID) {
      var _this2 = this;

      if (!bucketID) return Promise.reject(new Error('Missing argument : bucketID'));

      if (!this._endpoints.has(bucketID)) {
        var promise = this._axios.request({
          url: '/api/bucket/' + bucketID,
          method: 'GET',
          headers: {
            Authorization: 'Bearer ' + this.tokens.access_token
          }
        }).then(function (res) {
          var bucket = res.data;
          var node = _typeof(bucket.node) === 'object' ? bucket.node : bucket.node_cache;
          return node.endpoints.web;
        }).catch(function (e) {
          _this2._endpoints.delete(bucketID);
          throw e;
        });

        this._endpoints.set(bucketID, promise);
      }

      return this._endpoints.get(bucketID);
    }

    /**
     * Send a http request
     * @param {Object} opts
     * @param {String} [opts.method=GET] http method
     * @param {String} opts.url the full URL
     * @param {Object} [opts.data] body data
     * @param {Object} [opts.params] url params
     *
     * @return {Promise}
     */

  }, {
    key: 'request',
    value: function request(httpOpts) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        async.series([
        // verify that we don't need to buffer the request because authentication
        function (next) {
          if (_this3.authenticated === true || httpOpts.authentication === false) return next();

          loggerHttp('Queued request to ' + httpOpts.url);
          _this3._queue.push({
            resolve: resolve,
            reject: reject,
            request: httpOpts
          });
          // we need to stop the flow here
          return next(BUFFERIZED);
        },
        // we need to verify that the baseURL is correct
        function (next) {
          if (!httpOpts.url.match(/bucket\/[0-9a-fA-F]{24}/)) return next();
          // parse the bucket id from URL
          var bucketID = httpOpts.url.split('/')[3];
          // we need to retrieve where to send the request depending on the backend
          _this3._resolveBucketEndpoint(bucketID).then(function (endpoint) {
            httpOpts.baseURL = endpoint;
            // then continue the flow
            return next();
          }).catch(next);
        },
        // if the request has not been bufferized, make the request
        function (next) {
          // super trick to transform a promise response to a callback
          var successNext = function successNext(res) {
            return next(null, res);
          };
          loggerHttp('Making request to ' + httpOpts.url);

          if (!httpOpts.headers) {
            httpOpts.headers = {};
          }
          httpOpts.headers.Authorization = 'Bearer ' + _this3.tokens.access_token;

          _this3._axios.request(httpOpts).then(successNext).catch(function (error) {
            var response = error.response;
            // we only need to handle when code is 401 (which mean unauthenticated)
            if (response && response.status !== 401) return next(response);
            loggerHttp('Got unautenticated response, buffering request from now ...');

            // we tell the client to not send authenticated request anymore
            _this3.authenticated = false;

            loggerHttp('Asking to the oauth flow to retrieve new tokens');
            _this3.oauth_flow.retrieveTokens(_this3.km, function (err, data) {
              // if it fail, we fail the whole request
              if (err) {
                loggerHttp('Failed to retrieve new tokens : ' + (err.message || err));
                return next(response);
              }
              // if its good, we try to update the tokens
              loggerHttp('Succesfully retrieved new tokens');
              _this3._updateTokens(null, data, function (err, authenticated) {
                // if it fail, we fail the whole request
                if (err) return next(response);
                // then we can rebuffer the request
                loggerHttp('Re-buffering call to ' + httpOpts.url + ' since authenticated now');
                httpOpts.headers.Authorization = 'Bearer ' + _this3.tokens.access_token;
                return _this3._axios.request(httpOpts).then(successNext).catch(next);
              });
            });
          });
        }], function (err, results) {
          // if the flow is stoped because the request has been
          // buferred, we don't need to do anything
          if (err === BUFFERIZED) return;
          return err ? reject(err) : resolve(results[2]);
        });
      });
    }

    /**
     * Update the access token used by all the networking clients
     * @param {Error} err if any erro
     * @param {String} accessToken the token you want to use
     * @param {Function} [cb] invoked with <err, authenticated>
     * @private
     */

  }, {
    key: '_updateTokens',
    value: function _updateTokens(err, data, cb) {
      var _this4 = this;

      if (err) {
        console.error('Error while retrieving tokens:', err);
        // Try to logout/login user
        this.oauth_flow.deleteTokens(this.km);
        return console.error(err.response ? err.response.data : err.stack);
      }
      if (!data || !data.access_token || !data.refresh_token) throw new Error('Invalid tokens');

      this.tokens = data;

      loggerHttp('Registered new access_token : ' + data.access_token);
      this._websockets.forEach(function (websocket) {
        return websocket.updateAuthorization(data.access_token);
      });
      this._axios.defaults.headers.common['Authorization'] = 'Bearer ' + data.access_token;
      this._axios.request({
        url: '/api/bucket',
        method: 'GET',
        headers: {
          Authorization: 'Bearer ' + data.access_token
        }
      }).then(function (res) {
        loggerHttp('Cached ' + res.data.length + ' buckets for current user');
        _this4.authenticated = true;
        _this4._queueUpdater();
        return typeof cb === 'function' ? cb(null, true) : null;
      }).catch(function (err) {
        console.error('Error while retrieving buckets');
        console.error(err.response ? err.response.data : err);
        return typeof cb === 'function' ? cb(err) : null;
      });
    }

    /**
     * Specify a strategy to use when authenticating to server
     * @param {String|Function} flow the name of the flow to use or a custom implementation
     * @param {Object} [opts]
     * @param {String} [opts.client_id] the OAuth client ID to use to identify the application
     *  default to the one defined when instancing Keymetrics and fallback to 795984050 (custom tokens)
     * @throws invalid use of this function, either the flow don't exist or isn't correctly implemented
     */

  }, {
    key: 'useStrategy',
    value: function useStrategy(flow, opts) {
      if (!opts) opts = {};
      // if client not provided here, use the one given in the instance
      if (!opts.client_id) {
        opts.client_id = this.opts.OAUTH_CLIENT_ID;
      }

      // in the case of flow being a custom implementation
      if ((typeof flow === 'undefined' ? 'undefined' : _typeof(flow)) === 'object') {
        this.oauth_flow = flow;
        if (!this.oauth_flow.retrieveTokens || !this.oauth_flow.deleteTokens) {
          throw new Error('You must implement the Strategy interface to use it');
        }
        return this.oauth_flow.retrieveTokens(this.km, this._updateTokens.bind(this));
      }
      // otherwise fallback on the flow that are implemented
      if (typeof AuthStrategy.implementations(flow) === 'undefined') {
        throw new Error('The flow named ' + flow + ' doesn\'t exist');
      }
      var flowMeta = AuthStrategy.implementations(flow);

      // verify that the environnement condition is meet
      if (flowMeta.condition && constants.ENVIRONNEMENT !== flowMeta.condition) {
        throw new Error('The flow ' + flow + ' is reserved for ' + flowMeta.condition + ' environment');
      }
      var FlowImpl = flowMeta.nodule;
      this.oauth_flow = new FlowImpl(opts);
      return this.oauth_flow.retrieveTokens(this.km, this._updateTokens.bind(this));
    }

    /**
     * Subscribe to realtime from bucket
     * @param {String} bucketId bucket id
     * @param {Object} [opts]
     *
     * @return {Promise}
     */

  }, {
    key: 'subscribe',
    value: function subscribe(bucketId, opts) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        logger('Request endpoints for ' + bucketId);
        _this5.km.bucket.retrieve(bucketId).then(function (res) {
          var bucket = res.data;
          var connected = false;

          var endpoints = bucket.node.endpoints || bucket.node_cache.endpoints;
          var endpoint = endpoints.realtime || endpoints.web;
          endpoint = endpoint.replace('http', 'ws');
          if (_this5.opts.IS_DEBUG) {
            endpoint = endpoint.replace(':3000', ':4020');
          }
          loggerWS('Found endpoint for ' + bucketId + ' : ' + endpoint);

          // connect websocket client to the realtime endpoint
          var socket = new WS(endpoint + '/primus', _this5.tokens.access_token);
          socket.connected = false;
          socket.bucket = bucketId;

          var keepAliveHandler = function keepAliveHandler() {
            socket.ping();
          };
          var keepAliveInterval = null;

          var onConnect = function onConnect() {
            logger('Connected to ws endpoint : ' + endpoint + ' (bucket: ' + bucketId + ')');
            socket.connected = true;
            _this5.realtime.emit(bucket.public_id + ':connected');

            socket.send(JSON.stringify({
              action: 'active',
              public_id: bucket.public_id
            }));

            if (keepAliveInterval !== null) {
              clearInterval(keepAliveInterval);
              keepAliveInterval = null;
            }
            keepAliveInterval = setInterval(keepAliveHandler.bind(_this5), 5000);
            if (!connected) {
              connected = true;
              return resolve(socket);
            }
          };
          socket.onmaxreconnect = function (_) {
            if (!connected) {
              connected = true;
              return reject(new Error('Connection timeout'));
            }
          };
          socket.onopen = onConnect;
          socket.onreconnect = onConnect;

          socket.onunexpectedresponse = function (req, res) {
            if (res.statusCode === 401) {
              return _this5.oauth_flow.retrieveTokens(_this5.km, function (err, data) {
                if (err) return logger('Failed to retrieve tokens for ws: ' + err.message);
                logger('Succesfully retrieved new tokens for ws');
                _this5._updateTokens(null, data, function (err, authenticated) {
                  if (err) return logger('Failed to update tokens for ws: ' + err.message);
                  return socket._tryReconnect();
                });
              });
            }
            return socket._tryReconnect();
          };
          socket.onerror = function (err) {
            loggerWS('Error on ' + endpoint + ' (bucket: ' + bucketId + ')');
            loggerWS(err);

            _this5.realtime.emit(bucket.public_id + ':error', err);
          };

          socket.onclose = function () {
            logger('Closing ws connection ' + endpoint + ' (bucket: ' + bucketId + ')');
            socket.connected = false;
            _this5.realtime.emit(bucket.public_id + ':disconnected');

            if (keepAliveInterval !== null) {
              clearInterval(keepAliveInterval);
              keepAliveInterval = null;
            }
          };

          // broadcast in the bus
          socket.onmessage = function (msg) {
            loggerWS('Received message for bucket ' + bucketId + ' (' + (msg.data.length / 1000).toFixed(1) + ' Kb)');
            var data = null;
            try {
              data = JSON.parse(msg.data);
            } catch (e) {
              return loggerWS('Receive not json message for bucket ' + bucketId);
            }
            var packet = data.data[1];
            Object.keys(packet).forEach(function (event) {
              if (event === 'server_name') return;
              _this5.realtime.emit(bucket.public_id + ':' + (packet.server_name || 'none') + ':' + event, packet[event]);
            });
          };

          _this5._websockets.push(socket);
        }).catch(reject);
      });
    }

    /**
     * Unsubscribe realtime from bucket
     * @param {String} bucketId bucket id
     * @param {Object} [opts]
     *
     * @return {Promise}
     */

  }, {
    key: 'unsubscribe',
    value: function unsubscribe(bucketId, opts) {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        logger('Unsubscribe from realtime for ' + bucketId);
        var socket = _this6._websockets.find(function (socket) {
          return socket.bucket === bucketId;
        });
        if (!socket) {
          return reject(new Error('Realtime wasn\'t connected to ' + bucketId));
        }
        socket.close(1000, 'Disconnecting');
        logger('Succesfully unsubscribed from realtime for ' + bucketId);
        return resolve();
      });
    }
  }]);

  return NetworkWrapper;
}();
//# sourceMappingURL=network.js.map