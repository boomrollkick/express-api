{"version":3,"sources":["../../../../../src/node_modules/@pm2/js-api/src/network.js"],"names":["axios","require","AuthStrategy","constants","logger","loggerHttp","loggerWS","WS","EventEmitter","async","BUFFERIZED","module","exports","km","opts","baseURL","services","API","tokens","refresh_token","access_token","_queue","_axios","create","_websockets","_endpoints","Map","apiDateLag","realtime","wildcard","delimiter","newListener","maxListeners","subscribe","bind","unsubscribe","authenticated","_setupDateLag","updateApiDateLag","response","headers","date","headerDate","Date","clientDate","setMilliseconds","interceptors","use","error","Promise","reject","length","promise","shift","request","then","resolve","bucketID","Error","has","url","method","Authorization","res","bucket","data","node","node_cache","endpoints","web","catch","e","delete","set","get","httpOpts","series","authentication","next","push","match","split","_resolveBucketEndpoint","endpoint","successNext","status","oauth_flow","retrieveTokens","err","message","_updateTokens","results","cb","console","deleteTokens","stack","forEach","websocket","updateAuthorization","defaults","common","_queueUpdater","flow","client_id","OAUTH_CLIENT_ID","implementations","flowMeta","condition","ENVIRONNEMENT","FlowImpl","nodule","bucketId","retrieve","connected","replace","IS_DEBUG","socket","keepAliveHandler","ping","keepAliveInterval","onConnect","emit","public_id","send","JSON","stringify","action","clearInterval","setInterval","onmaxreconnect","onopen","onreconnect","onunexpectedresponse","req","statusCode","_tryReconnect","onerror","onclose","onmessage","msg","toFixed","parse","packet","Object","keys","event","server_name","find","close"],"mappings":"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","file":"network.js","sourcesContent":["\n'use strict'\n\nconst axios = require('axios')\nconst AuthStrategy = require('./auth_strategies/strategy')\nconst constants = require('../constants')\nconst logger = require('debug')('kmjs:network')\nconst loggerHttp = require('debug')('kmjs:network:http')\nconst loggerWS = require('debug')('kmjs:network:ws')\nconst WS = require('./utils/websocket')\nconst EventEmitter = require('eventemitter2')\nconst async = require('async')\n\nconst BUFFERIZED = -1\n\nmodule.exports = class NetworkWrapper {\n  constructor (km, opts) {\n    logger('init network manager')\n    opts.baseURL = opts.services.API || 'https://api.keymetrics.io'\n    this.opts = opts\n    this.tokens = {\n      refresh_token: null,\n      access_token: null\n    }\n    this.km = km\n    this._queue = []\n    this._axios = axios.create(opts)\n    this._websockets = []\n    this._endpoints = new Map()\n\n    this.apiDateLag = 0\n\n    this.realtime = new EventEmitter({\n      wildcard: true,\n      delimiter: ':',\n      newListener: false,\n      maxListeners: 20\n    })\n    this.realtime.subscribe = this.subscribe.bind(this)\n    this.realtime.unsubscribe = this.unsubscribe.bind(this)\n    this.authenticated = false\n    this._setupDateLag()\n  }\n\n  _setupDateLag () {\n    const updateApiDateLag = response => {\n      if (response && response.headers && response.headers.date) {\n        const headerDate = new Date(response.headers.date)\n        const clientDate = new Date()\n\n        // The header date is likely to be truncated to the second, so truncate the client date too\n        headerDate.setMilliseconds(0)\n        clientDate.setMilliseconds(0)\n\n        this.apiDateLag = headerDate - clientDate\n      }\n    }\n\n    this._axios.interceptors.response.use(\n      response => {\n        updateApiDateLag(response)\n        return response\n      },\n      error => {\n        updateApiDateLag(error.response)\n        return Promise.reject(error)\n      }\n    )\n  }\n\n  _queueUpdater () {\n    if (this.authenticated === false) return\n\n    if (this._queue.length > 0) {\n      logger(`Emptying requests queue (size: ${this._queue.length})`)\n    }\n\n    // when we are authenticated we can clear the queue\n    while (this._queue.length > 0) {\n      let promise = this._queue.shift()\n      // make the request\n      this.request(promise.request).then(promise.resolve, promise.reject)\n    }\n  }\n\n  /**\n   * Resolve the endpoint of the node to make the request to\n   * because each bucket might be on a different node\n   * @param {String} bucketID the bucket id\n   *\n   * @return {Promise}\n   */\n  _resolveBucketEndpoint (bucketID) {\n    if (!bucketID) return Promise.reject(new Error(`Missing argument : bucketID`))\n\n    if (!this._endpoints.has(bucketID)) {\n      const promise = this._axios.request({\n        url: `/api/bucket/${bucketID}`,\n        method: 'GET',\n        headers: {\n          Authorization: `Bearer ${this.tokens.access_token}`\n        }\n      })\n        .then((res) => {\n          const bucket = res.data\n          const node = typeof bucket.node === 'object' ? bucket.node : bucket.node_cache\n          return node.endpoints.web\n        })\n        .catch((e) => {\n          this._endpoints.delete(bucketID)\n          throw e\n        })\n\n      this._endpoints.set(bucketID, promise)\n    }\n\n    return this._endpoints.get(bucketID)\n  }\n\n  /**\n   * Send a http request\n   * @param {Object} opts\n   * @param {String} [opts.method=GET] http method\n   * @param {String} opts.url the full URL\n   * @param {Object} [opts.data] body data\n   * @param {Object} [opts.params] url params\n   *\n   * @return {Promise}\n   */\n  request (httpOpts) {\n    return new Promise((resolve, reject) => {\n      async.series([\n        // verify that we don't need to buffer the request because authentication\n        next => {\n          if (this.authenticated === true || httpOpts.authentication === false) return next()\n\n          loggerHttp(`Queued request to ${httpOpts.url}`)\n          this._queue.push({\n            resolve,\n            reject,\n            request: httpOpts\n          })\n          // we need to stop the flow here\n          return next(BUFFERIZED)\n        },\n        // we need to verify that the baseURL is correct\n        (next) => {\n          if (!httpOpts.url.match(/bucket\\/[0-9a-fA-F]{24}/)) return next()\n          // parse the bucket id from URL\n          let bucketID = httpOpts.url.split('/')[3]\n          // we need to retrieve where to send the request depending on the backend\n          this._resolveBucketEndpoint(bucketID)\n            .then(endpoint => {\n              httpOpts.baseURL = endpoint\n              // then continue the flow\n              return next()\n            }).catch(next)\n        },\n        // if the request has not been bufferized, make the request\n        next => {\n          // super trick to transform a promise response to a callback\n          const successNext = res => next(null, res)\n          loggerHttp(`Making request to ${httpOpts.url}`)\n\n          if (!httpOpts.headers) {\n            httpOpts.headers = {}\n          }\n          httpOpts.headers.Authorization = `Bearer ${this.tokens.access_token}`\n\n          this._axios.request(httpOpts)\n            .then(successNext)\n            .catch((error) => {\n              let response = error.response\n              // we only need to handle when code is 401 (which mean unauthenticated)\n              if (response && response.status !== 401) return next(response)\n              loggerHttp(`Got unautenticated response, buffering request from now ...`)\n\n              // we tell the client to not send authenticated request anymore\n              this.authenticated = false\n\n              loggerHttp(`Asking to the oauth flow to retrieve new tokens`)\n              this.oauth_flow.retrieveTokens(this.km, (err, data) => {\n                // if it fail, we fail the whole request\n                if (err) {\n                  loggerHttp(`Failed to retrieve new tokens : ${err.message || err}`)\n                  return next(response)\n                }\n                // if its good, we try to update the tokens\n                loggerHttp(`Succesfully retrieved new tokens`)\n                this._updateTokens(null, data, (err, authenticated) => {\n                  // if it fail, we fail the whole request\n                  if (err) return next(response)\n                  // then we can rebuffer the request\n                  loggerHttp(`Re-buffering call to ${httpOpts.url} since authenticated now`)\n                  httpOpts.headers.Authorization = `Bearer ${this.tokens.access_token}`\n                  return this._axios.request(httpOpts).then(successNext).catch(next)\n                })\n              })\n            })\n        }\n      ], (err, results) => {\n        // if the flow is stoped because the request has been\n        // buferred, we don't need to do anything\n        if (err === BUFFERIZED) return\n        return err ? reject(err) : resolve(results[2])\n      })\n    })\n  }\n\n  /**\n   * Update the access token used by all the networking clients\n   * @param {Error} err if any erro\n   * @param {String} accessToken the token you want to use\n   * @param {Function} [cb] invoked with <err, authenticated>\n   * @private\n   */\n  _updateTokens (err, data, cb) {\n    if (err) {\n      console.error('Error while retrieving tokens:', err)\n      // Try to logout/login user\n      this.oauth_flow.deleteTokens(this.km)\n      return console.error(err.response ? err.response.data : err.stack)\n    }\n    if (!data || !data.access_token || !data.refresh_token) throw new Error('Invalid tokens')\n\n    this.tokens = data\n\n    loggerHttp(`Registered new access_token : ${data.access_token}`)\n    this._websockets.forEach(websocket => websocket.updateAuthorization(data.access_token))\n    this._axios.defaults.headers.common['Authorization'] = `Bearer ${data.access_token}`\n    this._axios.request({\n      url: '/api/bucket',\n      method: 'GET',\n      headers: {\n        Authorization: `Bearer ${data.access_token}`\n      }\n    }).then((res) => {\n      loggerHttp(`Cached ${res.data.length} buckets for current user`)\n      this.authenticated = true\n      this._queueUpdater()\n      return typeof cb === 'function' ? cb(null, true) : null\n    }).catch((err) => {\n      console.error('Error while retrieving buckets')\n      console.error(err.response ? err.response.data : err)\n      return typeof cb === 'function' ? cb(err) : null\n    })\n  }\n\n  /**\n   * Specify a strategy to use when authenticating to server\n   * @param {String|Function} flow the name of the flow to use or a custom implementation\n   * @param {Object} [opts]\n   * @param {String} [opts.client_id] the OAuth client ID to use to identify the application\n   *  default to the one defined when instancing Keymetrics and fallback to 795984050 (custom tokens)\n   * @throws invalid use of this function, either the flow don't exist or isn't correctly implemented\n   */\n  useStrategy (flow, opts) {\n    if (!opts) opts = {}\n    // if client not provided here, use the one given in the instance\n    if (!opts.client_id) {\n      opts.client_id = this.opts.OAUTH_CLIENT_ID\n    }\n\n    // in the case of flow being a custom implementation\n    if (typeof flow === 'object') {\n      this.oauth_flow = flow\n      if (!this.oauth_flow.retrieveTokens || !this.oauth_flow.deleteTokens) {\n        throw new Error('You must implement the Strategy interface to use it')\n      }\n      return this.oauth_flow.retrieveTokens(this.km, this._updateTokens.bind(this))\n    }\n    // otherwise fallback on the flow that are implemented\n    if (typeof AuthStrategy.implementations(flow) === 'undefined') {\n      throw new Error(`The flow named ${flow} doesn't exist`)\n    }\n    let flowMeta = AuthStrategy.implementations(flow)\n\n    // verify that the environnement condition is meet\n    if (flowMeta.condition && constants.ENVIRONNEMENT !== flowMeta.condition) {\n      throw new Error(`The flow ${flow} is reserved for ${flowMeta.condition} environment`)\n    }\n    let FlowImpl = flowMeta.nodule\n    this.oauth_flow = new FlowImpl(opts)\n    return this.oauth_flow.retrieveTokens(this.km, this._updateTokens.bind(this))\n  }\n\n  /**\n   * Subscribe to realtime from bucket\n   * @param {String} bucketId bucket id\n   * @param {Object} [opts]\n   *\n   * @return {Promise}\n   */\n  subscribe (bucketId, opts) {\n    return new Promise((resolve, reject) => {\n      logger(`Request endpoints for ${bucketId}`)\n      this.km.bucket.retrieve(bucketId)\n        .then((res) => {\n          let bucket = res.data\n          let connected = false\n\n          const endpoints = bucket.node.endpoints || bucket.node_cache.endpoints\n          let endpoint = endpoints.realtime || endpoints.web\n          endpoint = endpoint.replace('http', 'ws')\n          if (this.opts.IS_DEBUG) {\n            endpoint = endpoint.replace(':3000', ':4020')\n          }\n          loggerWS(`Found endpoint for ${bucketId} : ${endpoint}`)\n\n          // connect websocket client to the realtime endpoint\n          let socket = new WS(`${endpoint}/primus`, this.tokens.access_token)\n          socket.connected = false\n          socket.bucket = bucketId\n\n          let keepAliveHandler = function () {\n            socket.ping()\n          }\n          let keepAliveInterval = null\n\n          let onConnect = () => {\n            logger(`Connected to ws endpoint : ${endpoint} (bucket: ${bucketId})`)\n            socket.connected = true\n            this.realtime.emit(`${bucket.public_id}:connected`)\n\n            socket.send(JSON.stringify({\n              action: 'active',\n              public_id: bucket.public_id\n            }))\n\n            if (keepAliveInterval !== null) {\n              clearInterval(keepAliveInterval)\n              keepAliveInterval = null\n            }\n            keepAliveInterval = setInterval(keepAliveHandler.bind(this), 5000)\n            if (!connected) {\n              connected = true\n              return resolve(socket)\n            }\n          }\n          socket.onmaxreconnect = _ => {\n            if (!connected) {\n              connected = true\n              return reject(new Error('Connection timeout'))\n            }\n          }\n          socket.onopen = onConnect\n          socket.onreconnect = onConnect\n\n          socket.onunexpectedresponse = (req, res) => {\n            if (res.statusCode === 401) {\n              return this.oauth_flow.retrieveTokens(this.km, (err, data) => {\n                if (err) return logger(`Failed to retrieve tokens for ws: ${err.message}`)\n                logger(`Succesfully retrieved new tokens for ws`)\n                this._updateTokens(null, data, (err, authenticated) => {\n                  if (err) return logger(`Failed to update tokens for ws: ${err.message}`)\n                  return socket._tryReconnect()\n                })\n              })\n            }\n            return socket._tryReconnect()\n          }\n          socket.onerror = (err) => {\n            loggerWS(`Error on ${endpoint} (bucket: ${bucketId})`)\n            loggerWS(err)\n\n            this.realtime.emit(`${bucket.public_id}:error`, err)\n          }\n\n          socket.onclose = () => {\n            logger(`Closing ws connection ${endpoint} (bucket: ${bucketId})`)\n            socket.connected = false\n            this.realtime.emit(`${bucket.public_id}:disconnected`)\n\n            if (keepAliveInterval !== null) {\n              clearInterval(keepAliveInterval)\n              keepAliveInterval = null\n            }\n          }\n\n          // broadcast in the bus\n          socket.onmessage = (msg) => {\n            loggerWS(`Received message for bucket ${bucketId} (${(msg.data.length / 1000).toFixed(1)} Kb)`)\n            let data = null\n            try {\n              data = JSON.parse(msg.data)\n            } catch (e) {\n              return loggerWS(`Receive not json message for bucket ${bucketId}`)\n            }\n            let packet = data.data[1]\n            Object.keys(packet).forEach((event) => {\n              if (event === 'server_name') return\n              this.realtime.emit(`${bucket.public_id}:${packet.server_name || 'none'}:${event}`, packet[event])\n            })\n          }\n\n          this._websockets.push(socket)\n        }).catch(reject)\n    })\n  }\n\n  /**\n   * Unsubscribe realtime from bucket\n   * @param {String} bucketId bucket id\n   * @param {Object} [opts]\n   *\n   * @return {Promise}\n   */\n  unsubscribe (bucketId, opts) {\n    return new Promise((resolve, reject) => {\n      logger(`Unsubscribe from realtime for ${bucketId}`)\n      let socket = this._websockets.find(socket => socket.bucket === bucketId)\n      if (!socket) {\n        return reject(new Error(`Realtime wasn't connected to ${bucketId}`))\n      }\n      socket.close(1000, 'Disconnecting')\n      logger(`Succesfully unsubscribed from realtime for ${bucketId}`)\n      return resolve()\n    })\n  }\n}\n"]}