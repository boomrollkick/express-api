{"version":3,"sources":["../../../src/node_modules/async-listener/glue.js"],"names":["wrap","require","HAS_CREATE_AL","HAS_BEFORE_AL","HAS_AFTER_AL","HAS_ERROR_AL","listeners","uid","inAsyncTick","listenerStack","asyncCatcher","asyncWrap","union","dest","added","destLength","length","addedLength","returned","j","i","missing","push","process","_fatalException","inErrorTick","errorValues","er","handled","listener","flags","value","error","pop","undefined","original","list","values","data","create","before","apply","arguments","after","_asyncFatalException","errorThrew","uncaughtCatcher","threw","x","removeListener","_originalNextTick","addListener","simpleWrap","wrapCallback","slice","AsyncListener","callbacks","prototype","createAsyncListener","TypeError","addAsyncListener","registered","removeAsyncListener","splice","module","exports"],"mappings":"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","file":"glue.js","sourcesContent":["var wrap = require('shimmer').wrap;\n\n/*\n *\n * CONSTANTS\n *\n */\nvar HAS_CREATE_AL = 1 << 0;\nvar HAS_BEFORE_AL = 1 << 1;\nvar HAS_AFTER_AL = 1 << 2;\nvar HAS_ERROR_AL = 1 << 3;\n\n/**\n * There is one list of currently active listeners that is mutated in place by\n * addAsyncListener and removeAsyncListener. This complicates error-handling,\n * for reasons that are discussed below.\n */\nvar listeners = [];\n\n/**\n * There can be multiple listeners with the same properties, so disambiguate\n * them by assigning them an ID at creation time.\n */\nvar uid = 0;\n\n/**\n * Ensure that errors coming from within listeners are handed off to domains,\n * process._fatalException, or uncaughtException without being treated like\n * user errors.\n */\nvar inAsyncTick = false;\n\n/**\n * Because asynchronous contexts can be nested, and errors can come from anywhere\n * in the stack, a little extra work is required to keep track of where in the\n * nesting we are. Because JS arrays are frequently mutated in place\n */\nvar listenerStack = [];\n\n/**\n * The error handler on a listener can capture errors thrown during synchronous\n * execution immediately after the listener is added. To capture both\n * synchronous and asynchronous errors, the error handler just uses the\n * \"global\" list of active listeners, and the rest of the code ensures that the\n * listener list is correct by using a stack of listener lists during\n * asynchronous execution.\n */\nvar asyncCatcher;\n\n/**\n * The guts of the system -- called each time an asynchronous event happens\n * while one or more listeners are active.\n */\nvar asyncWrap;\n\n/**\n * Simple helper function that's probably faster than using Array\n * filter methods and can be inlined.\n */\nfunction union(dest, added) {\n  var destLength = dest.length;\n  var addedLength = added.length;\n  var returned = [];\n\n  if (destLength === 0 && addedLength === 0) return returned;\n\n  for (var j  = 0; j < destLength; j++) returned[j] = dest[j];\n\n  if (addedLength === 0) return returned;\n\n  for (var i = 0; i < addedLength; i++) {\n    var missing = true;\n    for (j = 0; j < destLength; j++) {\n      if (dest[j].uid === added[i].uid) {\n        missing = false;\n        break;\n      }\n    }\n    if (missing) returned.push(added[i]);\n  }\n\n  return returned;\n}\n\n/*\n * For performance, split error-handlers and asyncCatcher up into two separate\n * code paths.\n */\n\n// 0.9+\nif (process._fatalException) {\n  /**\n   * Error handlers on listeners can throw, the catcher needs to be able to\n   * discriminate between exceptions thrown by user code, and exceptions coming\n   * from within the catcher itself. Use a global to keep track of which state\n   * the catcher is currently in.\n   */\n  var inErrorTick = false;\n\n  /**\n   * Throwing always happens synchronously. If the current array of values for\n   * the current list of asyncListeners is put in a module-scoped variable right\n   * before a call that can throw, it will always be correct when the error\n   * handlers are run.\n   */\n  var errorValues;\n\n  asyncCatcher = function asyncCatcher(er) {\n    var length = listeners.length;\n    if (inErrorTick || length === 0) return false;\n\n    var handled = false;\n\n    /*\n     * error handlers\n     */\n    inErrorTick = true;\n    for (var i = 0; i < length; ++i) {\n      var listener = listeners[i];\n      if ((listener.flags & HAS_ERROR_AL) === 0) continue;\n\n      var value = errorValues && errorValues[listener.uid];\n      handled = listener.error(value, er) || handled;\n    }\n    inErrorTick = false;\n\n    /* Test whether there are any listener arrays on the stack. In the case of\n     * synchronous throws when the listener is active, there may have been\n     * none pushed yet.\n     */\n    if (listenerStack.length > 0) listeners = listenerStack.pop();\n    errorValues = undefined;\n\n    return handled && !inAsyncTick;\n  };\n\n  asyncWrap = function asyncWrap(original, list, length) {\n    var values = [];\n\n    /*\n     * listeners\n     */\n    inAsyncTick = true;\n    for (var i = 0; i < length; ++i) {\n      var listener = list[i];\n      values[listener.uid] = listener.data;\n\n      if ((listener.flags & HAS_CREATE_AL) === 0) continue;\n\n      var value = listener.create(listener.data);\n      if (value !== undefined) values[listener.uid] = value;\n    }\n    inAsyncTick = false;\n\n    /* One of the main differences between this polyfill and the core\n     * asyncListener support is that core avoids creating closures by putting a\n     * lot of the state managemnt on the C++ side of Node (and of course also it\n     * bakes support for async listeners into the Node C++ API through the\n     * AsyncWrap class, which means that it doesn't monkeypatch basically every\n     * async method like this does).\n     */\n    return function () {\n      // put the current values where the catcher can see them\n      errorValues = values;\n\n      /* More than one listener can end up inside these closures, so save the\n       * current listeners on a stack.\n       */\n      listenerStack.push(listeners);\n\n      /* Activate both the listeners that were active when the closure was\n       * created and the listeners that were previously active.\n       */\n      listeners = union(list, listeners);\n\n      /*\n       * before handlers\n       */\n      inAsyncTick = true;\n      for (var i = 0; i < length; ++i) {\n        if ((list[i].flags & HAS_BEFORE_AL) > 0) {\n          list[i].before(this, values[list[i].uid]);\n        }\n      }\n      inAsyncTick = false;\n\n      // save the return value to pass to the after callbacks\n      var returned = original.apply(this, arguments);\n\n      /*\n       * after handlers (not run if original throws)\n       */\n      inAsyncTick = true;\n      for (i = 0; i < length; ++i) {\n        if ((list[i].flags & HAS_AFTER_AL) > 0) {\n          list[i].after(this, values[list[i].uid]);\n        }\n      }\n      inAsyncTick = false;\n\n      // back to the previous listener list on the stack\n      listeners = listenerStack.pop();\n      errorValues = undefined;\n\n      return returned;\n    };\n  };\n\n  wrap(process, '_fatalException', function (_fatalException) {\n    return function _asyncFatalException(er) {\n      return asyncCatcher(er) || _fatalException(er);\n    };\n  });\n}\n// 0.8 and below\nelse {\n  /**\n   * If an error handler in asyncWrap throws, the process must die. Under 0.8\n   * and earlier the only way to put a bullet through the head of the process\n   * is to rethrow from inside the exception handler, so rethrow and set\n   * errorThrew to tell the uncaughtHandler what to do.\n   */\n  var errorThrew = false;\n\n  /**\n   * Under Node 0.8, this handler *only* handles synchronously thrown errors.\n   * This simplifies it, which almost but not quite makes up for the hit taken\n   * by putting everything in a try-catch.\n   */\n  asyncCatcher = function uncaughtCatcher(er) {\n    // going down hard\n    if (errorThrew) throw er;\n\n    var handled = false;\n\n    /*\n     * error handlers\n     */\n    var length = listeners.length;\n    for (var i = 0; i < length; ++i) {\n      var listener = listeners[i];\n      if ((listener.flags & HAS_ERROR_AL) === 0) continue;\n      handled = listener.error(null, er) || handled;\n    }\n\n    /* Rethrow if one of the before / after handlers fire, which will bring the\n     * process down immediately.\n     */\n    if (!handled && inAsyncTick) throw er;\n  };\n\n  asyncWrap = function asyncWrap(original, list, length) {\n    var values = [];\n\n    /*\n     * listeners\n     */\n    inAsyncTick = true;\n    for (var i = 0; i < length; ++i) {\n      var listener = list[i];\n      values[listener.uid] = listener.data;\n\n      if ((listener.flags & HAS_CREATE_AL) === 0) continue;\n\n      var value = listener.create(listener.data);\n      if (value !== undefined) values[listener.uid] = value;\n    }\n    inAsyncTick = false;\n\n    /* One of the main differences between this polyfill and the core\n     * asyncListener support is that core avoids creating closures by putting a\n     * lot of the state managemnt on the C++ side of Node (and of course also it\n     * bakes support for async listeners into the Node C++ API through the\n     * AsyncWrap class, which means that it doesn't monkeypatch basically every\n     * async method like this does).\n     */\n    return function () {\n      /*jshint maxdepth:4*/\n\n      // after() handlers don't run if threw\n      var threw = false;\n\n      // ...unless the error is handled\n      var handled = false;\n\n      /* More than one listener can end up inside these closures, so save the\n       * current listeners on a stack.\n       */\n      listenerStack.push(listeners);\n\n      /* Activate both the listeners that were active when the closure was\n       * created and the listeners that were previously active.\n       */\n      listeners = union(list, listeners);\n\n      /*\n       * before handlers\n       */\n      inAsyncTick = true;\n      for (var i = 0; i < length; ++i) {\n        if ((list[i].flags & HAS_BEFORE_AL) > 0) {\n          list[i].before(this, values[list[i].uid]);\n        }\n      }\n      inAsyncTick = false;\n\n      // save the return value to pass to the after callbacks\n      var returned;\n      try {\n        returned = original.apply(this, arguments);\n      }\n      catch (er) {\n        threw = true;\n        for (var i = 0; i < length; ++i) {\n          if ((listeners[i].flags & HAS_ERROR_AL) == 0) continue;\n          try {\n            handled = listeners[i].error(values[list[i].uid], er) || handled;\n          }\n          catch (x) {\n            errorThrew = true;\n            throw x;\n          }\n        }\n\n        if (!handled) {\n          // having an uncaughtException handler here alters crash semantics\n          process.removeListener('uncaughtException', asyncCatcher);\n          process._originalNextTick(function () {\n            process.addListener('uncaughtException', asyncCatcher);\n          });\n\n          throw er;\n        }\n      }\n      finally {\n        /*\n         * after handlers (not run if original throws)\n         */\n        if (!threw || handled) {\n          inAsyncTick = true;\n          for (i = 0; i < length; ++i) {\n            if ((list[i].flags & HAS_AFTER_AL) > 0) {\n              list[i].after(this, values[list[i].uid]);\n            }\n          }\n          inAsyncTick = false;\n        }\n\n        // back to the previous listener list on the stack\n        listeners = listenerStack.pop();\n      }\n\n\n      return returned;\n    };\n  };\n\n  // will be the first to fire if async-listener is the first module loaded\n  process.addListener('uncaughtException', asyncCatcher);\n}\n\n// for performance in the case where there are no handlers, just the listener\nfunction simpleWrap(original, list, length) {\n  inAsyncTick = true;\n  for (var i = 0; i < length; ++i) {\n    var listener = list[i];\n    if (listener.create) listener.create(listener.data);\n  }\n  inAsyncTick = false;\n\n  // still need to make sure nested async calls are made in the context\n  // of the listeners active at their creation\n  return function () {\n    listenerStack.push(listeners);\n    listeners = union(list, listeners);\n\n    var returned = original.apply(this, arguments);\n\n    listeners = listenerStack.pop();\n\n    return returned;\n  };\n}\n\n/**\n * Called each time an asynchronous function that's been monkeypatched in\n * index.js is called. If there are no listeners, return the function\n * unwrapped.  If there are any asyncListeners and any of them have callbacks,\n * pass them off to asyncWrap for later use, otherwise just call the listener.\n */\nfunction wrapCallback(original) {\n  var length = listeners.length;\n\n  // no context to capture, so avoid closure creation\n  if (length === 0) return original;\n\n  // capture the active listeners as of when the wrapped function was called\n  var list = listeners.slice();\n\n  for (var i = 0; i < length; ++i) {\n    if (list[i].flags > 0) return asyncWrap(original, list, length);\n  }\n\n  return simpleWrap(original, list, length);\n}\n\nfunction AsyncListener(callbacks, data) {\n  if (typeof callbacks.create === 'function') {\n    this.create = callbacks.create;\n    this.flags |= HAS_CREATE_AL;\n  }\n\n  if (typeof callbacks.before === 'function') {\n    this.before = callbacks.before;\n    this.flags |= HAS_BEFORE_AL;\n  }\n\n  if (typeof callbacks.after === 'function') {\n    this.after = callbacks.after;\n    this.flags |= HAS_AFTER_AL;\n  }\n\n  if (typeof callbacks.error === 'function') {\n    this.error = callbacks.error;\n    this.flags |= HAS_ERROR_AL;\n  }\n\n  this.uid = ++uid;\n  this.data = data === undefined ? null : data;\n}\nAsyncListener.prototype.create = undefined;\nAsyncListener.prototype.before = undefined;\nAsyncListener.prototype.after  = undefined;\nAsyncListener.prototype.error  = undefined;\nAsyncListener.prototype.data   = undefined;\nAsyncListener.prototype.uid    = 0;\nAsyncListener.prototype.flags  = 0;\n\nfunction createAsyncListener(callbacks, data) {\n  if (typeof callbacks !== 'object' || !callbacks) {\n    throw new TypeError('callbacks argument must be an object');\n  }\n\n  if (callbacks instanceof AsyncListener) {\n    return callbacks;\n  }\n  else {\n    return new AsyncListener(callbacks, data);\n  }\n}\n\nfunction addAsyncListener(callbacks, data) {\n  var listener;\n  if (!(callbacks instanceof AsyncListener)) {\n    listener = createAsyncListener(callbacks, data);\n  }\n  else {\n    listener = callbacks;\n  }\n\n  // Make sure the listener isn't already in the list.\n  var registered = false;\n  for (var i = 0; i < listeners.length; i++) {\n    if (listener === listeners[i]) {\n      registered = true;\n      break;\n    }\n  }\n\n  if (!registered) listeners.push(listener);\n\n  return listener;\n}\n\nfunction removeAsyncListener(listener) {\n  for (var i = 0; i < listeners.length; i++) {\n    if (listener === listeners[i]) {\n      listeners.splice(i, 1);\n      break;\n    }\n  }\n}\n\nprocess.createAsyncListener = createAsyncListener;\nprocess.addAsyncListener    = addAsyncListener;\nprocess.removeAsyncListener = removeAsyncListener;\n\nmodule.exports = wrapCallback;\n"]}