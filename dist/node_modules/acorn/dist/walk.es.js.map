{"version":3,"sources":["../../../../src/node_modules/acorn/dist/walk.es.js"],"names":["simple","node","visitors","baseVisitor","state","override","base","c","st","type","found","ancestor","ancestors","isNew","length","push","pop","recursive","funcs","visitor","make","undefined","makeTest","test","Found","full","callback","fullAncestor","findNodeAt","start","end","e","findNodeAround","pos","findNodeAfter","findNodeBefore","max","create","Object","proto","Ctor","prototype","skipThrough","ignore","_node","_st","_c","Program","BlockStatement","i","list","body","stmt","Statement","EmptyStatement","ExpressionStatement","ParenthesizedExpression","expression","IfStatement","consequent","alternate","LabeledStatement","BreakStatement","ContinueStatement","WithStatement","object","SwitchStatement","discriminant","cases","cs","i$1","list$1","cons","SwitchCase","ReturnStatement","YieldExpression","AwaitExpression","argument","ThrowStatement","SpreadElement","TryStatement","block","handler","finalizer","CatchClause","param","WhileStatement","DoWhileStatement","ForStatement","init","update","ForInStatement","ForOfStatement","left","right","ForInit","DebuggerStatement","FunctionDeclaration","VariableDeclaration","declarations","decl","VariableDeclarator","id","Function","params","ScopeBody","ScopeExpression","Pattern","VariablePattern","MemberPattern","RestElement","ArrayPattern","elements","elt","ObjectPattern","properties","prop","computed","key","value","Expression","ThisExpression","Super","MetaProperty","ArrayExpression","ObjectExpression","FunctionExpression","ArrowFunctionExpression","SequenceExpression","TemplateLiteral","expressions","expr","UnaryExpression","UpdateExpression","BinaryExpression","LogicalExpression","AssignmentExpression","AssignmentPattern","ConditionalExpression","NewExpression","CallExpression","callee","arguments","arg","MemberExpression","property","ExportNamedDeclaration","ExportDefaultDeclaration","declaration","source","ExportAllDeclaration","ImportDeclaration","specifiers","spec","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","Identifier","Literal","TaggedTemplateExpression","tag","quasi","ClassDeclaration","ClassExpression","Class","superClass","ClassBody","MethodDefinition","Property"],"mappings":"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","file":"walk.es.js","sourcesContent":["// AST walker module for Mozilla Parser API compatible trees\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression,\n// Statement, and ScopeBody, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n\nfunction simple(node, visitors, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st); }\n  })(node, state, override);\n}\n\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\nfunction ancestor(node, visitors, baseVisitor, state) {\n  var ancestors = [];\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st || ancestors, ancestors); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state);\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nfunction recursive(node, state, funcs, baseVisitor, override) {\n  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;(function c(node, st, override) {\n    visitor[override || node.type](node, st, c);\n  })(node, state, override);\n}\n\nfunction makeTest(test) {\n  if (typeof test === \"string\")\n    { return function (type) { return type === test; } }\n  else if (!test)\n    { return function () { return true; } }\n  else\n    { return test }\n}\n\nvar Found = function Found(node, state) { this.node = node; this.state = state; };\n\n// A full walk triggers the callback on each node\nfunction full(node, callback, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type;\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st, type); }\n  })(node, state, override);\n}\n\n// An fullAncestor walk is like an ancestor walk, but triggers\n// the callback on each node\nfunction fullAncestor(node, callback, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  var ancestors = [];(function c(node, st, override) {\n    var type = override || node.type;\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st || ancestors, ancestors, type); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state);\n}\n\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nfunction findNodeAt(node, start, end, test, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  test = makeTest(test);\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if ((start == null || node.start <= start) &&\n          (end == null || node.end >= end))\n        { baseVisitor[type](node, st, c); }\n      if ((start == null || node.start === start) &&\n          (end == null || node.end === end) &&\n          test(type, node))\n        { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nfunction findNodeAround(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if (node.start > pos || node.end < pos) { return }\n      baseVisitor[type](node, st, c);\n      if (test(type, node)) { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node after a given position.\nfunction findNodeAfter(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      if (node.end < pos) { return }\n      var type = override || node.type;\n      if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node before a given position.\nfunction findNodeBefore(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  var max;(function c(node, st, override) {\n    if (node.start > pos) { return }\n    var type = override || node.type;\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n      { max = new Found(node, st); }\n    baseVisitor[type](node, st, c);\n  })(node, state);\n  return max\n}\n\n// Fallback to an Object.create polyfill for older environments.\nvar create = Object.create || function(proto) {\n  function Ctor() {}\n  Ctor.prototype = proto;\n  return new Ctor\n};\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nfunction make(funcs, baseVisitor) {\n  var visitor = create(baseVisitor || base);\n  for (var type in funcs) { visitor[type] = funcs[type]; }\n  return visitor\n}\n\nfunction skipThrough(node, st, c) { c(node, st); }\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nvar base = {};\n\nbase.Program = base.BlockStatement = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var stmt = list[i];\n\n    c(stmt, st, \"Statement\");\n  }\n};\nbase.Statement = skipThrough;\nbase.EmptyStatement = ignore;\nbase.ExpressionStatement = base.ParenthesizedExpression =\n  function (node, st, c) { return c(node.expression, st, \"Expression\"); };\nbase.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Statement\");\n  if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n};\nbase.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\nbase.BreakStatement = base.ContinueStatement = ignore;\nbase.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\");\n  for (var i = 0, list = node.cases; i < list.length; i += 1) {\n    var cs = list[i];\n\n    if (cs.test) { c(cs.test, st, \"Expression\"); }\n    for (var i$1 = 0, list$1 = cs.consequent; i$1 < list$1.length; i$1 += 1)\n      {\n      var cons = list$1[i$1];\n\n      c(cons, st, \"Statement\");\n    }\n  }\n};\nbase.SwitchCase = function (node, st, c) {\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  for (var i = 0, list = node.consequent; i < list.length; i += 1)\n    {\n    var cons = list[i];\n\n    c(cons, st, \"Statement\");\n  }\n};\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n  if (node.argument) { c(node.argument, st, \"Expression\"); }\n};\nbase.ThrowStatement = base.SpreadElement =\n  function (node, st, c) { return c(node.argument, st, \"Expression\"); };\nbase.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\");\n  if (node.handler) { c(node.handler, st); }\n  if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n};\nbase.CatchClause = function (node, st, c) {\n  if (node.param) { c(node.param, st, \"Pattern\"); }\n  c(node.body, st, \"ScopeBody\");\n};\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForStatement = function (node, st, c) {\n  if (node.init) { c(node.init, st, \"ForInit\"); }\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  if (node.update) { c(node.update, st, \"Expression\"); }\n  c(node.body, st, \"Statement\");\n};\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\");\n  c(node.right, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForInit = function (node, st, c) {\n  if (node.type === \"VariableDeclaration\") { c(node, st); }\n  else { c(node, st, \"Expression\"); }\n};\nbase.DebuggerStatement = ignore;\n\nbase.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\nbase.VariableDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.declarations; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    c(decl, st);\n  }\n};\nbase.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\");\n  if (node.init) { c(node.init, st, \"Expression\"); }\n};\n\nbase.Function = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    c(param, st, \"Pattern\");\n  }\n  c(node.body, st, node.expression ? \"ScopeExpression\" : \"ScopeBody\");\n};\n// FIXME drop these node types in next major version\n// (They are awkward, and in ES6 every block can be a scope.)\nbase.ScopeBody = function (node, st, c) { return c(node, st, \"Statement\"); };\nbase.ScopeExpression = function (node, st, c) { return c(node, st, \"Expression\"); };\n\nbase.Pattern = function (node, st, c) {\n  if (node.type === \"Identifier\")\n    { c(node, st, \"VariablePattern\"); }\n  else if (node.type === \"MemberExpression\")\n    { c(node, st, \"MemberPattern\"); }\n  else\n    { c(node, st); }\n};\nbase.VariablePattern = ignore;\nbase.MemberPattern = skipThrough;\nbase.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\nbase.ArrayPattern = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Pattern\"); }\n  }\n};\nbase.ObjectPattern = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n\n    if (prop.type === \"Property\") {\n      if (prop.computed) { c(prop.key, st, \"Expression\"); }\n      c(prop.value, st, \"Pattern\");\n    } else if (prop.type === \"RestElement\") {\n      c(prop.argument, st, \"Pattern\");\n    }\n  }\n};\n\nbase.Expression = skipThrough;\nbase.ThisExpression = base.Super = base.MetaProperty = ignore;\nbase.ArrayExpression = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Expression\"); }\n  }\n};\nbase.ObjectExpression = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1)\n    {\n    var prop = list[i];\n\n    c(prop, st);\n  }\n};\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\nbase.SequenceExpression = base.TemplateLiteral = function (node, st, c) {\n  for (var i = 0, list = node.expressions; i < list.length; i += 1)\n    {\n    var expr = list[i];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\");\n};\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\");\n  c(node.right, st, \"Expression\");\n};\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\");\n  c(node.right, st, \"Expression\");\n};\nbase.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Expression\");\n  c(node.alternate, st, \"Expression\");\n};\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\");\n  if (node.arguments)\n    { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n      {\n        var arg = list[i];\n\n        c(arg, st, \"Expression\");\n      } }\n};\nbase.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  if (node.computed) { c(node.property, st, \"Expression\"); }\n};\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration)\n    { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n  if (node.source) { c(node.source, st, \"Expression\"); }\n};\nbase.ExportAllDeclaration = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\nbase.ImportDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n    {\n    var spec = list[i];\n\n    c(spec, st);\n  }\n  c(node.source, st, \"Expression\");\n};\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore;\n\nbase.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\");\n  c(node.quasi, st, \"Expression\");\n};\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\nbase.Class = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n  c(node.body, st);\n};\nbase.ClassBody = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var elt = list[i];\n\n    c(elt, st);\n  }\n};\nbase.MethodDefinition = base.Property = function (node, st, c) {\n  if (node.computed) { c(node.key, st, \"Expression\"); }\n  c(node.value, st, \"Expression\");\n};\n\nexport { simple, ancestor, recursive, full, fullAncestor, findNodeAt, findNodeAround, findNodeAfter, findNodeBefore, make, base };\n"]}