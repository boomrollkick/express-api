{"version":3,"sources":["../../../../src/node_modules/argparse/lib/argument_parser.js"],"names":["util","require","format","Path","sprintf","c","$$","ActionContainer","argumentErrorHelper","HelpFormatter","Namespace","ArgumentParser","options","self","description","argumentDefault","prefixChars","conflictHandler","call","addHelp","parents","prog","basename","process","argv","usage","epilog","version","debug","formatterClass","fromfilePrefixChars","_positionals","addArgumentGroup","title","_optionals","_subparsers","FUNCTION_IDENTITY","o","register","x","result","parseInt","isNaN","Error","parseFloat","defaultPrefix","indexOf","addArgument","action","defaultValue","SUPPRESS","help","forEach","parent","_addContainerActions","_defaults","defaultKey","hasOwnProperty","inherits","prototype","addSubparsers","error","optionStrings","parserClass","formatter","_getFormatter","positionals","_getPositionalActions","groups","_mutuallyExclusiveGroups","addUsage","formatHelp","trim","ParsersClass","_popActionClass","_addAction","isOptional","_getOptionalActions","_actions","filter","isPositional","parseArgs","args","namespace","parseKnownArgs","length","join","slice","dest","has","_getValue","Object","keys","res","_parseKnownArgs","_UNRECOGNIZED_ARGS_ATTR","arrayUnion","e","argStrings","extras","_readArgsFromFiles","actionHash","getName","conflicts","key","actionConflicts","mutexGroup","_groupActions","mutexAction","i","groupActions","push","apply","optionStringIndices","argStringPatternParts","argString","argStringIndex","pattern","optionTuple","_parseOptional","argStringsPattern","seenActions","seenNonDefaultActions","takeAction","argumentStrings","optionString","argumentValues","_getValues","actionConflict","consumeOptional","startIndex","explicitArg","actionTuples","argCount","start","stop","_matchArgument","chars","newExplicitArg","optionalsMap","_optionStringActions","selectedPatterns","substr","consumePositionals","selectedPattern","argCounts","_matchArgumentsPartial","position","maxOptionStringIndex","Math","max","positionalsEndIndex","nextOptionStringIndex","min","strings","concat","stopIndex","required","actionUsed","group","some","names","msg","fs","newArgStrings","argstrs","filename","content","readFileSync","split","argLine","convertArgLineToArgs","arg","message","regexpArgStrings","regexpNargs","RegExp","_getNargsPattern","matches","match","nargs","undefined","OPTIONAL","ONE_OR_MORE","actions","actionSlice","j","getLength","string","splice","map","argExplicit","optionTuples","_getOptionTuples","_regexpNegativeNumber","_hasNegativeNumberOptionals","Boolean","search","optionPrefix","actionOptionString","optionStringSplit","optionPrefixShort","argExplicitShort","ZERO_OR_MORE","REMAINDER","PARSER","repeat","replace","arrayElement","value","constant","_checkValue","v","typeFunction","_registryGet","type","name","displayName","choices","Array","isArray","formatUsage","addText","_actionGroups","actionGroup","startSection","addArguments","endSection","FormatterClass","printUsage","_printMessage","printHelp","stream","stdout","write","exit","status","stderr","err","EOL","module","exports"],"mappings":"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","file":"argument_parser.js","sourcesContent":["/**\n * class ArgumentParser\n *\n * Object for parsing command line strings into js objects.\n *\n * Inherited from [[ActionContainer]]\n **/\n'use strict';\n\nvar util    = require('util');\nvar format  = require('util').format;\nvar Path    = require('path');\nvar sprintf = require('sprintf-js').sprintf;\n\n// Constants\nvar c = require('./const');\n\nvar $$ = require('./utils');\n\nvar ActionContainer = require('./action_container');\n\n// Errors\nvar argumentErrorHelper = require('./argument/error');\n\nvar HelpFormatter = require('./help/formatter');\n\nvar Namespace = require('./namespace');\n\n\n/**\n * new ArgumentParser(options)\n *\n * Create a new ArgumentParser object.\n *\n * ##### Options:\n * - `prog`  The name of the program (default: Path.basename(process.argv[1]))\n * - `usage`  A usage message (default: auto-generated from arguments)\n * - `description`  A description of what the program does\n * - `epilog`  Text following the argument descriptions\n * - `parents`  Parsers whose arguments should be copied into this one\n * - `formatterClass`  HelpFormatter class for printing help messages\n * - `prefixChars`  Characters that prefix optional arguments\n * - `fromfilePrefixChars` Characters that prefix files containing additional arguments\n * - `argumentDefault`  The default value for all arguments\n * - `addHelp`  Add a -h/-help option\n * - `conflictHandler`  Specifies how to handle conflicting argument names\n * - `debug`  Enable debug mode. Argument errors throw exception in\n *   debug mode and process.exit in normal. Used for development and\n *   testing (default: false)\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#argumentparser-objects\n **/\nfunction ArgumentParser(options) {\n  if (!(this instanceof ArgumentParser)) {\n    return new ArgumentParser(options);\n  }\n  var self = this;\n  options = options || {};\n\n  options.description = (options.description || null);\n  options.argumentDefault = (options.argumentDefault || null);\n  options.prefixChars = (options.prefixChars || '-');\n  options.conflictHandler = (options.conflictHandler || 'error');\n  ActionContainer.call(this, options);\n\n  options.addHelp = typeof options.addHelp === 'undefined' || !!options.addHelp;\n  options.parents = options.parents || [];\n  // default program name\n  options.prog = (options.prog || Path.basename(process.argv[1]));\n  this.prog = options.prog;\n  this.usage = options.usage;\n  this.epilog = options.epilog;\n  this.version = options.version;\n\n  this.debug = (options.debug === true);\n\n  this.formatterClass = (options.formatterClass || HelpFormatter);\n  this.fromfilePrefixChars = options.fromfilePrefixChars || null;\n  this._positionals = this.addArgumentGroup({ title: 'Positional arguments' });\n  this._optionals = this.addArgumentGroup({ title: 'Optional arguments' });\n  this._subparsers = null;\n\n  // register types\n  function FUNCTION_IDENTITY(o) {\n    return o;\n  }\n  this.register('type', 'auto', FUNCTION_IDENTITY);\n  this.register('type', null, FUNCTION_IDENTITY);\n  this.register('type', 'int', function (x) {\n    var result = parseInt(x, 10);\n    if (isNaN(result)) {\n      throw new Error(x + ' is not a valid integer.');\n    }\n    return result;\n  });\n  this.register('type', 'float', function (x) {\n    var result = parseFloat(x);\n    if (isNaN(result)) {\n      throw new Error(x + ' is not a valid float.');\n    }\n    return result;\n  });\n  this.register('type', 'string', function (x) {\n    return '' + x;\n  });\n\n  // add help and version arguments if necessary\n  var defaultPrefix = (this.prefixChars.indexOf('-') > -1) ? '-' : this.prefixChars[0];\n  if (options.addHelp) {\n    this.addArgument(\n      [ defaultPrefix + 'h', defaultPrefix + defaultPrefix + 'help' ],\n      {\n        action: 'help',\n        defaultValue: c.SUPPRESS,\n        help: 'Show this help message and exit.'\n      }\n    );\n  }\n  if (typeof this.version !== 'undefined') {\n    this.addArgument(\n      [ defaultPrefix + 'v', defaultPrefix + defaultPrefix + 'version' ],\n      {\n        action: 'version',\n        version: this.version,\n        defaultValue: c.SUPPRESS,\n        help: \"Show program's version number and exit.\"\n      }\n    );\n  }\n\n  // add parent arguments and defaults\n  options.parents.forEach(function (parent) {\n    self._addContainerActions(parent);\n    if (typeof parent._defaults !== 'undefined') {\n      for (var defaultKey in parent._defaults) {\n        if (parent._defaults.hasOwnProperty(defaultKey)) {\n          self._defaults[defaultKey] = parent._defaults[defaultKey];\n        }\n      }\n    }\n  });\n}\n\nutil.inherits(ArgumentParser, ActionContainer);\n\n/**\n * ArgumentParser#addSubparsers(options) -> [[ActionSubparsers]]\n * - options (object): hash of options see [[ActionSubparsers.new]]\n *\n * See also [subcommands][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#sub-commands\n **/\nArgumentParser.prototype.addSubparsers = function (options) {\n  if (this._subparsers) {\n    this.error('Cannot have multiple subparser arguments.');\n  }\n\n  options = options || {};\n  options.debug = (this.debug === true);\n  options.optionStrings = [];\n  options.parserClass = (options.parserClass || ArgumentParser);\n\n\n  if (!!options.title || !!options.description) {\n\n    this._subparsers = this.addArgumentGroup({\n      title: (options.title || 'subcommands'),\n      description: options.description\n    });\n    delete options.title;\n    delete options.description;\n\n  } else {\n    this._subparsers = this._positionals;\n  }\n\n  // prog defaults to the usage message of this parser, skipping\n  // optional arguments and with no \"usage:\" prefix\n  if (!options.prog) {\n    var formatter = this._getFormatter();\n    var positionals = this._getPositionalActions();\n    var groups = this._mutuallyExclusiveGroups;\n    formatter.addUsage(this.usage, positionals, groups, '');\n    options.prog = formatter.formatHelp().trim();\n  }\n\n  // create the parsers action and add it to the positionals list\n  var ParsersClass = this._popActionClass(options, 'parsers');\n  var action = new ParsersClass(options);\n  this._subparsers._addAction(action);\n\n  // return the created parsers action\n  return action;\n};\n\nArgumentParser.prototype._addAction = function (action) {\n  if (action.isOptional()) {\n    this._optionals._addAction(action);\n  } else {\n    this._positionals._addAction(action);\n  }\n  return action;\n};\n\nArgumentParser.prototype._getOptionalActions = function () {\n  return this._actions.filter(function (action) {\n    return action.isOptional();\n  });\n};\n\nArgumentParser.prototype._getPositionalActions = function () {\n  return this._actions.filter(function (action) {\n    return action.isPositional();\n  });\n};\n\n\n/**\n * ArgumentParser#parseArgs(args, namespace) -> Namespace|Object\n * - args (array): input elements\n * - namespace (Namespace|Object): result object\n *\n * Parsed args and throws error if some arguments are not recognized\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#the-parse-args-method\n **/\nArgumentParser.prototype.parseArgs = function (args, namespace) {\n  var argv;\n  var result = this.parseKnownArgs(args, namespace);\n\n  args = result[0];\n  argv = result[1];\n  if (argv && argv.length > 0) {\n    this.error(\n      format('Unrecognized arguments: %s.', argv.join(' '))\n    );\n  }\n  return args;\n};\n\n/**\n * ArgumentParser#parseKnownArgs(args, namespace) -> array\n * - args (array): input options\n * - namespace (Namespace|Object): result object\n *\n * Parse known arguments and return tuple of result object\n * and unknown args\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#partial-parsing\n **/\nArgumentParser.prototype.parseKnownArgs = function (args, namespace) {\n  var self = this;\n\n  // args default to the system args\n  args = args || process.argv.slice(2);\n\n  // default Namespace built from parser defaults\n  namespace = namespace || new Namespace();\n\n  self._actions.forEach(function (action) {\n    if (action.dest !== c.SUPPRESS) {\n      if (!$$.has(namespace, action.dest)) {\n        if (action.defaultValue !== c.SUPPRESS) {\n          var defaultValue = action.defaultValue;\n          if (typeof action.defaultValue === 'string') {\n            defaultValue = self._getValue(action, defaultValue);\n          }\n          namespace[action.dest] = defaultValue;\n        }\n      }\n    }\n  });\n\n  Object.keys(self._defaults).forEach(function (dest) {\n    namespace[dest] = self._defaults[dest];\n  });\n\n  // parse the arguments and exit if there are any errors\n  try {\n    var res = this._parseKnownArgs(args, namespace);\n\n    namespace = res[0];\n    args = res[1];\n    if ($$.has(namespace, c._UNRECOGNIZED_ARGS_ATTR)) {\n      args = $$.arrayUnion(args, namespace[c._UNRECOGNIZED_ARGS_ATTR]);\n      delete namespace[c._UNRECOGNIZED_ARGS_ATTR];\n    }\n    return [ namespace, args ];\n  } catch (e) {\n    this.error(e);\n  }\n};\n\nArgumentParser.prototype._parseKnownArgs = function (argStrings, namespace) {\n  var self = this;\n\n  var extras = [];\n\n  // replace arg strings that are file references\n  if (this.fromfilePrefixChars !== null) {\n    argStrings = this._readArgsFromFiles(argStrings);\n  }\n  // map all mutually exclusive arguments to the other arguments\n  // they can't occur with\n  // Python has 'conflicts = action_conflicts.setdefault(mutex_action, [])'\n  // though I can't conceive of a way in which an action could be a member\n  // of two different mutually exclusive groups.\n\n  function actionHash(action) {\n    // some sort of hashable key for this action\n    // action itself cannot be a key in actionConflicts\n    // I think getName() (join of optionStrings) is unique enough\n    return action.getName();\n  }\n\n  var conflicts, key;\n  var actionConflicts = {};\n\n  this._mutuallyExclusiveGroups.forEach(function (mutexGroup) {\n    mutexGroup._groupActions.forEach(function (mutexAction, i, groupActions) {\n      key = actionHash(mutexAction);\n      if (!$$.has(actionConflicts, key)) {\n        actionConflicts[key] = [];\n      }\n      conflicts = actionConflicts[key];\n      conflicts.push.apply(conflicts, groupActions.slice(0, i));\n      conflicts.push.apply(conflicts, groupActions.slice(i + 1));\n    });\n  });\n\n  // find all option indices, and determine the arg_string_pattern\n  // which has an 'O' if there is an option at an index,\n  // an 'A' if there is an argument, or a '-' if there is a '--'\n  var optionStringIndices = {};\n\n  var argStringPatternParts = [];\n\n  argStrings.forEach(function (argString, argStringIndex) {\n    if (argString === '--') {\n      argStringPatternParts.push('-');\n      while (argStringIndex < argStrings.length) {\n        argStringPatternParts.push('A');\n        argStringIndex++;\n      }\n    } else {\n      // otherwise, add the arg to the arg strings\n      // and note the index if it was an option\n      var pattern;\n      var optionTuple = self._parseOptional(argString);\n      if (!optionTuple) {\n        pattern = 'A';\n      } else {\n        optionStringIndices[argStringIndex] = optionTuple;\n        pattern = 'O';\n      }\n      argStringPatternParts.push(pattern);\n    }\n  });\n  var argStringsPattern = argStringPatternParts.join('');\n\n  var seenActions = [];\n  var seenNonDefaultActions = [];\n\n\n  function takeAction(action, argumentStrings, optionString) {\n    seenActions.push(action);\n    var argumentValues = self._getValues(action, argumentStrings);\n\n    // error if this argument is not allowed with other previously\n    // seen arguments, assuming that actions that use the default\n    // value don't really count as \"present\"\n    if (argumentValues !== action.defaultValue) {\n      seenNonDefaultActions.push(action);\n      if (actionConflicts[actionHash(action)]) {\n        actionConflicts[actionHash(action)].forEach(function (actionConflict) {\n          if (seenNonDefaultActions.indexOf(actionConflict) >= 0) {\n            throw argumentErrorHelper(\n              action,\n              format('Not allowed with argument \"%s\".', actionConflict.getName())\n            );\n          }\n        });\n      }\n    }\n\n    if (argumentValues !== c.SUPPRESS) {\n      action.call(self, namespace, argumentValues, optionString);\n    }\n  }\n\n  function consumeOptional(startIndex) {\n    // get the optional identified at this index\n    var optionTuple = optionStringIndices[startIndex];\n    var action = optionTuple[0];\n    var optionString = optionTuple[1];\n    var explicitArg = optionTuple[2];\n\n    // identify additional optionals in the same arg string\n    // (e.g. -xyz is the same as -x -y -z if no args are required)\n    var actionTuples = [];\n\n    var args, argCount, start, stop;\n\n    for (;;) {\n      if (!action) {\n        extras.push(argStrings[startIndex]);\n        return startIndex + 1;\n      }\n      if (explicitArg) {\n        argCount = self._matchArgument(action, 'A');\n\n        // if the action is a single-dash option and takes no\n        // arguments, try to parse more single-dash options out\n        // of the tail of the option string\n        var chars = self.prefixChars;\n        if (argCount === 0 && chars.indexOf(optionString[1]) < 0) {\n          actionTuples.push([ action, [], optionString ]);\n          optionString = optionString[0] + explicitArg[0];\n          var newExplicitArg = explicitArg.slice(1) || null;\n          var optionalsMap = self._optionStringActions;\n\n          if (Object.keys(optionalsMap).indexOf(optionString) >= 0) {\n            action = optionalsMap[optionString];\n            explicitArg = newExplicitArg;\n          } else {\n            throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));\n          }\n        } else if (argCount === 1) {\n          // if the action expect exactly one argument, we've\n          // successfully matched the option; exit the loop\n          stop = startIndex + 1;\n          args = [ explicitArg ];\n          actionTuples.push([ action, args, optionString ]);\n          break;\n        } else {\n          // error if a double-dash option did not use the\n          // explicit argument\n          throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));\n        }\n      } else {\n        // if there is no explicit argument, try to match the\n        // optional's string arguments with the following strings\n        // if successful, exit the loop\n\n        start = startIndex + 1;\n        var selectedPatterns = argStringsPattern.substr(start);\n\n        argCount = self._matchArgument(action, selectedPatterns);\n        stop = start + argCount;\n\n\n        args = argStrings.slice(start, stop);\n\n        actionTuples.push([ action, args, optionString ]);\n        break;\n      }\n\n    }\n\n    // add the Optional to the list and return the index at which\n    // the Optional's string args stopped\n    if (actionTuples.length < 1) {\n      throw new Error('length should be > 0');\n    }\n    for (var i = 0; i < actionTuples.length; i++) {\n      takeAction.apply(self, actionTuples[i]);\n    }\n    return stop;\n  }\n\n  // the list of Positionals left to be parsed; this is modified\n  // by consume_positionals()\n  var positionals = self._getPositionalActions();\n\n  function consumePositionals(startIndex) {\n    // match as many Positionals as possible\n    var selectedPattern = argStringsPattern.substr(startIndex);\n    var argCounts = self._matchArgumentsPartial(positionals, selectedPattern);\n\n    // slice off the appropriate arg strings for each Positional\n    // and add the Positional and its args to the list\n    for (var i = 0; i < positionals.length; i++) {\n      var action = positionals[i];\n      var argCount = argCounts[i];\n      if (typeof argCount === 'undefined') {\n        continue;\n      }\n      var args = argStrings.slice(startIndex, startIndex + argCount);\n\n      startIndex += argCount;\n      takeAction(action, args);\n    }\n\n    // slice off the Positionals that we just parsed and return the\n    // index at which the Positionals' string args stopped\n    positionals = positionals.slice(argCounts.length);\n    return startIndex;\n  }\n\n  // consume Positionals and Optionals alternately, until we have\n  // passed the last option string\n  var startIndex = 0;\n  var position;\n\n  var maxOptionStringIndex = -1;\n\n  Object.keys(optionStringIndices).forEach(function (position) {\n    maxOptionStringIndex = Math.max(maxOptionStringIndex, parseInt(position, 10));\n  });\n\n  var positionalsEndIndex, nextOptionStringIndex;\n\n  while (startIndex <= maxOptionStringIndex) {\n    // consume any Positionals preceding the next option\n    nextOptionStringIndex = null;\n    for (position in optionStringIndices) {\n      if (!optionStringIndices.hasOwnProperty(position)) { continue; }\n\n      position = parseInt(position, 10);\n      if (position >= startIndex) {\n        if (nextOptionStringIndex !== null) {\n          nextOptionStringIndex = Math.min(nextOptionStringIndex, position);\n        } else {\n          nextOptionStringIndex = position;\n        }\n      }\n    }\n\n    if (startIndex !== nextOptionStringIndex) {\n      positionalsEndIndex = consumePositionals(startIndex);\n      // only try to parse the next optional if we didn't consume\n      // the option string during the positionals parsing\n      if (positionalsEndIndex > startIndex) {\n        startIndex = positionalsEndIndex;\n        continue;\n      } else {\n        startIndex = positionalsEndIndex;\n      }\n    }\n\n    // if we consumed all the positionals we could and we're not\n    // at the index of an option string, there were extra arguments\n    if (!optionStringIndices[startIndex]) {\n      var strings = argStrings.slice(startIndex, nextOptionStringIndex);\n      extras = extras.concat(strings);\n      startIndex = nextOptionStringIndex;\n    }\n    // consume the next optional and any arguments for it\n    startIndex = consumeOptional(startIndex);\n  }\n\n  // consume any positionals following the last Optional\n  var stopIndex = consumePositionals(startIndex);\n\n  // if we didn't consume all the argument strings, there were extras\n  extras = extras.concat(argStrings.slice(stopIndex));\n\n  // if we didn't use all the Positional objects, there were too few\n  // arg strings supplied.\n  if (positionals.length > 0) {\n    self.error('too few arguments');\n  }\n\n  // make sure all required actions were present\n  self._actions.forEach(function (action) {\n    if (action.required) {\n      if (seenActions.indexOf(action) < 0) {\n        self.error(format('Argument \"%s\" is required', action.getName()));\n      }\n    }\n  });\n\n  // make sure all required groups have one option present\n  var actionUsed = false;\n  self._mutuallyExclusiveGroups.forEach(function (group) {\n    if (group.required) {\n      actionUsed = group._groupActions.some(function (action) {\n        return seenNonDefaultActions.indexOf(action) !== -1;\n      });\n\n      // if no actions were used, report the error\n      if (!actionUsed) {\n        var names = [];\n        group._groupActions.forEach(function (action) {\n          if (action.help !== c.SUPPRESS) {\n            names.push(action.getName());\n          }\n        });\n        names = names.join(' ');\n        var msg = 'one of the arguments ' + names + ' is required';\n        self.error(msg);\n      }\n    }\n  });\n\n  // return the updated namespace and the extra arguments\n  return [ namespace, extras ];\n};\n\nArgumentParser.prototype._readArgsFromFiles = function (argStrings) {\n  // expand arguments referencing files\n  var self = this;\n  var fs = require('fs');\n  var newArgStrings = [];\n  argStrings.forEach(function (argString) {\n    if (self.fromfilePrefixChars.indexOf(argString[0]) < 0) {\n      // for regular arguments, just add them back into the list\n      newArgStrings.push(argString);\n    } else {\n      // replace arguments referencing files with the file content\n      try {\n        var argstrs = [];\n        var filename = argString.slice(1);\n        var content = fs.readFileSync(filename, 'utf8');\n        content = content.trim().split('\\n');\n        content.forEach(function (argLine) {\n          self.convertArgLineToArgs(argLine).forEach(function (arg) {\n            argstrs.push(arg);\n          });\n          argstrs = self._readArgsFromFiles(argstrs);\n        });\n        newArgStrings.push.apply(newArgStrings, argstrs);\n      } catch (error) {\n        return self.error(error.message);\n      }\n    }\n  });\n  return newArgStrings;\n};\n\nArgumentParser.prototype.convertArgLineToArgs = function (argLine) {\n  return [ argLine ];\n};\n\nArgumentParser.prototype._matchArgument = function (action, regexpArgStrings) {\n\n  // match the pattern for this action to the arg strings\n  var regexpNargs = new RegExp('^' + this._getNargsPattern(action));\n  var matches = regexpArgStrings.match(regexpNargs);\n  var message;\n\n  // throw an exception if we weren't able to find a match\n  if (!matches) {\n    switch (action.nargs) {\n      /*eslint-disable no-undefined*/\n      case undefined:\n      case null:\n        message = 'Expected one argument.';\n        break;\n      case c.OPTIONAL:\n        message = 'Expected at most one argument.';\n        break;\n      case c.ONE_OR_MORE:\n        message = 'Expected at least one argument.';\n        break;\n      default:\n        message = 'Expected %s argument(s)';\n    }\n\n    throw argumentErrorHelper(\n      action,\n      format(message, action.nargs)\n    );\n  }\n  // return the number of arguments matched\n  return matches[1].length;\n};\n\nArgumentParser.prototype._matchArgumentsPartial = function (actions, regexpArgStrings) {\n  // progressively shorten the actions list by slicing off the\n  // final actions until we find a match\n  var self = this;\n  var result = [];\n  var actionSlice, pattern, matches;\n  var i, j;\n\n  function getLength(string) {\n    return string.length;\n  }\n\n  for (i = actions.length; i > 0; i--) {\n    pattern = '';\n    actionSlice = actions.slice(0, i);\n    for (j = 0; j < actionSlice.length; j++) {\n      pattern += self._getNargsPattern(actionSlice[j]);\n    }\n\n    pattern = new RegExp('^' + pattern);\n    matches = regexpArgStrings.match(pattern);\n\n    if (matches && matches.length > 0) {\n      // need only groups\n      matches = matches.splice(1);\n      result = result.concat(matches.map(getLength));\n      break;\n    }\n  }\n\n  // return the list of arg string counts\n  return result;\n};\n\nArgumentParser.prototype._parseOptional = function (argString) {\n  var action, optionString, argExplicit, optionTuples;\n\n  // if it's an empty string, it was meant to be a positional\n  if (!argString) {\n    return null;\n  }\n\n  // if it doesn't start with a prefix, it was meant to be positional\n  if (this.prefixChars.indexOf(argString[0]) < 0) {\n    return null;\n  }\n\n  // if the option string is present in the parser, return the action\n  if (this._optionStringActions[argString]) {\n    return [ this._optionStringActions[argString], argString, null ];\n  }\n\n  // if it's just a single character, it was meant to be positional\n  if (argString.length === 1) {\n    return null;\n  }\n\n  // if the option string before the \"=\" is present, return the action\n  if (argString.indexOf('=') >= 0) {\n    optionString = argString.split('=', 1)[0];\n    argExplicit = argString.slice(optionString.length + 1);\n\n    if (this._optionStringActions[optionString]) {\n      action = this._optionStringActions[optionString];\n      return [ action, optionString, argExplicit ];\n    }\n  }\n\n  // search through all possible prefixes of the option string\n  // and all actions in the parser for possible interpretations\n  optionTuples = this._getOptionTuples(argString);\n\n  // if multiple actions match, the option string was ambiguous\n  if (optionTuples.length > 1) {\n    var optionStrings = optionTuples.map(function (optionTuple) {\n      return optionTuple[1];\n    });\n    this.error(format(\n          'Ambiguous option: \"%s\" could match %s.',\n          argString, optionStrings.join(', ')\n    ));\n  // if exactly one action matched, this segmentation is good,\n  // so return the parsed action\n  } else if (optionTuples.length === 1) {\n    return optionTuples[0];\n  }\n\n  // if it was not found as an option, but it looks like a negative\n  // number, it was meant to be positional\n  // unless there are negative-number-like options\n  if (argString.match(this._regexpNegativeNumber)) {\n    if (!this._hasNegativeNumberOptionals.some(Boolean)) {\n      return null;\n    }\n  }\n  // if it contains a space, it was meant to be a positional\n  if (argString.search(' ') >= 0) {\n    return null;\n  }\n\n  // it was meant to be an optional but there is no such option\n  // in this parser (though it might be a valid option in a subparser)\n  return [ null, argString, null ];\n};\n\nArgumentParser.prototype._getOptionTuples = function (optionString) {\n  var result = [];\n  var chars = this.prefixChars;\n  var optionPrefix;\n  var argExplicit;\n  var action;\n  var actionOptionString;\n\n  // option strings starting with two prefix characters are only split at\n  // the '='\n  if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) >= 0) {\n    if (optionString.indexOf('=') >= 0) {\n      var optionStringSplit = optionString.split('=', 1);\n\n      optionPrefix = optionStringSplit[0];\n      argExplicit = optionStringSplit[1];\n    } else {\n      optionPrefix = optionString;\n      argExplicit = null;\n    }\n\n    for (actionOptionString in this._optionStringActions) {\n      if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {\n        action = this._optionStringActions[actionOptionString];\n        result.push([ action, actionOptionString, argExplicit ]);\n      }\n    }\n\n  // single character options can be concatenated with their arguments\n  // but multiple character options always have to have their argument\n  // separate\n  } else if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) < 0) {\n    optionPrefix = optionString;\n    argExplicit = null;\n    var optionPrefixShort = optionString.substr(0, 2);\n    var argExplicitShort = optionString.substr(2);\n\n    for (actionOptionString in this._optionStringActions) {\n      if (!$$.has(this._optionStringActions, actionOptionString)) continue;\n\n      action = this._optionStringActions[actionOptionString];\n      if (actionOptionString === optionPrefixShort) {\n        result.push([ action, actionOptionString, argExplicitShort ]);\n      } else if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {\n        result.push([ action, actionOptionString, argExplicit ]);\n      }\n    }\n\n  // shouldn't ever get here\n  } else {\n    throw new Error(format('Unexpected option string: %s.', optionString));\n  }\n  // return the collected option tuples\n  return result;\n};\n\nArgumentParser.prototype._getNargsPattern = function (action) {\n  // in all examples below, we have to allow for '--' args\n  // which are represented as '-' in the pattern\n  var regexpNargs;\n\n  switch (action.nargs) {\n    // the default (null) is assumed to be a single argument\n    case undefined:\n    case null:\n      regexpNargs = '(-*A-*)';\n      break;\n    // allow zero or more arguments\n    case c.OPTIONAL:\n      regexpNargs = '(-*A?-*)';\n      break;\n    // allow zero or more arguments\n    case c.ZERO_OR_MORE:\n      regexpNargs = '(-*[A-]*)';\n      break;\n    // allow one or more arguments\n    case c.ONE_OR_MORE:\n      regexpNargs = '(-*A[A-]*)';\n      break;\n    // allow any number of options or arguments\n    case c.REMAINDER:\n      regexpNargs = '([-AO]*)';\n      break;\n    // allow one argument followed by any number of options or arguments\n    case c.PARSER:\n      regexpNargs = '(-*A[-AO]*)';\n      break;\n    // all others should be integers\n    default:\n      regexpNargs = '(-*' + $$.repeat('-*A', action.nargs) + '-*)';\n  }\n\n  // if this is an optional action, -- is not allowed\n  if (action.isOptional()) {\n    regexpNargs = regexpNargs.replace(/-\\*/g, '');\n    regexpNargs = regexpNargs.replace(/-/g, '');\n  }\n\n  // return the pattern\n  return regexpNargs;\n};\n\n//\n// Value conversion methods\n//\n\nArgumentParser.prototype._getValues = function (action, argStrings) {\n  var self = this;\n\n  // for everything but PARSER args, strip out '--'\n  if (action.nargs !== c.PARSER && action.nargs !== c.REMAINDER) {\n    argStrings = argStrings.filter(function (arrayElement) {\n      return arrayElement !== '--';\n    });\n  }\n\n  var value, argString;\n\n  // optional argument produces a default when not present\n  if (argStrings.length === 0 && action.nargs === c.OPTIONAL) {\n\n    value = (action.isOptional()) ? action.constant : action.defaultValue;\n\n    if (typeof (value) === 'string') {\n      value = this._getValue(action, value);\n      this._checkValue(action, value);\n    }\n\n  // when nargs='*' on a positional, if there were no command-line\n  // args, use the default if it is anything other than None\n  } else if (argStrings.length === 0 && action.nargs === c.ZERO_OR_MORE &&\n    action.optionStrings.length === 0) {\n\n    value = (action.defaultValue || argStrings);\n    this._checkValue(action, value);\n\n  // single argument or optional argument produces a single value\n  } else if (argStrings.length === 1 &&\n        (!action.nargs || action.nargs === c.OPTIONAL)) {\n\n    argString = argStrings[0];\n    value = this._getValue(action, argString);\n    this._checkValue(action, value);\n\n  // REMAINDER arguments convert all values, checking none\n  } else if (action.nargs === c.REMAINDER) {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n\n  // PARSER arguments convert all values, but check only the first\n  } else if (action.nargs === c.PARSER) {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n    this._checkValue(action, value[0]);\n\n  // all other types of nargs produce a list\n  } else {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n    value.forEach(function (v) {\n      self._checkValue(action, v);\n    });\n  }\n\n  // return the converted value\n  return value;\n};\n\nArgumentParser.prototype._getValue = function (action, argString) {\n  var result;\n\n  var typeFunction = this._registryGet('type', action.type, action.type);\n  if (typeof typeFunction !== 'function') {\n    var message = format('%s is not callable', typeFunction);\n    throw argumentErrorHelper(action, message);\n  }\n\n  // convert the value to the appropriate type\n  try {\n    result = typeFunction(argString);\n\n    // ArgumentTypeErrors indicate errors\n    // If action.type is not a registered string, it is a function\n    // Try to deduce its name for inclusion in the error message\n    // Failing that, include the error message it raised.\n  } catch (e) {\n    var name = null;\n    if (typeof action.type === 'string') {\n      name = action.type;\n    } else {\n      name = action.type.name || action.type.displayName || '<function>';\n    }\n    var msg = format('Invalid %s value: %s', name, argString);\n    if (name === '<function>') { msg += '\\n' + e.message; }\n    throw argumentErrorHelper(action, msg);\n  }\n  // return the converted value\n  return result;\n};\n\nArgumentParser.prototype._checkValue = function (action, value) {\n  // converted value must be one of the choices (if specified)\n  var choices = action.choices;\n  if (choices) {\n    // choise for argument can by array or string\n    if ((typeof choices === 'string' || Array.isArray(choices)) &&\n        choices.indexOf(value) !== -1) {\n      return;\n    }\n    // choise for subparsers can by only hash\n    if (typeof choices === 'object' && !Array.isArray(choices) && choices[value]) {\n      return;\n    }\n\n    if (typeof choices === 'string') {\n      choices = choices.split('').join(', ');\n    } else if (Array.isArray(choices)) {\n      choices =  choices.join(', ');\n    } else {\n      choices =  Object.keys(choices).join(', ');\n    }\n    var message = format('Invalid choice: %s (choose from [%s])', value, choices);\n    throw argumentErrorHelper(action, message);\n  }\n};\n\n//\n// Help formatting methods\n//\n\n/**\n * ArgumentParser#formatUsage -> string\n *\n * Return usage string\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.formatUsage = function () {\n  var formatter = this._getFormatter();\n  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);\n  return formatter.formatHelp();\n};\n\n/**\n * ArgumentParser#formatHelp -> string\n *\n * Return help\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.formatHelp = function () {\n  var formatter = this._getFormatter();\n\n  // usage\n  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);\n\n  // description\n  formatter.addText(this.description);\n\n  // positionals, optionals and user-defined groups\n  this._actionGroups.forEach(function (actionGroup) {\n    formatter.startSection(actionGroup.title);\n    formatter.addText(actionGroup.description);\n    formatter.addArguments(actionGroup._groupActions);\n    formatter.endSection();\n  });\n\n  // epilog\n  formatter.addText(this.epilog);\n\n  // determine help from format above\n  return formatter.formatHelp();\n};\n\nArgumentParser.prototype._getFormatter = function () {\n  var FormatterClass = this.formatterClass;\n  var formatter = new FormatterClass({ prog: this.prog });\n  return formatter;\n};\n\n//\n//  Print functions\n//\n\n/**\n * ArgumentParser#printUsage() -> Void\n *\n * Print usage\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.printUsage = function () {\n  this._printMessage(this.formatUsage());\n};\n\n/**\n * ArgumentParser#printHelp() -> Void\n *\n * Print help\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.printHelp = function () {\n  this._printMessage(this.formatHelp());\n};\n\nArgumentParser.prototype._printMessage = function (message, stream) {\n  if (!stream) {\n    stream = process.stdout;\n  }\n  if (message) {\n    stream.write('' + message);\n  }\n};\n\n//\n//  Exit functions\n//\n\n/**\n * ArgumentParser#exit(status=0, message) -> Void\n * - status (int): exit status\n * - message (string): message\n *\n * Print message in stderr/stdout and exit program\n **/\nArgumentParser.prototype.exit = function (status, message) {\n  if (message) {\n    if (status === 0) {\n      this._printMessage(message);\n    } else {\n      this._printMessage(message, process.stderr);\n    }\n  }\n\n  process.exit(status);\n};\n\n/**\n * ArgumentParser#error(message) -> Void\n * - err (Error|string): message\n *\n * Error method Prints a usage message incorporating the message to stderr and\n * exits. If you override this in a subclass,\n * it should not return -- it should\n * either exit or throw an exception.\n *\n **/\nArgumentParser.prototype.error = function (err) {\n  var message;\n  if (err instanceof Error) {\n    if (this.debug === true) {\n      throw err;\n    }\n    message = err.message;\n  } else {\n    message = err;\n  }\n  var msg = format('%s: error: %s', this.prog, message) + c.EOL;\n\n  if (this.debug === true) {\n    throw new Error(msg);\n  }\n\n  this.printUsage(process.stderr);\n\n  return this.exit(2, msg);\n};\n\nmodule.exports = ArgumentParser;\n"]}