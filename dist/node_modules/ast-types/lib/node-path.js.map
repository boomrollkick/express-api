{"version":3,"sources":["../../../../src/node_modules/ast-types/lib/node-path.js"],"names":["module","exports","fork","types","use","require","n","namedTypes","b","builders","isNumber","builtInTypes","number","isArray","array","Path","Scope","NodePath","value","parentPath","name","Error","call","NPp","prototype","Object","create","constructor","enumerable","writable","configurable","defineProperties","node","get","defineProperty","_computeNode","parent","_computeParent","scope","_computeScope","replace","apply","arguments","prune","remainingNodePath","cleanUpNodesAfterPrune","Node","check","pp","isEstablishedBy","getValueProperty","getFieldValue","needsParens","assumeExpressionContext","Expression","type","object","callee","po","operator","PRECEDENCE","no","np","right","test","containsCallExpression","canBeFirstInStatement","firstInStatement","isBinary","BinaryExpression","LogicalExpression","isUnaryLike","UnaryExpression","SpreadElement","SpreadProperty","forEach","tier","i","op","CallExpression","some","someField","child","FunctionExpression","ObjectExpression","path","BlockStatement","body","ExpressionStatement","expression","SequenceExpression","expressions","MemberExpression","ConditionalExpression","left","prefix","argument","VariableDeclaration","declarations","length","IfStatement","cleanUpIfStatementAfterPrune","ifStatement","testExpression","alternate","consequent","testExpressionStatement","expressionStatement","negatedTestExpression","unaryExpression"],"mappings":";;AAAAA,OAAOC,OAAP,GAAiB,UAAUC,IAAV,EAAgB;AAC7B,QAAIC,QAAQD,KAAKE,GAAL,CAASC,QAAQ,SAAR,CAAT,CAAZ;AACA,QAAIC,IAAIH,MAAMI,UAAd;AACA,QAAIC,IAAIL,MAAMM,QAAd;AACA,QAAIC,WAAWP,MAAMQ,YAAN,CAAmBC,MAAlC;AACA,QAAIC,UAAUV,MAAMQ,YAAN,CAAmBG,KAAjC;AACA,QAAIC,OAAOb,KAAKE,GAAL,CAASC,QAAQ,QAAR,CAAT,CAAX;AACA,QAAIW,QAAQd,KAAKE,GAAL,CAASC,QAAQ,SAAR,CAAT,CAAZ;;AAEA,aAASY,QAAT,CAAkBC,KAAlB,EAAyBC,UAAzB,EAAqCC,IAArC,EAA2C;AACvC,YAAI,EAAE,gBAAgBH,QAAlB,CAAJ,EAAiC;AAC7B,kBAAM,IAAII,KAAJ,CAAU,sDAAV,CAAN;AACH;AACDN,aAAKO,IAAL,CAAU,IAAV,EAAgBJ,KAAhB,EAAuBC,UAAvB,EAAmCC,IAAnC;AACH;;AAED,QAAIG,MAAMN,SAASO,SAAT,GAAqBC,OAAOC,MAAP,CAAcX,KAAKS,SAAnB,EAA8B;AACzDG,qBAAa;AACTT,mBAAOD,QADE;AAETW,wBAAY,KAFH;AAGTC,sBAAU,IAHD;AAITC,0BAAc;AAJL;AAD4C,KAA9B,CAA/B;;AASAL,WAAOM,gBAAP,CAAwBR,GAAxB,EAA6B;AACzBS,cAAM;AACFC,iBAAK,eAAY;AACbR,uBAAOS,cAAP,CAAsB,IAAtB,EAA4B,MAA5B,EAAoC;AAChCJ,kCAAc,IADkB,EACZ;AACpBZ,2BAAO,KAAKiB,YAAL;AAFyB,iBAApC;;AAKA,uBAAO,KAAKH,IAAZ;AACH;AARC,SADmB;;AAYzBI,gBAAQ;AACJH,iBAAK,eAAY;AACbR,uBAAOS,cAAP,CAAsB,IAAtB,EAA4B,QAA5B,EAAsC;AAClCJ,kCAAc,IADoB,EACd;AACpBZ,2BAAO,KAAKmB,cAAL;AAF2B,iBAAtC;;AAKA,uBAAO,KAAKD,MAAZ;AACH;AARG,SAZiB;;AAuBzBE,eAAO;AACHL,iBAAK,eAAY;AACbR,uBAAOS,cAAP,CAAsB,IAAtB,EAA4B,OAA5B,EAAqC;AACjCJ,kCAAc,IADmB,EACb;AACpBZ,2BAAO,KAAKqB,aAAL;AAF0B,iBAArC;;AAKA,uBAAO,KAAKD,KAAZ;AACH;AARE;AAvBkB,KAA7B;;AAmCAf,QAAIiB,OAAJ,GAAc,YAAY;AACtB,eAAO,KAAKR,IAAZ;AACA,eAAO,KAAKI,MAAZ;AACA,eAAO,KAAKE,KAAZ;AACA,eAAOvB,KAAKS,SAAL,CAAegB,OAAf,CAAuBC,KAAvB,CAA6B,IAA7B,EAAmCC,SAAnC,CAAP;AACH,KALD;;AAOAnB,QAAIoB,KAAJ,GAAY,YAAY;AACpB,YAAIC,oBAAoB,KAAKR,MAA7B;;AAEA,aAAKI,OAAL;;AAEA,eAAOK,uBAAuBD,iBAAvB,CAAP;AACH,KAND;;AAQA;AACArB,QAAIY,YAAJ,GAAmB,YAAY;AAC3B,YAAIjB,QAAQ,KAAKA,KAAjB;AACA,YAAIZ,EAAEwC,IAAF,CAAOC,KAAP,CAAa7B,KAAb,CAAJ,EAAyB;AACrB,mBAAOA,KAAP;AACH;;AAED,YAAI8B,KAAK,KAAK7B,UAAd;AACA,eAAO6B,MAAMA,GAAGhB,IAAT,IAAiB,IAAxB;AACH,KARD;;AAUA;AACAT,QAAIc,cAAJ,GAAqB,YAAY;AAC7B,YAAInB,QAAQ,KAAKA,KAAjB;AACA,YAAI8B,KAAK,KAAK7B,UAAd;;AAEA,YAAI,CAACb,EAAEwC,IAAF,CAAOC,KAAP,CAAa7B,KAAb,CAAL,EAA0B;AACtB,mBAAO8B,MAAM,CAAC1C,EAAEwC,IAAF,CAAOC,KAAP,CAAaC,GAAG9B,KAAhB,CAAd,EAAsC;AAClC8B,qBAAKA,GAAG7B,UAAR;AACH;;AAED,gBAAI6B,EAAJ,EAAQ;AACJA,qBAAKA,GAAG7B,UAAR;AACH;AACJ;;AAED,eAAO6B,MAAM,CAAC1C,EAAEwC,IAAF,CAAOC,KAAP,CAAaC,GAAG9B,KAAhB,CAAd,EAAsC;AAClC8B,iBAAKA,GAAG7B,UAAR;AACH;;AAED,eAAO6B,MAAM,IAAb;AACH,KAnBD;;AAqBA;AACAzB,QAAIgB,aAAJ,GAAoB,YAAY;AAC5B,YAAIrB,QAAQ,KAAKA,KAAjB;AACA,YAAI8B,KAAK,KAAK7B,UAAd;AACA,YAAImB,QAAQU,MAAMA,GAAGV,KAArB;;AAEA,YAAIhC,EAAEwC,IAAF,CAAOC,KAAP,CAAa7B,KAAb,KACFF,MAAMiC,eAAN,CAAsB/B,KAAtB,CADF,EACgC;AAC5BoB,oBAAQ,IAAItB,KAAJ,CAAU,IAAV,EAAgBsB,KAAhB,CAAR;AACH;;AAED,eAAOA,SAAS,IAAhB;AACH,KAXD;;AAaAf,QAAI2B,gBAAJ,GAAuB,UAAU9B,IAAV,EAAgB;AACnC,eAAOjB,MAAMgD,aAAN,CAAoB,KAAKjC,KAAzB,EAAgCE,IAAhC,CAAP;AACH,KAFD;;AAIA;;;;;;;;;;;;;AAaAG,QAAI6B,WAAJ,GAAkB,UAAUC,uBAAV,EAAmC;AACjD,YAAIL,KAAK,KAAK7B,UAAd;AACA,YAAI,CAAC6B,EAAL,EAAS;AACL,mBAAO,KAAP;AACH;;AAED,YAAIhB,OAAO,KAAKd,KAAhB;;AAEA;AACA,YAAI,CAACZ,EAAEgD,UAAF,CAAaP,KAAb,CAAmBf,IAAnB,CAAL,EAA+B;AAC3B,mBAAO,KAAP;AACH;;AAED;AACA,YAAIA,KAAKuB,IAAL,KAAc,YAAlB,EAAgC;AAC5B,mBAAO,KAAP;AACH;;AAED,eAAO,CAACjD,EAAEwC,IAAF,CAAOC,KAAP,CAAaC,GAAG9B,KAAhB,CAAR,EAAgC;AAC5B8B,iBAAKA,GAAG7B,UAAR;AACA,gBAAI,CAAC6B,EAAL,EAAS;AACL,uBAAO,KAAP;AACH;AACJ;;AAED,YAAIZ,SAASY,GAAG9B,KAAhB;;AAEA,gBAAQc,KAAKuB,IAAb;AACI,iBAAK,iBAAL;AACA,iBAAK,eAAL;AACA,iBAAK,gBAAL;AACI,uBAAOnB,OAAOmB,IAAP,KAAgB,kBAAhB,IACF,KAAKnC,IAAL,KAAc,QADZ,IAEFgB,OAAOoB,MAAP,KAAkBxB,IAFvB;;AAIJ,iBAAK,kBAAL;AACA,iBAAK,mBAAL;AACI,wBAAQI,OAAOmB,IAAf;AACI,yBAAK,gBAAL;AACI,+BAAO,KAAKnC,IAAL,KAAc,QAAd,IACFgB,OAAOqB,MAAP,KAAkBzB,IADvB;;AAGJ,yBAAK,iBAAL;AACA,yBAAK,eAAL;AACA,yBAAK,gBAAL;AACI,+BAAO,IAAP;;AAEJ,yBAAK,kBAAL;AACI,+BAAO,KAAKZ,IAAL,KAAc,QAAd,IACFgB,OAAOoB,MAAP,KAAkBxB,IADvB;;AAGJ,yBAAK,kBAAL;AACA,yBAAK,mBAAL;AACI,4BAAI0B,KAAKtB,OAAOuB,QAAhB;AACA,4BAAIX,KAAKY,WAAWF,EAAX,CAAT;AACA,4BAAIG,KAAK7B,KAAK2B,QAAd;AACA,4BAAIG,KAAKF,WAAWC,EAAX,CAAT;;AAEA,4BAAIb,KAAKc,EAAT,EAAa;AACT,mCAAO,IAAP;AACH;;AAED,4BAAId,OAAOc,EAAP,IAAa,KAAK1C,IAAL,KAAc,OAA/B,EAAwC;AACpC,gCAAIgB,OAAO2B,KAAP,KAAiB/B,IAArB,EAA2B;AACvB,sCAAM,IAAIX,KAAJ,CAAU,qBAAV,CAAN;AACH;AACD,mCAAO,IAAP;AACH;;AAEL;AACI,+BAAO,KAAP;AAjCR;;AAoCJ,iBAAK,oBAAL;AACI,wBAAQe,OAAOmB,IAAf;AACI,yBAAK,cAAL;AACI;AACA;AACA;AACA;AACA,+BAAO,KAAP;;AAEJ,yBAAK,qBAAL;AACI,+BAAO,KAAKnC,IAAL,KAAc,YAArB;;AAEJ;AACI;AACA;AACA,+BAAO,IAAP;AAdR;;AAiBJ,iBAAK,iBAAL;AACI,wBAAQgB,OAAOmB,IAAf;AACI,yBAAK,kBAAL;AACA,yBAAK,mBAAL;AACA,yBAAK,iBAAL;AACA,yBAAK,eAAL;AACA,yBAAK,gBAAL;AACA,yBAAK,gBAAL;AACA,yBAAK,kBAAL;AACA,yBAAK,eAAL;AACA,yBAAK,uBAAL;AACA,yBAAK,iBAAL;AACI,+BAAO,IAAP;;AAEJ;AACI,+BAAO,KAAP;AAdR;;AAiBJ,iBAAK,SAAL;AACI,uBAAOnB,OAAOmB,IAAP,KAAgB,kBAAhB,IACF7C,SAASqC,KAAT,CAAef,KAAKd,KAApB,CADE,IAEF,KAAKE,IAAL,KAAc,QAFZ,IAGFgB,OAAOoB,MAAP,KAAkBxB,IAHvB;;AAKJ,iBAAK,sBAAL;AACA,iBAAK,uBAAL;AACI,wBAAQI,OAAOmB,IAAf;AACI,yBAAK,iBAAL;AACA,yBAAK,eAAL;AACA,yBAAK,gBAAL;AACA,yBAAK,kBAAL;AACA,yBAAK,mBAAL;AACI,+BAAO,IAAP;;AAEJ,yBAAK,gBAAL;AACI,+BAAO,KAAKnC,IAAL,KAAc,QAAd,IACFgB,OAAOqB,MAAP,KAAkBzB,IADvB;;AAGJ,yBAAK,uBAAL;AACI,+BAAO,KAAKZ,IAAL,KAAc,MAAd,IACFgB,OAAO4B,IAAP,KAAgBhC,IADrB;;AAGJ,yBAAK,kBAAL;AACI,+BAAO,KAAKZ,IAAL,KAAc,QAAd,IACFgB,OAAOoB,MAAP,KAAkBxB,IADvB;;AAGJ;AACI,+BAAO,KAAP;AArBR;;AAwBJ;AACI,oBAAII,OAAOmB,IAAP,KAAgB,eAAhB,IACF,KAAKnC,IAAL,KAAc,QADZ,IAEFgB,OAAOqB,MAAP,KAAkBzB,IAFpB,EAE0B;AACtB,2BAAOiC,uBAAuBjC,IAAvB,CAAP;AACH;AAvHT;;AA0HA,YAAIqB,4BAA4B,IAA5B,IACF,CAAC,KAAKa,qBAAL,EADC,IAEF,KAAKC,gBAAL,EAFF,EAGI,OAAO,IAAP;;AAEJ,eAAO,KAAP;AACH,KA3JD;;AA6JA,aAASC,QAAT,CAAkBpC,IAAlB,EAAwB;AACpB,eAAO1B,EAAE+D,gBAAF,CAAmBtB,KAAnB,CAAyBf,IAAzB,KACF1B,EAAEgE,iBAAF,CAAoBvB,KAApB,CAA0Bf,IAA1B,CADL;AAEH;;AAED,aAASuC,WAAT,CAAqBvC,IAArB,EAA2B;AACvB,eAAO1B,EAAEkE,eAAF,CAAkBzB,KAAlB,CAAwBf,IAAxB;AACL;AACA;AAFK,WAGD1B,EAAEmE,aAAF,IAAmBnE,EAAEmE,aAAF,CAAgB1B,KAAhB,CAAsBf,IAAtB,CAHlB,IAID1B,EAAEoE,cAAF,IAAoBpE,EAAEoE,cAAF,CAAiB3B,KAAjB,CAAuBf,IAAvB,CAJ1B;AAKH;;AAED,QAAI4B,aAAa,EAAjB;AACA,KAAC,CAAC,IAAD,CAAD,EACI,CAAC,IAAD,CADJ,EAEI,CAAC,GAAD,CAFJ,EAGI,CAAC,GAAD,CAHJ,EAII,CAAC,GAAD,CAJJ,EAKI,CAAC,IAAD,EAAO,KAAP,EAAc,IAAd,EAAoB,KAApB,CALJ,EAMI,CAAC,GAAD,EAAM,GAAN,EAAW,IAAX,EAAiB,IAAjB,EAAuB,IAAvB,EAA6B,YAA7B,CANJ,EAOI,CAAC,IAAD,EAAO,IAAP,EAAa,KAAb,CAPJ,EAQI,CAAC,GAAD,EAAM,GAAN,CARJ,EASI,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CATJ,EAUEe,OAVF,CAUU,UAAUC,IAAV,EAAgBC,CAAhB,EAAmB;AACzBD,aAAKD,OAAL,CAAa,UAAUG,EAAV,EAAc;AACvBlB,uBAAWkB,EAAX,IAAiBD,CAAjB;AACH,SAFD;AAGH,KAdD;;AAgBA,aAASZ,sBAAT,CAAgCjC,IAAhC,EAAsC;AAClC,YAAI1B,EAAEyE,cAAF,CAAiBhC,KAAjB,CAAuBf,IAAvB,CAAJ,EAAkC;AAC9B,mBAAO,IAAP;AACH;;AAED,YAAInB,QAAQkC,KAAR,CAAcf,IAAd,CAAJ,EAAyB;AACrB,mBAAOA,KAAKgD,IAAL,CAAUf,sBAAV,CAAP;AACH;;AAED,YAAI3D,EAAEwC,IAAF,CAAOC,KAAP,CAAaf,IAAb,CAAJ,EAAwB;AACpB,mBAAO7B,MAAM8E,SAAN,CAAgBjD,IAAhB,EAAsB,UAAUZ,IAAV,EAAgB8D,KAAhB,EAAuB;AAChD,uBAAOjB,uBAAuBiB,KAAvB,CAAP;AACH,aAFM,CAAP;AAGH;;AAED,eAAO,KAAP;AACH;;AAED3D,QAAI2C,qBAAJ,GAA4B,YAAY;AACpC,YAAIlC,OAAO,KAAKA,IAAhB;AACA,eAAO,CAAC1B,EAAE6E,kBAAF,CAAqBpC,KAArB,CAA2Bf,IAA3B,CAAD,IACF,CAAC1B,EAAE8E,gBAAF,CAAmBrC,KAAnB,CAAyBf,IAAzB,CADN;AAEH,KAJD;;AAMAT,QAAI4C,gBAAJ,GAAuB,YAAY;AAC/B,eAAOA,iBAAiB,IAAjB,CAAP;AACH,KAFD;;AAIA,aAASA,gBAAT,CAA0BkB,IAA1B,EAAgC;AAC5B,aAAK,IAAIrD,IAAJ,EAAUI,MAAf,EAAuBiD,KAAKjD,MAA5B,EAAoCiD,OAAOA,KAAKjD,MAAhD,EAAwD;AACpDJ,mBAAOqD,KAAKrD,IAAZ;AACAI,qBAASiD,KAAKjD,MAAL,CAAYJ,IAArB;;AAEA,gBAAI1B,EAAEgF,cAAF,CAAiBvC,KAAjB,CAAuBX,MAAvB,KACFiD,KAAKjD,MAAL,CAAYhB,IAAZ,KAAqB,MADnB,IAEFiE,KAAKjE,IAAL,KAAc,CAFhB,EAEmB;AACf,oBAAIgB,OAAOmD,IAAP,CAAY,CAAZ,MAAmBvD,IAAvB,EAA6B;AACzB,0BAAM,IAAIX,KAAJ,CAAU,qBAAV,CAAN;AACH;AACD,uBAAO,IAAP;AACH;;AAED,gBAAIf,EAAEkF,mBAAF,CAAsBzC,KAAtB,CAA4BX,MAA5B,KACFiD,KAAKjE,IAAL,KAAc,YADhB,EAC8B;AAC1B,oBAAIgB,OAAOqD,UAAP,KAAsBzD,IAA1B,EAAgC;AAC5B,0BAAM,IAAIX,KAAJ,CAAU,qBAAV,CAAN;AACH;AACD,uBAAO,IAAP;AACH;;AAED,gBAAIf,EAAEoF,kBAAF,CAAqB3C,KAArB,CAA2BX,MAA3B,KACFiD,KAAKjD,MAAL,CAAYhB,IAAZ,KAAqB,aADnB,IAEFiE,KAAKjE,IAAL,KAAc,CAFhB,EAEmB;AACf,oBAAIgB,OAAOuD,WAAP,CAAmB,CAAnB,MAA0B3D,IAA9B,EAAoC;AAChC,0BAAM,IAAIX,KAAJ,CAAU,qBAAV,CAAN;AACH;AACD;AACH;;AAED,gBAAIf,EAAEyE,cAAF,CAAiBhC,KAAjB,CAAuBX,MAAvB,KACFiD,KAAKjE,IAAL,KAAc,QADhB,EAC0B;AACtB,oBAAIgB,OAAOqB,MAAP,KAAkBzB,IAAtB,EAA4B;AACxB,0BAAM,IAAIX,KAAJ,CAAU,qBAAV,CAAN;AACH;AACD;AACH;;AAED,gBAAIf,EAAEsF,gBAAF,CAAmB7C,KAAnB,CAAyBX,MAAzB,KACFiD,KAAKjE,IAAL,KAAc,QADhB,EAC0B;AACtB,oBAAIgB,OAAOoB,MAAP,KAAkBxB,IAAtB,EAA4B;AACxB,0BAAM,IAAIX,KAAJ,CAAU,qBAAV,CAAN;AACH;AACD;AACH;;AAED,gBAAIf,EAAEuF,qBAAF,CAAwB9C,KAAxB,CAA8BX,MAA9B,KACFiD,KAAKjE,IAAL,KAAc,MADhB,EACwB;AACpB,oBAAIgB,OAAO4B,IAAP,KAAgBhC,IAApB,EAA0B;AACtB,0BAAM,IAAIX,KAAJ,CAAU,qBAAV,CAAN;AACH;AACD;AACH;;AAED,gBAAI+C,SAAShC,MAAT,KACFiD,KAAKjE,IAAL,KAAc,MADhB,EACwB;AACpB,oBAAIgB,OAAO0D,IAAP,KAAgB9D,IAApB,EAA0B;AACtB,0BAAM,IAAIX,KAAJ,CAAU,qBAAV,CAAN;AACH;AACD;AACH;;AAED,gBAAIf,EAAEkE,eAAF,CAAkBzB,KAAlB,CAAwBX,MAAxB,KACF,CAACA,OAAO2D,MADN,IAEFV,KAAKjE,IAAL,KAAc,UAFhB,EAE4B;AACxB,oBAAIgB,OAAO4D,QAAP,KAAoBhE,IAAxB,EAA8B;AAC1B,0BAAM,IAAIX,KAAJ,CAAU,qBAAV,CAAN;AACH;AACD;AACH;;AAED,mBAAO,KAAP;AACH;;AAED,eAAO,IAAP;AACH;;AAED;;;AAGA,aAASwB,sBAAT,CAAgCD,iBAAhC,EAAmD;AAC/C,YAAItC,EAAE2F,mBAAF,CAAsBlD,KAAtB,CAA4BH,kBAAkBZ,IAA9C,CAAJ,EAAyD;AACrD,gBAAIkE,eAAetD,kBAAkBX,GAAlB,CAAsB,cAAtB,EAAsCf,KAAzD;AACA,gBAAI,CAACgF,YAAD,IAAiBA,aAAaC,MAAb,KAAwB,CAA7C,EAAgD;AAC5C,uBAAOvD,kBAAkBD,KAAlB,EAAP;AACH;AACJ,SALD,MAKO,IAAIrC,EAAEkF,mBAAF,CAAsBzC,KAAtB,CAA4BH,kBAAkBZ,IAA9C,CAAJ,EAAyD;AAC5D,gBAAI,CAACY,kBAAkBX,GAAlB,CAAsB,YAAtB,EAAoCf,KAAzC,EAAgD;AAC5C,uBAAO0B,kBAAkBD,KAAlB,EAAP;AACH;AACJ,SAJM,MAIA,IAAIrC,EAAE8F,WAAF,CAAcrD,KAAd,CAAoBH,kBAAkBZ,IAAtC,CAAJ,EAAiD;AACpDqE,yCAA6BzD,iBAA7B;AACH;;AAED,eAAOA,iBAAP;AACH;;AAED,aAASyD,4BAAT,CAAsCC,WAAtC,EAAmD;AAC/C,YAAIC,iBAAiBD,YAAYrE,GAAZ,CAAgB,MAAhB,EAAwBf,KAA7C;AACA,YAAIsF,YAAYF,YAAYrE,GAAZ,CAAgB,WAAhB,EAA6Bf,KAA7C;AACA,YAAIuF,aAAaH,YAAYrE,GAAZ,CAAgB,YAAhB,EAA8Bf,KAA/C;;AAEA,YAAI,CAACuF,UAAD,IAAe,CAACD,SAApB,EAA+B;AAC3B,gBAAIE,0BAA0BlG,EAAEmG,mBAAF,CAAsBJ,cAAtB,CAA9B;;AAEAD,wBAAY9D,OAAZ,CAAoBkE,uBAApB;AACH,SAJD,MAIO,IAAI,CAACD,UAAD,IAAeD,SAAnB,EAA8B;AACjC,gBAAII,wBAAwBpG,EAAEqG,eAAF,CAAkB,GAAlB,EAAuBN,cAAvB,EAAuC,IAAvC,CAA5B;;AAEA,gBAAIjG,EAAEkE,eAAF,CAAkBzB,KAAlB,CAAwBwD,cAAxB,KAA2CA,eAAe5C,QAAf,KAA4B,GAA3E,EAAgF;AAC5EiD,wCAAwBL,eAAeP,QAAvC;AACH;;AAEDM,wBAAYrE,GAAZ,CAAgB,MAAhB,EAAwBO,OAAxB,CAAgCoE,qBAAhC;AACAN,wBAAYrE,GAAZ,CAAgB,YAAhB,EAA8BO,OAA9B,CAAsCgE,SAAtC;AACAF,wBAAYrE,GAAZ,CAAgB,WAAhB,EAA6BO,OAA7B;AACH;AACJ;;AAED,WAAOvB,QAAP;AACH,CA3dD","file":"node-path.js","sourcesContent":["module.exports = function (fork) {\n    var types = fork.use(require(\"./types\"));\n    var n = types.namedTypes;\n    var b = types.builders;\n    var isNumber = types.builtInTypes.number;\n    var isArray = types.builtInTypes.array;\n    var Path = fork.use(require(\"./path\"));\n    var Scope = fork.use(require(\"./scope\"));\n\n    function NodePath(value, parentPath, name) {\n        if (!(this instanceof NodePath)) {\n            throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n        }\n        Path.call(this, value, parentPath, name);\n    }\n\n    var NPp = NodePath.prototype = Object.create(Path.prototype, {\n        constructor: {\n            value: NodePath,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n\n    Object.defineProperties(NPp, {\n        node: {\n            get: function () {\n                Object.defineProperty(this, \"node\", {\n                    configurable: true, // Enable deletion.\n                    value: this._computeNode()\n                });\n\n                return this.node;\n            }\n        },\n\n        parent: {\n            get: function () {\n                Object.defineProperty(this, \"parent\", {\n                    configurable: true, // Enable deletion.\n                    value: this._computeParent()\n                });\n\n                return this.parent;\n            }\n        },\n\n        scope: {\n            get: function () {\n                Object.defineProperty(this, \"scope\", {\n                    configurable: true, // Enable deletion.\n                    value: this._computeScope()\n                });\n\n                return this.scope;\n            }\n        }\n    });\n\n    NPp.replace = function () {\n        delete this.node;\n        delete this.parent;\n        delete this.scope;\n        return Path.prototype.replace.apply(this, arguments);\n    };\n\n    NPp.prune = function () {\n        var remainingNodePath = this.parent;\n\n        this.replace();\n\n        return cleanUpNodesAfterPrune(remainingNodePath);\n    };\n\n    // The value of the first ancestor Path whose value is a Node.\n    NPp._computeNode = function () {\n        var value = this.value;\n        if (n.Node.check(value)) {\n            return value;\n        }\n\n        var pp = this.parentPath;\n        return pp && pp.node || null;\n    };\n\n    // The first ancestor Path whose value is a Node distinct from this.node.\n    NPp._computeParent = function () {\n        var value = this.value;\n        var pp = this.parentPath;\n\n        if (!n.Node.check(value)) {\n            while (pp && !n.Node.check(pp.value)) {\n                pp = pp.parentPath;\n            }\n\n            if (pp) {\n                pp = pp.parentPath;\n            }\n        }\n\n        while (pp && !n.Node.check(pp.value)) {\n            pp = pp.parentPath;\n        }\n\n        return pp || null;\n    };\n\n    // The closest enclosing scope that governs this node.\n    NPp._computeScope = function () {\n        var value = this.value;\n        var pp = this.parentPath;\n        var scope = pp && pp.scope;\n\n        if (n.Node.check(value) &&\n          Scope.isEstablishedBy(value)) {\n            scope = new Scope(this, scope);\n        }\n\n        return scope || null;\n    };\n\n    NPp.getValueProperty = function (name) {\n        return types.getFieldValue(this.value, name);\n    };\n\n    /**\n     * Determine whether this.node needs to be wrapped in parentheses in order\n     * for a parser to reproduce the same local AST structure.\n     *\n     * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression\n     * whose operator is \"+\" needs parentheses, because `1 + 2 * 3` would\n     * parse differently.\n     *\n     * If assumeExpressionContext === true, we don't worry about edge cases\n     * like an anonymous FunctionExpression appearing lexically first in its\n     * enclosing statement and thus needing parentheses to avoid being parsed\n     * as a FunctionDeclaration with a missing name.\n     */\n    NPp.needsParens = function (assumeExpressionContext) {\n        var pp = this.parentPath;\n        if (!pp) {\n            return false;\n        }\n\n        var node = this.value;\n\n        // Only expressions need parentheses.\n        if (!n.Expression.check(node)) {\n            return false;\n        }\n\n        // Identifiers never need parentheses.\n        if (node.type === \"Identifier\") {\n            return false;\n        }\n\n        while (!n.Node.check(pp.value)) {\n            pp = pp.parentPath;\n            if (!pp) {\n                return false;\n            }\n        }\n\n        var parent = pp.value;\n\n        switch (node.type) {\n            case \"UnaryExpression\":\n            case \"SpreadElement\":\n            case \"SpreadProperty\":\n                return parent.type === \"MemberExpression\"\n                  && this.name === \"object\"\n                  && parent.object === node;\n\n            case \"BinaryExpression\":\n            case \"LogicalExpression\":\n                switch (parent.type) {\n                    case \"CallExpression\":\n                        return this.name === \"callee\"\n                          && parent.callee === node;\n\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                        return true;\n\n                    case \"MemberExpression\":\n                        return this.name === \"object\"\n                          && parent.object === node;\n\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                        var po = parent.operator;\n                        var pp = PRECEDENCE[po];\n                        var no = node.operator;\n                        var np = PRECEDENCE[no];\n\n                        if (pp > np) {\n                            return true;\n                        }\n\n                        if (pp === np && this.name === \"right\") {\n                            if (parent.right !== node) {\n                                throw new Error(\"Nodes must be equal\");\n                            }\n                            return true;\n                        }\n\n                    default:\n                        return false;\n                }\n\n            case \"SequenceExpression\":\n                switch (parent.type) {\n                    case \"ForStatement\":\n                        // Although parentheses wouldn't hurt around sequence\n                        // expressions in the head of for loops, traditional style\n                        // dictates that e.g. i++, j++ should not be wrapped with\n                        // parentheses.\n                        return false;\n\n                    case \"ExpressionStatement\":\n                        return this.name !== \"expression\";\n\n                    default:\n                        // Otherwise err on the side of overparenthesization, adding\n                        // explicit exceptions above if this proves overzealous.\n                        return true;\n                }\n\n            case \"YieldExpression\":\n                switch (parent.type) {\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                    case \"CallExpression\":\n                    case \"MemberExpression\":\n                    case \"NewExpression\":\n                    case \"ConditionalExpression\":\n                    case \"YieldExpression\":\n                        return true;\n\n                    default:\n                        return false;\n                }\n\n            case \"Literal\":\n                return parent.type === \"MemberExpression\"\n                  && isNumber.check(node.value)\n                  && this.name === \"object\"\n                  && parent.object === node;\n\n            case \"AssignmentExpression\":\n            case \"ConditionalExpression\":\n                switch (parent.type) {\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                        return true;\n\n                    case \"CallExpression\":\n                        return this.name === \"callee\"\n                          && parent.callee === node;\n\n                    case \"ConditionalExpression\":\n                        return this.name === \"test\"\n                          && parent.test === node;\n\n                    case \"MemberExpression\":\n                        return this.name === \"object\"\n                          && parent.object === node;\n\n                    default:\n                        return false;\n                }\n\n            default:\n                if (parent.type === \"NewExpression\" &&\n                  this.name === \"callee\" &&\n                  parent.callee === node) {\n                    return containsCallExpression(node);\n                }\n        }\n\n        if (assumeExpressionContext !== true &&\n          !this.canBeFirstInStatement() &&\n          this.firstInStatement())\n            return true;\n\n        return false;\n    };\n\n    function isBinary(node) {\n        return n.BinaryExpression.check(node)\n          || n.LogicalExpression.check(node);\n    }\n\n    function isUnaryLike(node) {\n        return n.UnaryExpression.check(node)\n          // I considered making SpreadElement and SpreadProperty subtypes\n          // of UnaryExpression, but they're not really Expression nodes.\n          || (n.SpreadElement && n.SpreadElement.check(node))\n          || (n.SpreadProperty && n.SpreadProperty.check(node));\n    }\n\n    var PRECEDENCE = {};\n    [[\"||\"],\n        [\"&&\"],\n        [\"|\"],\n        [\"^\"],\n        [\"&\"],\n        [\"==\", \"===\", \"!=\", \"!==\"],\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n        [\">>\", \"<<\", \">>>\"],\n        [\"+\", \"-\"],\n        [\"*\", \"/\", \"%\"]\n    ].forEach(function (tier, i) {\n        tier.forEach(function (op) {\n            PRECEDENCE[op] = i;\n        });\n    });\n\n    function containsCallExpression(node) {\n        if (n.CallExpression.check(node)) {\n            return true;\n        }\n\n        if (isArray.check(node)) {\n            return node.some(containsCallExpression);\n        }\n\n        if (n.Node.check(node)) {\n            return types.someField(node, function (name, child) {\n                return containsCallExpression(child);\n            });\n        }\n\n        return false;\n    }\n\n    NPp.canBeFirstInStatement = function () {\n        var node = this.node;\n        return !n.FunctionExpression.check(node)\n          && !n.ObjectExpression.check(node);\n    };\n\n    NPp.firstInStatement = function () {\n        return firstInStatement(this);\n    };\n\n    function firstInStatement(path) {\n        for (var node, parent; path.parent; path = path.parent) {\n            node = path.node;\n            parent = path.parent.node;\n\n            if (n.BlockStatement.check(parent) &&\n              path.parent.name === \"body\" &&\n              path.name === 0) {\n                if (parent.body[0] !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                return true;\n            }\n\n            if (n.ExpressionStatement.check(parent) &&\n              path.name === \"expression\") {\n                if (parent.expression !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                return true;\n            }\n\n            if (n.SequenceExpression.check(parent) &&\n              path.parent.name === \"expressions\" &&\n              path.name === 0) {\n                if (parent.expressions[0] !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n\n            if (n.CallExpression.check(parent) &&\n              path.name === \"callee\") {\n                if (parent.callee !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n\n            if (n.MemberExpression.check(parent) &&\n              path.name === \"object\") {\n                if (parent.object !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n\n            if (n.ConditionalExpression.check(parent) &&\n              path.name === \"test\") {\n                if (parent.test !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n\n            if (isBinary(parent) &&\n              path.name === \"left\") {\n                if (parent.left !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n\n            if (n.UnaryExpression.check(parent) &&\n              !parent.prefix &&\n              path.name === \"argument\") {\n                if (parent.argument !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.\n     */\n    function cleanUpNodesAfterPrune(remainingNodePath) {\n        if (n.VariableDeclaration.check(remainingNodePath.node)) {\n            var declarations = remainingNodePath.get('declarations').value;\n            if (!declarations || declarations.length === 0) {\n                return remainingNodePath.prune();\n            }\n        } else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n            if (!remainingNodePath.get('expression').value) {\n                return remainingNodePath.prune();\n            }\n        } else if (n.IfStatement.check(remainingNodePath.node)) {\n            cleanUpIfStatementAfterPrune(remainingNodePath);\n        }\n\n        return remainingNodePath;\n    }\n\n    function cleanUpIfStatementAfterPrune(ifStatement) {\n        var testExpression = ifStatement.get('test').value;\n        var alternate = ifStatement.get('alternate').value;\n        var consequent = ifStatement.get('consequent').value;\n\n        if (!consequent && !alternate) {\n            var testExpressionStatement = b.expressionStatement(testExpression);\n\n            ifStatement.replace(testExpressionStatement);\n        } else if (!consequent && alternate) {\n            var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n\n            if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n                negatedTestExpression = testExpression.argument;\n            }\n\n            ifStatement.get(\"test\").replace(negatedTestExpression);\n            ifStatement.get(\"consequent\").replace(alternate);\n            ifStatement.get(\"alternate\").replace();\n        }\n    }\n\n    return NodePath;\n};\n"]}