{"version":3,"sources":["../../../../src/node_modules/ast-types/lib/shared.js"],"names":["module","exports","fork","types","use","require","Type","builtin","builtInTypes","isNumber","number","geq","than","value","check","defaults","naiveIsPrimitive","or","string","boolean","null","undefined","isPrimitive","type","toString"],"mappings":";;;;AAAAA,OAAOC,OAAP,GAAiB,UAAUC,IAAV,EAAgB;AAC7B,QAAID,UAAU,EAAd;AACA,QAAIE,QAAQD,KAAKE,GAAL,CAASC,QAAQ,cAAR,CAAT,CAAZ;AACA,QAAIC,OAAOH,MAAMG,IAAjB;AACA,QAAIC,UAAUJ,MAAMK,YAApB;AACA,QAAIC,WAAWF,QAAQG,MAAvB;;AAEA;AACA;AACAT,YAAQU,GAAR,GAAc,UAAUC,IAAV,EAAgB;AAC1B,eAAO,IAAIN,IAAJ,CAAS,UAAUO,KAAV,EAAiB;AAC7B,mBAAOJ,SAASK,KAAT,CAAeD,KAAf,KAAyBA,SAASD,IAAzC;AACH,SAFM,EAEJH,WAAW,MAAX,GAAoBG,IAFhB,CAAP;AAGH,KAJD;;AAMA;AACA;AACAX,YAAQc,QAAR,GAAmB;AACf;AACA;AACA;AACA,gBAAQ,iBAAY;AAAE,mBAAO,IAAP;AAAa,SAJpB;AAKf,sBAAc,sBAAY;AAAE,mBAAO,EAAP;AAAW,SALxB;AAMf,iBAAS,kBAAY;AAAE,mBAAO,KAAP;AAAc,SANtB;AAOf,gBAAQ,iBAAY;AAAE,mBAAO,IAAP;AAAa,SAPpB;AAQf,qBAAa,qBAAY,CAAE;AARZ,KAAnB;;AAWA,QAAIC,mBAAmBV,KAAKW,EAAL,CACrBV,QAAQW,MADa,EAErBX,QAAQG,MAFa,EAGrBH,QAAQY,OAHa,EAIrBZ,QAAQa,IAJa,EAKrBb,QAAQc,SALa,CAAvB;;AAQApB,YAAQqB,WAAR,GAAsB,IAAIhB,IAAJ,CAAS,UAAUO,KAAV,EAAiB;AAC5C,YAAIA,UAAU,IAAd,EACI,OAAO,IAAP;AACJ,YAAIU,cAAcV,KAAd,yCAAcA,KAAd,CAAJ;AACA,eAAO,EAAEU,SAAS,QAAT,IACTA,SAAS,UADF,CAAP;AAEH,KANqB,EAMnBP,iBAAiBQ,QAAjB,EANmB,CAAtB;;AAQA,WAAOvB,OAAP;AACH,CA7CD","file":"shared.js","sourcesContent":["module.exports = function (fork) {\n    var exports = {};\n    var types = fork.use(require(\"../lib/types\"));\n    var Type = types.Type;\n    var builtin = types.builtInTypes;\n    var isNumber = builtin.number;\n\n    // An example of constructing a new type with arbitrary constraints from\n    // an existing type.\n    exports.geq = function (than) {\n        return new Type(function (value) {\n            return isNumber.check(value) && value >= than;\n        }, isNumber + \" >= \" + than);\n    };\n\n    // Default value-returning functions that may optionally be passed as a\n    // third argument to Def.prototype.field.\n    exports.defaults = {\n        // Functions were used because (among other reasons) that's the most\n        // elegant way to allow for the emptyArray one always to give a new\n        // array instance.\n        \"null\": function () { return null },\n        \"emptyArray\": function () { return [] },\n        \"false\": function () { return false },\n        \"true\": function () { return true },\n        \"undefined\": function () {}\n    };\n\n    var naiveIsPrimitive = Type.or(\n      builtin.string,\n      builtin.number,\n      builtin.boolean,\n      builtin.null,\n      builtin.undefined\n    );\n\n    exports.isPrimitive = new Type(function (value) {\n        if (value === null)\n            return true;\n        var type = typeof value;\n        return !(type === \"object\" ||\n        type === \"function\");\n    }, naiveIsPrimitive.toString());\n\n    return exports;\n};"]}