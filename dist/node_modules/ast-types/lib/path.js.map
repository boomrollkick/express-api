{"version":3,"sources":["../../../../src/node_modules/ast-types/lib/path.js"],"names":["Ap","Array","prototype","slice","map","Op","Object","hasOwn","hasOwnProperty","module","exports","fork","types","use","require","isArray","builtInTypes","array","isNumber","number","Path","value","parentPath","name","Error","__childCache","Pp","getChildCache","path","create","getChildPath","cache","actualChildValue","getValueProperty","childPath","call","constructor","get","names","arguments","count","length","i","each","callback","context","childPaths","len","result","push","filter","emptyMoves","getMoves","offset","start","end","assert","argc","Math","max","min","moves","newIndex","shift","move","unshift","node","apply","pop","insertAt","index","insertBefore","pp","insertAtArgs","insertAfter","repairRelationshipWithParent","parentValue","parentCache","check","indexOf","replace","replacement","results","originalLength","spliceArgs","splicedOut","splice"],"mappings":";;AAAA,IAAIA,KAAKC,MAAMC,SAAf;AACA,IAAIC,QAAQH,GAAGG,KAAf;AACA,IAAIC,MAAMJ,GAAGI,GAAb;AACA,IAAIC,KAAKC,OAAOJ,SAAhB;AACA,IAAIK,SAASF,GAAGG,cAAhB;;AAEAC,OAAOC,OAAP,GAAiB,UAAUC,IAAV,EAAgB;AAC7B,QAAIC,QAAQD,KAAKE,GAAL,CAASC,QAAQ,SAAR,CAAT,CAAZ;AACA,QAAIC,UAAUH,MAAMI,YAAN,CAAmBC,KAAjC;AACA,QAAIC,WAAWN,MAAMI,YAAN,CAAmBG,MAAlC;;AAEA,aAASC,IAAT,CAAcC,KAAd,EAAqBC,UAArB,EAAiCC,IAAjC,EAAuC;AACnC,YAAI,EAAE,gBAAgBH,IAAlB,CAAJ,EAA6B;AACzB,kBAAM,IAAII,KAAJ,CAAU,kDAAV,CAAN;AACH;;AAED,YAAIF,UAAJ,EAAgB;AACZ,gBAAI,EAAEA,sBAAsBF,IAAxB,CAAJ,EAAmC;AAC/B,sBAAM,IAAII,KAAJ,CAAU,EAAV,CAAN;AACH;AACJ,SAJD,MAIO;AACHF,yBAAa,IAAb;AACAC,mBAAO,IAAP;AACH;;AAED;AACA;AACA,aAAKF,KAAL,GAAaA,KAAb;;AAEA;AACA,aAAKC,UAAL,GAAkBA,UAAlB;;AAEA;AACA;AACA,aAAKC,IAAL,GAAYA,IAAZ;;AAEA;AACA;AACA,aAAKE,YAAL,GAAoB,IAApB;AACH;;AAED,QAAIC,KAAKN,KAAKlB,SAAd;;AAEA,aAASyB,aAAT,CAAuBC,IAAvB,EAA6B;AACzB;AACA;AACA,eAAOA,KAAKH,YAAL,KAAsBG,KAAKH,YAAL,GAAoBnB,OAAOuB,MAAP,CAAc,IAAd,CAA1C,CAAP;AACH;;AAED,aAASC,YAAT,CAAsBF,IAAtB,EAA4BL,IAA5B,EAAkC;AAC9B,YAAIQ,QAAQJ,cAAcC,IAAd,CAAZ;AACA,YAAII,mBAAmBJ,KAAKK,gBAAL,CAAsBV,IAAtB,CAAvB;AACA,YAAIW,YAAYH,MAAMR,IAAN,CAAhB;AACA,YAAI,CAAChB,OAAO4B,IAAP,CAAYJ,KAAZ,EAAmBR,IAAnB,CAAD;AACF;AACAW,kBAAUb,KAAV,KAAoBW,gBAFtB,EAEwC;AACpCE,wBAAYH,MAAMR,IAAN,IAAc,IAAIK,KAAKQ,WAAT,CACxBJ,gBADwB,EACNJ,IADM,EACAL,IADA,CAA1B;AAGH;AACD,eAAOW,SAAP;AACH;;AAEL;AACA;AACIR,OAAGO,gBAAH,GAAsB,SAASA,gBAAT,CAA0BV,IAA1B,EAAgC;AAClD,eAAO,KAAKF,KAAL,CAAWE,IAAX,CAAP;AACH,KAFD;;AAIAG,OAAGW,GAAH,GAAS,SAASA,GAAT,CAAad,IAAb,EAAmB;AACxB,YAAIK,OAAO,IAAX;AACA,YAAIU,QAAQC,SAAZ;AACA,YAAIC,QAAQF,MAAMG,MAAlB;;AAEA,aAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIF,KAApB,EAA2B,EAAEE,CAA7B,EAAgC;AAC5Bd,mBAAOE,aAAaF,IAAb,EAAmBU,MAAMI,CAAN,CAAnB,CAAP;AACH;;AAED,eAAOd,IAAP;AACH,KAVD;;AAYAF,OAAGiB,IAAH,GAAU,SAASA,IAAT,CAAcC,QAAd,EAAwBC,OAAxB,EAAiC;AACvC,YAAIC,aAAa,EAAjB;AACA,YAAIC,MAAM,KAAK1B,KAAL,CAAWoB,MAArB;AACA,YAAIC,IAAI,CAAR;;AAEA;AACA,aAAK,IAAIA,IAAI,CAAb,EAAgBA,IAAIK,GAApB,EAAyB,EAAEL,CAA3B,EAA8B;AAC1B,gBAAInC,OAAO4B,IAAP,CAAY,KAAKd,KAAjB,EAAwBqB,CAAxB,CAAJ,EAAgC;AAC5BI,2BAAWJ,CAAX,IAAgB,KAAKL,GAAL,CAASK,CAAT,CAAhB;AACH;AACJ;;AAED;AACA;AACA;AACA;AACAG,kBAAUA,WAAW,IAArB;AACA,aAAKH,IAAI,CAAT,EAAYA,IAAIK,GAAhB,EAAqB,EAAEL,CAAvB,EAA0B;AACtB,gBAAInC,OAAO4B,IAAP,CAAYW,UAAZ,EAAwBJ,CAAxB,CAAJ,EAAgC;AAC5BE,yBAAST,IAAT,CAAcU,OAAd,EAAuBC,WAAWJ,CAAX,CAAvB;AACH;AACJ;AACJ,KAtBD;;AAwBAhB,OAAGtB,GAAH,GAAS,SAASA,GAAT,CAAawC,QAAb,EAAuBC,OAAvB,EAAgC;AACrC,YAAIG,SAAS,EAAb;;AAEA,aAAKL,IAAL,CAAU,UAAUT,SAAV,EAAqB;AAC3Bc,mBAAOC,IAAP,CAAYL,SAAST,IAAT,CAAc,IAAd,EAAoBD,SAApB,CAAZ;AACH,SAFD,EAEGW,OAFH;;AAIA,eAAOG,MAAP;AACH,KARD;;AAUAtB,OAAGwB,MAAH,GAAY,SAASA,MAAT,CAAgBN,QAAhB,EAA0BC,OAA1B,EAAmC;AAC3C,YAAIG,SAAS,EAAb;;AAEA,aAAKL,IAAL,CAAU,UAAUT,SAAV,EAAqB;AAC3B,gBAAIU,SAAST,IAAT,CAAc,IAAd,EAAoBD,SAApB,CAAJ,EAAoC;AAChCc,uBAAOC,IAAP,CAAYf,SAAZ;AACH;AACJ,SAJD,EAIGW,OAJH;;AAMA,eAAOG,MAAP;AACH,KAVD;;AAYA,aAASG,UAAT,GAAsB,CAAE;AACxB,aAASC,QAAT,CAAkBxB,IAAlB,EAAwByB,MAAxB,EAAgCC,KAAhC,EAAuCC,GAAvC,EAA4C;AACxCxC,gBAAQyC,MAAR,CAAe5B,KAAKP,KAApB;;AAEA,YAAIgC,WAAW,CAAf,EAAkB;AACd,mBAAOF,UAAP;AACH;;AAED,YAAIV,SAASb,KAAKP,KAAL,CAAWoB,MAAxB;AACA,YAAIA,SAAS,CAAb,EAAgB;AACZ,mBAAOU,UAAP;AACH;;AAED,YAAIM,OAAOlB,UAAUE,MAArB;AACA,YAAIgB,SAAS,CAAb,EAAgB;AACZH,oBAAQ,CAAR;AACAC,kBAAMd,MAAN;AACH,SAHD,MAGO,IAAIgB,SAAS,CAAb,EAAgB;AACnBH,oBAAQI,KAAKC,GAAL,CAASL,KAAT,EAAgB,CAAhB,CAAR;AACAC,kBAAMd,MAAN;AACH,SAHM,MAGA;AACHa,oBAAQI,KAAKC,GAAL,CAASL,KAAT,EAAgB,CAAhB,CAAR;AACAC,kBAAMG,KAAKE,GAAL,CAASL,GAAT,EAAcd,MAAd,CAAN;AACH;;AAEDvB,iBAASsC,MAAT,CAAgBF,KAAhB;AACApC,iBAASsC,MAAT,CAAgBD,GAAhB;;AAEA,YAAIM,QAAQvD,OAAOuB,MAAP,CAAc,IAAd,CAAZ;AACA,YAAIE,QAAQJ,cAAcC,IAAd,CAAZ;;AAEA,aAAK,IAAIc,IAAIY,KAAb,EAAoBZ,IAAIa,GAAxB,EAA6B,EAAEb,CAA/B,EAAkC;AAC9B,gBAAInC,OAAO4B,IAAP,CAAYP,KAAKP,KAAjB,EAAwBqB,CAAxB,CAAJ,EAAgC;AAC5B,oBAAIR,YAAYN,KAAKS,GAAL,CAASK,CAAT,CAAhB;AACA,oBAAIR,UAAUX,IAAV,KAAmBmB,CAAvB,EAA0B;AACtB,0BAAM,IAAIlB,KAAJ,CAAU,EAAV,CAAN;AACH;AACD,oBAAIsC,WAAWpB,IAAIW,MAAnB;AACAnB,0BAAUX,IAAV,GAAiBuC,QAAjB;AACAD,sBAAMC,QAAN,IAAkB5B,SAAlB;AACA,uBAAOH,MAAMW,CAAN,CAAP;AACH;AACJ;;AAED,eAAOX,MAAMU,MAAb;;AAEA,eAAO,YAAY;AACf,iBAAK,IAAIqB,QAAT,IAAqBD,KAArB,EAA4B;AACxB,oBAAI3B,YAAY2B,MAAMC,QAAN,CAAhB;AACA,oBAAI5B,UAAUX,IAAV,KAAmB,CAACuC,QAAxB,EAAkC;AAC9B,0BAAM,IAAItC,KAAJ,CAAU,EAAV,CAAN;AACH;AACDO,sBAAM+B,QAAN,IAAkB5B,SAAlB;AACAN,qBAAKP,KAAL,CAAWyC,QAAX,IAAuB5B,UAAUb,KAAjC;AACH;AACJ,SATD;AAUH;;AAEDK,OAAGqC,KAAH,GAAW,SAASA,KAAT,GAAiB;AACxB,YAAIC,OAAOZ,SAAS,IAAT,EAAe,CAAC,CAAhB,CAAX;AACA,YAAIJ,SAAS,KAAK3B,KAAL,CAAW0C,KAAX,EAAb;AACAC;AACA,eAAOhB,MAAP;AACH,KALD;;AAOAtB,OAAGuC,OAAH,GAAa,SAASA,OAAT,CAAiBC,IAAjB,EAAuB;AAChC,YAAIF,OAAOZ,SAAS,IAAT,EAAeb,UAAUE,MAAzB,CAAX;AACA,YAAIO,SAAS,KAAK3B,KAAL,CAAW4C,OAAX,CAAmBE,KAAnB,CAAyB,KAAK9C,KAA9B,EAAqCkB,SAArC,CAAb;AACAyB;AACA,eAAOhB,MAAP;AACH,KALD;;AAOAtB,OAAGuB,IAAH,GAAU,SAASA,IAAT,CAAciB,IAAd,EAAoB;AAC1BnD,gBAAQyC,MAAR,CAAe,KAAKnC,KAApB;AACA,eAAOM,cAAc,IAAd,EAAoBc,MAA3B;AACA,eAAO,KAAKpB,KAAL,CAAW4B,IAAX,CAAgBkB,KAAhB,CAAsB,KAAK9C,KAA3B,EAAkCkB,SAAlC,CAAP;AACH,KAJD;;AAMAb,OAAG0C,GAAH,GAAS,SAASA,GAAT,GAAe;AACpBrD,gBAAQyC,MAAR,CAAe,KAAKnC,KAApB;AACA,YAAIU,QAAQJ,cAAc,IAAd,CAAZ;AACA,eAAOI,MAAM,KAAKV,KAAL,CAAWoB,MAAX,GAAoB,CAA1B,CAAP;AACA,eAAOV,MAAMU,MAAb;AACA,eAAO,KAAKpB,KAAL,CAAW+C,GAAX,EAAP;AACH,KAND;;AAQA1C,OAAG2C,QAAH,GAAc,SAASA,QAAT,CAAkBC,KAAlB,EAAyBJ,IAAzB,EAA+B;AACzC,YAAIT,OAAOlB,UAAUE,MAArB;AACA,YAAIuB,OAAOZ,SAAS,IAAT,EAAeK,OAAO,CAAtB,EAAyBa,KAAzB,CAAX;AACA,YAAIN,SAASb,UAAb,EAAyB;AACrB,mBAAO,IAAP;AACH;;AAEDmB,gBAAQZ,KAAKC,GAAL,CAASW,KAAT,EAAgB,CAAhB,CAAR;;AAEA,aAAK,IAAI5B,IAAI,CAAb,EAAgBA,IAAIe,IAApB,EAA0B,EAAEf,CAA5B,EAA+B;AAC3B,iBAAKrB,KAAL,CAAWiD,QAAQ5B,CAAR,GAAY,CAAvB,IAA4BH,UAAUG,CAAV,CAA5B;AACH;;AAEDsB;;AAEA,eAAO,IAAP;AACH,KAhBD;;AAkBAtC,OAAG6C,YAAH,GAAkB,SAASA,YAAT,CAAsBL,IAAtB,EAA4B;AAC1C,YAAIM,KAAK,KAAKlD,UAAd;AACA,YAAImC,OAAOlB,UAAUE,MAArB;AACA,YAAIgC,eAAe,CAAC,KAAKlD,IAAN,CAAnB;AACA,aAAK,IAAImB,IAAI,CAAb,EAAgBA,IAAIe,IAApB,EAA0B,EAAEf,CAA5B,EAA+B;AAC3B+B,yBAAaxB,IAAb,CAAkBV,UAAUG,CAAV,CAAlB;AACH;AACD,eAAO8B,GAAGH,QAAH,CAAYF,KAAZ,CAAkBK,EAAlB,EAAsBC,YAAtB,CAAP;AACH,KARD;;AAUA/C,OAAGgD,WAAH,GAAiB,SAASA,WAAT,CAAqBR,IAArB,EAA2B;AACxC,YAAIM,KAAK,KAAKlD,UAAd;AACA,YAAImC,OAAOlB,UAAUE,MAArB;AACA,YAAIgC,eAAe,CAAC,KAAKlD,IAAL,GAAY,CAAb,CAAnB;AACA,aAAK,IAAImB,IAAI,CAAb,EAAgBA,IAAIe,IAApB,EAA0B,EAAEf,CAA5B,EAA+B;AAC3B+B,yBAAaxB,IAAb,CAAkBV,UAAUG,CAAV,CAAlB;AACH;AACD,eAAO8B,GAAGH,QAAH,CAAYF,KAAZ,CAAkBK,EAAlB,EAAsBC,YAAtB,CAAP;AACH,KARD;;AAUA,aAASE,4BAAT,CAAsC/C,IAAtC,EAA4C;AACxC,YAAI,EAAEA,gBAAgBR,IAAlB,CAAJ,EAA6B;AACzB,kBAAM,IAAII,KAAJ,CAAU,EAAV,CAAN;AACH;;AAED,YAAIgD,KAAK5C,KAAKN,UAAd;AACA,YAAI,CAACkD,EAAL,EAAS;AACL;AACA,mBAAO5C,IAAP;AACH;;AAED,YAAIgD,cAAcJ,GAAGnD,KAArB;AACA,YAAIwD,cAAclD,cAAc6C,EAAd,CAAlB;;AAEA;AACA,YAAII,YAAYhD,KAAKL,IAAjB,MAA2BK,KAAKP,KAApC,EAA2C;AACvCwD,wBAAYjD,KAAKL,IAAjB,IAAyBK,IAAzB;AACH,SAFD,MAEO,IAAIb,QAAQ+D,KAAR,CAAcF,WAAd,CAAJ,EAAgC;AACnC;AACA;AACA,gBAAIlC,IAAIkC,YAAYG,OAAZ,CAAoBnD,KAAKP,KAAzB,CAAR;AACA,gBAAIqB,KAAK,CAAT,EAAY;AACRmC,4BAAYjD,KAAKL,IAAL,GAAYmB,CAAxB,IAA6Bd,IAA7B;AACH;AACJ,SAPM,MAOA;AACH;AACA;AACA;AACAgD,wBAAYhD,KAAKL,IAAjB,IAAyBK,KAAKP,KAA9B;AACAwD,wBAAYjD,KAAKL,IAAjB,IAAyBK,IAAzB;AACH;;AAED,YAAIgD,YAAYhD,KAAKL,IAAjB,MAA2BK,KAAKP,KAApC,EAA2C;AACvC,kBAAM,IAAIG,KAAJ,CAAU,EAAV,CAAN;AACH;AACD,YAAII,KAAKN,UAAL,CAAgBe,GAAhB,CAAoBT,KAAKL,IAAzB,MAAmCK,IAAvC,EAA6C;AACzC,kBAAM,IAAIJ,KAAJ,CAAU,EAAV,CAAN;AACH;;AAED,eAAOI,IAAP;AACH;;AAEDF,OAAGsD,OAAH,GAAa,SAASA,OAAT,CAAiBC,WAAjB,EAA8B;AACvC,YAAIC,UAAU,EAAd;AACA,YAAIN,cAAc,KAAKtD,UAAL,CAAgBD,KAAlC;AACA,YAAIwD,cAAclD,cAAc,KAAKL,UAAnB,CAAlB;AACA,YAAIkB,QAAQD,UAAUE,MAAtB;;AAEAkC,qCAA6B,IAA7B;;AAEA,YAAI5D,QAAQ+D,KAAR,CAAcF,WAAd,CAAJ,EAAgC;AAC5B,gBAAIO,iBAAiBP,YAAYnC,MAAjC;AACA,gBAAIuB,OAAOZ,SAAS,KAAK9B,UAAd,EAA0BkB,QAAQ,CAAlC,EAAqC,KAAKjB,IAAL,GAAY,CAAjD,CAAX;;AAEA,gBAAI6D,aAAa,CAAC,KAAK7D,IAAN,EAAY,CAAZ,CAAjB;AACA,iBAAK,IAAImB,IAAI,CAAb,EAAgBA,IAAIF,KAApB,EAA2B,EAAEE,CAA7B,EAAgC;AAC5B0C,2BAAWnC,IAAX,CAAgBV,UAAUG,CAAV,CAAhB;AACH;;AAED,gBAAI2C,aAAaT,YAAYU,MAAZ,CAAmBnB,KAAnB,CAAyBS,WAAzB,EAAsCQ,UAAtC,CAAjB;;AAEA,gBAAIC,WAAW,CAAX,MAAkB,KAAKhE,KAA3B,EAAkC;AAC9B,sBAAM,IAAIG,KAAJ,CAAU,EAAV,CAAN;AACH;AACD,gBAAIoD,YAAYnC,MAAZ,KAAwB0C,iBAAiB,CAAjB,GAAqB3C,KAAjD,EAAyD;AACrD,sBAAM,IAAIhB,KAAJ,CAAU,EAAV,CAAN;AACH;;AAEDwC;;AAEA,gBAAIxB,UAAU,CAAd,EAAiB;AACb,uBAAO,KAAKnB,KAAZ;AACA,uBAAOwD,YAAY,KAAKtD,IAAjB,CAAP;AACA,qBAAKE,YAAL,GAAoB,IAApB;AAEH,aALD,MAKO;AACH,oBAAImD,YAAY,KAAKrD,IAAjB,MAA2B0D,WAA/B,EAA4C;AACxC,0BAAM,IAAIzD,KAAJ,CAAU,EAAV,CAAN;AACH;;AAED,oBAAI,KAAKH,KAAL,KAAe4D,WAAnB,EAAgC;AAC5B,yBAAK5D,KAAL,GAAa4D,WAAb;AACA,yBAAKxD,YAAL,GAAoB,IAApB;AACH;;AAED,qBAAKiB,IAAI,CAAT,EAAYA,IAAIF,KAAhB,EAAuB,EAAEE,CAAzB,EAA4B;AACxBwC,4BAAQjC,IAAR,CAAa,KAAK3B,UAAL,CAAgBe,GAAhB,CAAoB,KAAKd,IAAL,GAAYmB,CAAhC,CAAb;AACH;;AAED,oBAAIwC,QAAQ,CAAR,MAAe,IAAnB,EAAyB;AACrB,0BAAM,IAAI1D,KAAJ,CAAU,EAAV,CAAN;AACH;AACJ;AAEJ,SA5CD,MA4CO,IAAIgB,UAAU,CAAd,EAAiB;AACpB,gBAAI,KAAKnB,KAAL,KAAe4D,WAAnB,EAAgC;AAC5B,qBAAKxD,YAAL,GAAoB,IAApB;AACH;AACD,iBAAKJ,KAAL,GAAauD,YAAY,KAAKrD,IAAjB,IAAyB0D,WAAtC;AACAC,oBAAQjC,IAAR,CAAa,IAAb;AAEH,SAPM,MAOA,IAAIT,UAAU,CAAd,EAAiB;AACpB,mBAAOoC,YAAY,KAAKrD,IAAjB,CAAP;AACA,mBAAO,KAAKF,KAAZ;AACA,iBAAKI,YAAL,GAAoB,IAApB;;AAEA;AACA;AAEH,SARM,MAQA;AACH,kBAAM,IAAID,KAAJ,CAAU,wBAAV,CAAN;AACH;;AAED,eAAO0D,OAAP;AACH,KAxED;;AA0EA,WAAO9D,IAAP;AACH,CA1WD","file":"path.js","sourcesContent":["var Ap = Array.prototype;\nvar slice = Ap.slice;\nvar map = Ap.map;\nvar Op = Object.prototype;\nvar hasOwn = Op.hasOwnProperty;\n\nmodule.exports = function (fork) {\n    var types = fork.use(require(\"./types\"));\n    var isArray = types.builtInTypes.array;\n    var isNumber = types.builtInTypes.number;\n\n    function Path(value, parentPath, name) {\n        if (!(this instanceof Path)) {\n            throw new Error(\"Path constructor cannot be invoked without 'new'\");\n        }\n\n        if (parentPath) {\n            if (!(parentPath instanceof Path)) {\n                throw new Error(\"\");\n            }\n        } else {\n            parentPath = null;\n            name = null;\n        }\n\n        // The value encapsulated by this Path, generally equal to\n        // parentPath.value[name] if we have a parentPath.\n        this.value = value;\n\n        // The immediate parent Path of this Path.\n        this.parentPath = parentPath;\n\n        // The name of the property of parentPath.value through which this\n        // Path's value was reached.\n        this.name = name;\n\n        // Calling path.get(\"child\") multiple times always returns the same\n        // child Path object, for both performance and consistency reasons.\n        this.__childCache = null;\n    }\n\n    var Pp = Path.prototype;\n\n    function getChildCache(path) {\n        // Lazily create the child cache. This also cheapens cache\n        // invalidation, since you can just reset path.__childCache to null.\n        return path.__childCache || (path.__childCache = Object.create(null));\n    }\n\n    function getChildPath(path, name) {\n        var cache = getChildCache(path);\n        var actualChildValue = path.getValueProperty(name);\n        var childPath = cache[name];\n        if (!hasOwn.call(cache, name) ||\n          // Ensure consistency between cache and reality.\n          childPath.value !== actualChildValue) {\n            childPath = cache[name] = new path.constructor(\n              actualChildValue, path, name\n            );\n        }\n        return childPath;\n    }\n\n// This method is designed to be overridden by subclasses that need to\n// handle missing properties, etc.\n    Pp.getValueProperty = function getValueProperty(name) {\n        return this.value[name];\n    };\n\n    Pp.get = function get(name) {\n        var path = this;\n        var names = arguments;\n        var count = names.length;\n\n        for (var i = 0; i < count; ++i) {\n            path = getChildPath(path, names[i]);\n        }\n\n        return path;\n    };\n\n    Pp.each = function each(callback, context) {\n        var childPaths = [];\n        var len = this.value.length;\n        var i = 0;\n\n        // Collect all the original child paths before invoking the callback.\n        for (var i = 0; i < len; ++i) {\n            if (hasOwn.call(this.value, i)) {\n                childPaths[i] = this.get(i);\n            }\n        }\n\n        // Invoke the callback on just the original child paths, regardless of\n        // any modifications made to the array by the callback. I chose these\n        // semantics over cleverly invoking the callback on new elements because\n        // this way is much easier to reason about.\n        context = context || this;\n        for (i = 0; i < len; ++i) {\n            if (hasOwn.call(childPaths, i)) {\n                callback.call(context, childPaths[i]);\n            }\n        }\n    };\n\n    Pp.map = function map(callback, context) {\n        var result = [];\n\n        this.each(function (childPath) {\n            result.push(callback.call(this, childPath));\n        }, context);\n\n        return result;\n    };\n\n    Pp.filter = function filter(callback, context) {\n        var result = [];\n\n        this.each(function (childPath) {\n            if (callback.call(this, childPath)) {\n                result.push(childPath);\n            }\n        }, context);\n\n        return result;\n    };\n\n    function emptyMoves() {}\n    function getMoves(path, offset, start, end) {\n        isArray.assert(path.value);\n\n        if (offset === 0) {\n            return emptyMoves;\n        }\n\n        var length = path.value.length;\n        if (length < 1) {\n            return emptyMoves;\n        }\n\n        var argc = arguments.length;\n        if (argc === 2) {\n            start = 0;\n            end = length;\n        } else if (argc === 3) {\n            start = Math.max(start, 0);\n            end = length;\n        } else {\n            start = Math.max(start, 0);\n            end = Math.min(end, length);\n        }\n\n        isNumber.assert(start);\n        isNumber.assert(end);\n\n        var moves = Object.create(null);\n        var cache = getChildCache(path);\n\n        for (var i = start; i < end; ++i) {\n            if (hasOwn.call(path.value, i)) {\n                var childPath = path.get(i);\n                if (childPath.name !== i) {\n                    throw new Error(\"\");\n                }\n                var newIndex = i + offset;\n                childPath.name = newIndex;\n                moves[newIndex] = childPath;\n                delete cache[i];\n            }\n        }\n\n        delete cache.length;\n\n        return function () {\n            for (var newIndex in moves) {\n                var childPath = moves[newIndex];\n                if (childPath.name !== +newIndex) {\n                    throw new Error(\"\");\n                }\n                cache[newIndex] = childPath;\n                path.value[newIndex] = childPath.value;\n            }\n        };\n    }\n\n    Pp.shift = function shift() {\n        var move = getMoves(this, -1);\n        var result = this.value.shift();\n        move();\n        return result;\n    };\n\n    Pp.unshift = function unshift(node) {\n        var move = getMoves(this, arguments.length);\n        var result = this.value.unshift.apply(this.value, arguments);\n        move();\n        return result;\n    };\n\n    Pp.push = function push(node) {\n        isArray.assert(this.value);\n        delete getChildCache(this).length\n        return this.value.push.apply(this.value, arguments);\n    };\n\n    Pp.pop = function pop() {\n        isArray.assert(this.value);\n        var cache = getChildCache(this);\n        delete cache[this.value.length - 1];\n        delete cache.length;\n        return this.value.pop();\n    };\n\n    Pp.insertAt = function insertAt(index, node) {\n        var argc = arguments.length;\n        var move = getMoves(this, argc - 1, index);\n        if (move === emptyMoves) {\n            return this;\n        }\n\n        index = Math.max(index, 0);\n\n        for (var i = 1; i < argc; ++i) {\n            this.value[index + i - 1] = arguments[i];\n        }\n\n        move();\n\n        return this;\n    };\n\n    Pp.insertBefore = function insertBefore(node) {\n        var pp = this.parentPath;\n        var argc = arguments.length;\n        var insertAtArgs = [this.name];\n        for (var i = 0; i < argc; ++i) {\n            insertAtArgs.push(arguments[i]);\n        }\n        return pp.insertAt.apply(pp, insertAtArgs);\n    };\n\n    Pp.insertAfter = function insertAfter(node) {\n        var pp = this.parentPath;\n        var argc = arguments.length;\n        var insertAtArgs = [this.name + 1];\n        for (var i = 0; i < argc; ++i) {\n            insertAtArgs.push(arguments[i]);\n        }\n        return pp.insertAt.apply(pp, insertAtArgs);\n    };\n\n    function repairRelationshipWithParent(path) {\n        if (!(path instanceof Path)) {\n            throw new Error(\"\");\n        }\n\n        var pp = path.parentPath;\n        if (!pp) {\n            // Orphan paths have no relationship to repair.\n            return path;\n        }\n\n        var parentValue = pp.value;\n        var parentCache = getChildCache(pp);\n\n        // Make sure parentCache[path.name] is populated.\n        if (parentValue[path.name] === path.value) {\n            parentCache[path.name] = path;\n        } else if (isArray.check(parentValue)) {\n            // Something caused path.name to become out of date, so attempt to\n            // recover by searching for path.value in parentValue.\n            var i = parentValue.indexOf(path.value);\n            if (i >= 0) {\n                parentCache[path.name = i] = path;\n            }\n        } else {\n            // If path.value disagrees with parentValue[path.name], and\n            // path.name is not an array index, let path.value become the new\n            // parentValue[path.name] and update parentCache accordingly.\n            parentValue[path.name] = path.value;\n            parentCache[path.name] = path;\n        }\n\n        if (parentValue[path.name] !== path.value) {\n            throw new Error(\"\");\n        }\n        if (path.parentPath.get(path.name) !== path) {\n            throw new Error(\"\");\n        }\n\n        return path;\n    }\n\n    Pp.replace = function replace(replacement) {\n        var results = [];\n        var parentValue = this.parentPath.value;\n        var parentCache = getChildCache(this.parentPath);\n        var count = arguments.length;\n\n        repairRelationshipWithParent(this);\n\n        if (isArray.check(parentValue)) {\n            var originalLength = parentValue.length;\n            var move = getMoves(this.parentPath, count - 1, this.name + 1);\n\n            var spliceArgs = [this.name, 1];\n            for (var i = 0; i < count; ++i) {\n                spliceArgs.push(arguments[i]);\n            }\n\n            var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);\n\n            if (splicedOut[0] !== this.value) {\n                throw new Error(\"\");\n            }\n            if (parentValue.length !== (originalLength - 1 + count)) {\n                throw new Error(\"\");\n            }\n\n            move();\n\n            if (count === 0) {\n                delete this.value;\n                delete parentCache[this.name];\n                this.__childCache = null;\n\n            } else {\n                if (parentValue[this.name] !== replacement) {\n                    throw new Error(\"\");\n                }\n\n                if (this.value !== replacement) {\n                    this.value = replacement;\n                    this.__childCache = null;\n                }\n\n                for (i = 0; i < count; ++i) {\n                    results.push(this.parentPath.get(this.name + i));\n                }\n\n                if (results[0] !== this) {\n                    throw new Error(\"\");\n                }\n            }\n\n        } else if (count === 1) {\n            if (this.value !== replacement) {\n                this.__childCache = null;\n            }\n            this.value = parentValue[this.name] = replacement;\n            results.push(this);\n\n        } else if (count === 0) {\n            delete parentValue[this.name];\n            delete this.value;\n            this.__childCache = null;\n\n            // Leave this path cached as parentCache[this.name], even though\n            // it no longer has a value defined.\n\n        } else {\n            throw new Error(\"Could not replace path\");\n        }\n\n        return results;\n    };\n\n    return Path;\n};\n"]}