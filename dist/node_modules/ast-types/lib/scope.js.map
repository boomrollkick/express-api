{"version":3,"sources":["../../../../src/node_modules/ast-types/lib/scope.js"],"names":["hasOwn","Object","prototype","hasOwnProperty","module","exports","fork","types","use","require","Type","namedTypes","Node","Expression","isArray","builtInTypes","array","b","builders","Scope","path","parentScope","Error","ScopeType","assert","value","depth","defineProperties","node","isGlobal","enumerable","parent","bindings","scopeTypes","Program","Function","CatchClause","or","apply","isEstablishedBy","check","Sp","didScan","declares","name","scan","call","declaresType","declareTemporary","prefix","test","toString","index","identifier","injectTemporary","init","bodyPath","get","BlockStatement","unshift","variableDeclaration","variableDeclarator","force","scanScope","getBindings","getTypes","addPattern","recursiveScanScope","FunctionExpression","id","each","childPath","recursiveScanChild","paramPath","TypeAlias","addTypePattern","VariableDeclarator","type","local","eachField","child","pathHasValue","Array","length","FunctionDeclaration","ClassDeclaration","catchParamName","param","hadBinding","patternPath","pattern","Pattern","Identifier","push","AssignmentPattern","ObjectPattern","propertyPath","property","Property","SpreadProperty","ArrayPattern","elementPath","element","SpreadElement","PropertyPattern","SpreadElementPattern","SpreadPropertyPattern","lookup","scope","lookupType","getGlobalScope"],"mappings":"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","file":"scope.js","sourcesContent":["var hasOwn = Object.prototype.hasOwnProperty;\n\nmodule.exports = function (fork) {\n    var types = fork.use(require(\"./types\"));\n    var Type = types.Type;\n    var namedTypes = types.namedTypes;\n    var Node = namedTypes.Node;\n    var Expression = namedTypes.Expression;\n    var isArray = types.builtInTypes.array;\n    var b = types.builders;\n\n    function Scope(path, parentScope) {\n        if (!(this instanceof Scope)) {\n            throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n        }\n        if (!(path instanceof fork.use(require(\"./node-path\")))) {\n            throw new Error(\"\");\n        }\n        ScopeType.assert(path.value);\n\n        var depth;\n\n        if (parentScope) {\n            if (!(parentScope instanceof Scope)) {\n                throw new Error(\"\");\n            }\n            depth = parentScope.depth + 1;\n        } else {\n            parentScope = null;\n            depth = 0;\n        }\n\n        Object.defineProperties(this, {\n            path: { value: path },\n            node: { value: path.value },\n            isGlobal: { value: !parentScope, enumerable: true },\n            depth: { value: depth },\n            parent: { value: parentScope },\n            bindings: { value: {} },\n            types: { value: {} },\n        });\n    }\n\n    var scopeTypes = [\n        // Program nodes introduce global scopes.\n        namedTypes.Program,\n\n        // Function is the supertype of FunctionExpression,\n        // FunctionDeclaration, ArrowExpression, etc.\n        namedTypes.Function,\n\n        // In case you didn't know, the caught parameter shadows any variable\n        // of the same name in an outer scope.\n        namedTypes.CatchClause\n    ];\n\n    var ScopeType = Type.or.apply(Type, scopeTypes);\n\n    Scope.isEstablishedBy = function(node) {\n        return ScopeType.check(node);\n    };\n\n    var Sp = Scope.prototype;\n\n// Will be overridden after an instance lazily calls scanScope.\n    Sp.didScan = false;\n\n    Sp.declares = function(name) {\n        this.scan();\n        return hasOwn.call(this.bindings, name);\n    };\n\n    Sp.declaresType = function(name) {\n        this.scan();\n        return hasOwn.call(this.types, name);\n    };\n\n    Sp.declareTemporary = function(prefix) {\n        if (prefix) {\n            if (!/^[a-z$_]/i.test(prefix)) {\n                throw new Error(\"\");\n            }\n        } else {\n            prefix = \"t$\";\n        }\n\n        // Include this.depth in the name to make sure the name does not\n        // collide with any variables in nested/enclosing scopes.\n        prefix += this.depth.toString(36) + \"$\";\n\n        this.scan();\n\n        var index = 0;\n        while (this.declares(prefix + index)) {\n            ++index;\n        }\n\n        var name = prefix + index;\n        return this.bindings[name] = types.builders.identifier(name);\n    };\n\n    Sp.injectTemporary = function(identifier, init) {\n        identifier || (identifier = this.declareTemporary());\n\n        var bodyPath = this.path.get(\"body\");\n        if (namedTypes.BlockStatement.check(bodyPath.value)) {\n            bodyPath = bodyPath.get(\"body\");\n        }\n\n        bodyPath.unshift(\n          b.variableDeclaration(\n            \"var\",\n            [b.variableDeclarator(identifier, init || null)]\n          )\n        );\n\n        return identifier;\n    };\n\n    Sp.scan = function(force) {\n        if (force || !this.didScan) {\n            for (var name in this.bindings) {\n                // Empty out this.bindings, just in cases.\n                delete this.bindings[name];\n            }\n            scanScope(this.path, this.bindings, this.types);\n            this.didScan = true;\n        }\n    };\n\n    Sp.getBindings = function () {\n        this.scan();\n        return this.bindings;\n    };\n\n    Sp.getTypes = function () {\n        this.scan();\n        return this.types;\n    };\n\n    function scanScope(path, bindings, scopeTypes) {\n        var node = path.value;\n        ScopeType.assert(node);\n\n        if (namedTypes.CatchClause.check(node)) {\n            // A catch clause establishes a new scope but the only variable\n            // bound in that scope is the catch parameter. Any other\n            // declarations create bindings in the outer scope.\n            addPattern(path.get(\"param\"), bindings);\n\n        } else {\n            recursiveScanScope(path, bindings, scopeTypes);\n        }\n    }\n\n    function recursiveScanScope(path, bindings, scopeTypes) {\n        var node = path.value;\n\n        if (path.parent &&\n          namedTypes.FunctionExpression.check(path.parent.node) &&\n          path.parent.node.id) {\n            addPattern(path.parent.get(\"id\"), bindings);\n        }\n\n        if (!node) {\n            // None of the remaining cases matter if node is falsy.\n\n        } else if (isArray.check(node)) {\n            path.each(function(childPath) {\n                recursiveScanChild(childPath, bindings, scopeTypes);\n            });\n\n        } else if (namedTypes.Function.check(node)) {\n            path.get(\"params\").each(function(paramPath) {\n                addPattern(paramPath, bindings);\n            });\n\n            recursiveScanChild(path.get(\"body\"), bindings, scopeTypes);\n\n        } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node)) {\n            addTypePattern(path.get(\"id\"), scopeTypes);\n\n        } else if (namedTypes.VariableDeclarator.check(node)) {\n            addPattern(path.get(\"id\"), bindings);\n            recursiveScanChild(path.get(\"init\"), bindings, scopeTypes);\n\n        } else if (node.type === \"ImportSpecifier\" ||\n          node.type === \"ImportNamespaceSpecifier\" ||\n          node.type === \"ImportDefaultSpecifier\") {\n            addPattern(\n              // Esprima used to use the .name field to refer to the local\n              // binding identifier for ImportSpecifier nodes, but .id for\n              // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.\n              // ESTree/Acorn/ESpree use .local for all three node types.\n              path.get(node.local ? \"local\" :\n                node.name ? \"name\" : \"id\"),\n              bindings\n            );\n\n        } else if (Node.check(node) && !Expression.check(node)) {\n            types.eachField(node, function(name, child) {\n                var childPath = path.get(name);\n                if (!pathHasValue(childPath, child)) {\n                    throw new Error(\"\");\n                }\n                recursiveScanChild(childPath, bindings, scopeTypes);\n            });\n        }\n    }\n\n    function pathHasValue(path, value) {\n        if (path.value === value) {\n            return true;\n        }\n\n        // Empty arrays are probably produced by defaults.emptyArray, in which\n        // case is makes sense to regard them as equivalent, if not ===.\n        if (Array.isArray(path.value) &&\n          path.value.length === 0 &&\n          Array.isArray(value) &&\n          value.length === 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function recursiveScanChild(path, bindings, scopeTypes) {\n        var node = path.value;\n\n        if (!node || Expression.check(node)) {\n            // Ignore falsy values and Expressions.\n\n        } else if (namedTypes.FunctionDeclaration.check(node) &&\n                   node.id !== null) {\n            addPattern(path.get(\"id\"), bindings);\n\n        } else if (namedTypes.ClassDeclaration &&\n          namedTypes.ClassDeclaration.check(node)) {\n            addPattern(path.get(\"id\"), bindings);\n\n        } else if (ScopeType.check(node)) {\n            if (namedTypes.CatchClause.check(node)) {\n                var catchParamName = node.param.name;\n                var hadBinding = hasOwn.call(bindings, catchParamName);\n\n                // Any declarations that occur inside the catch body that do\n                // not have the same name as the catch parameter should count\n                // as bindings in the outer scope.\n                recursiveScanScope(path.get(\"body\"), bindings, scopeTypes);\n\n                // If a new binding matching the catch parameter name was\n                // created while scanning the catch body, ignore it because it\n                // actually refers to the catch parameter and not the outer\n                // scope that we're currently scanning.\n                if (!hadBinding) {\n                    delete bindings[catchParamName];\n                }\n            }\n\n        } else {\n            recursiveScanScope(path, bindings, scopeTypes);\n        }\n    }\n\n    function addPattern(patternPath, bindings) {\n        var pattern = patternPath.value;\n        namedTypes.Pattern.assert(pattern);\n\n        if (namedTypes.Identifier.check(pattern)) {\n            if (hasOwn.call(bindings, pattern.name)) {\n                bindings[pattern.name].push(patternPath);\n            } else {\n                bindings[pattern.name] = [patternPath];\n            }\n\n        } else if (namedTypes.AssignmentPattern &&\n          namedTypes.AssignmentPattern.check(pattern)) {\n          addPattern(patternPath.get('left'), bindings);\n\n        } else if (namedTypes.ObjectPattern &&\n          namedTypes.ObjectPattern.check(pattern)) {\n            patternPath.get('properties').each(function(propertyPath) {\n                var property = propertyPath.value;\n                if (namedTypes.Pattern.check(property)) {\n                    addPattern(propertyPath, bindings);\n                } else  if (namedTypes.Property.check(property)) {\n                    addPattern(propertyPath.get('value'), bindings);\n                } else if (namedTypes.SpreadProperty &&\n                  namedTypes.SpreadProperty.check(property)) {\n                    addPattern(propertyPath.get('argument'), bindings);\n                }\n            });\n\n        } else if (namedTypes.ArrayPattern &&\n          namedTypes.ArrayPattern.check(pattern)) {\n            patternPath.get('elements').each(function(elementPath) {\n                var element = elementPath.value;\n                if (namedTypes.Pattern.check(element)) {\n                    addPattern(elementPath, bindings);\n                } else if (namedTypes.SpreadElement &&\n                  namedTypes.SpreadElement.check(element)) {\n                    addPattern(elementPath.get(\"argument\"), bindings);\n                }\n            });\n\n        } else if (namedTypes.PropertyPattern &&\n          namedTypes.PropertyPattern.check(pattern)) {\n            addPattern(patternPath.get('pattern'), bindings);\n\n        } else if ((namedTypes.SpreadElementPattern &&\n          namedTypes.SpreadElementPattern.check(pattern)) ||\n          (namedTypes.SpreadPropertyPattern &&\n          namedTypes.SpreadPropertyPattern.check(pattern))) {\n            addPattern(patternPath.get('argument'), bindings);\n        }\n    }\n\n    function addTypePattern(patternPath, types) {\n        var pattern = patternPath.value;\n        namedTypes.Pattern.assert(pattern);\n\n        if (namedTypes.Identifier.check(pattern)) {\n            if (hasOwn.call(types, pattern.name)) {\n                types[pattern.name].push(patternPath);\n            } else {\n                types[pattern.name] = [patternPath];\n            }\n\n        }\n    }\n\n    Sp.lookup = function(name) {\n        for (var scope = this; scope; scope = scope.parent)\n            if (scope.declares(name))\n                break;\n        return scope;\n    };\n\n    Sp.lookupType = function(name) {\n        for (var scope = this; scope; scope = scope.parent)\n            if (scope.declaresType(name))\n                break;\n        return scope;\n    };\n\n    Sp.getGlobalScope = function() {\n        var scope = this;\n        while (!scope.isGlobal)\n            scope = scope.parent;\n        return scope;\n    };\n\n    return Scope;\n};\n"]}