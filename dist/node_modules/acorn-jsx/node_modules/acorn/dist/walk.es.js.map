{"version":3,"sources":["../../../../../../src/node_modules/acorn-jsx/node_modules/acorn/dist/walk.es.js"],"names":["simple","node","visitors","base","state","override","exports","c","st","type","found","ancestor","ancestors","isNew","length","push","pop","recursive","funcs","visitor","make","makeTest","test","Found","findNodeAt","start","end","e","findNodeAround","pos","findNodeAfter","findNodeBefore","max","create","Object","proto","Ctor","prototype","skipThrough","ignore","_node","_st","_c","Program","BlockStatement","i","body","Statement","EmptyStatement","ExpressionStatement","ParenthesizedExpression","expression","IfStatement","consequent","alternate","LabeledStatement","BreakStatement","ContinueStatement","WithStatement","object","SwitchStatement","discriminant","cases","cs","j","ReturnStatement","YieldExpression","argument","ThrowStatement","SpreadElement","TryStatement","block","handler","finalizer","CatchClause","param","WhileStatement","DoWhileStatement","ForStatement","init","update","ForInStatement","ForOfStatement","left","right","ForInit","DebuggerStatement","FunctionDeclaration","VariableDeclaration","declarations","VariableDeclarator","id","Function","params","ScopeBody","ScopeExpression","Pattern","VariablePattern","MemberPattern","RestElement","ArrayPattern","elements","elt","ObjectPattern","properties","value","Expression","ThisExpression","Super","MetaProperty","ArrayExpression","ObjectExpression","FunctionExpression","ArrowFunctionExpression","SequenceExpression","TemplateLiteral","expressions","UnaryExpression","UpdateExpression","BinaryExpression","LogicalExpression","AssignmentExpression","AssignmentPattern","ConditionalExpression","NewExpression","CallExpression","callee","arguments","MemberExpression","computed","property","ExportNamedDeclaration","ExportDefaultDeclaration","declaration","source","ExportAllDeclaration","ImportDeclaration","specifiers","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","Identifier","Literal","TaggedTemplateExpression","tag","quasi","ClassDeclaration","ClassExpression","Class","superClass","MethodDefinition","Property","key"],"mappings":"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","file":"walk.es.js","sourcesContent":["// AST walker module for Mozilla Parser API compatible trees\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression,\n// Statement, and ScopeBody, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n\nfunction simple(node, visitors, base, state, override) {\n  if (!base) base = exports.base\n  ;(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type]\n    base[type](node, st, c)\n    if (found) found(node, st)\n  })(node, state, override)\n}\n\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\nfunction ancestor(node, visitors, base, state) {\n  if (!base) base = exports.base\n  var ancestors = []\n  ;(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type]\n    var isNew = node != ancestors[ancestors.length - 1]\n    if (isNew) ancestors.push(node)\n    base[type](node, st, c)\n    if (found) found(node, st || ancestors, ancestors)\n    if (isNew) ancestors.pop()\n  })(node, state)\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nfunction recursive(node, state, funcs, base, override) {\n  var visitor = funcs ? exports.make(funcs, base) : base\n  ;(function c(node, st, override) {\n    visitor[override || node.type](node, st, c)\n  })(node, state, override)\n}\n\nfunction makeTest(test) {\n  if (typeof test == \"string\")\n    return function (type) { return type == test; }\n  else if (!test)\n    return function () { return true; }\n  else\n    return test\n}\n\nvar Found = function Found(node, state) { this.node = node; this.state = state };\n\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nfunction findNodeAt(node, start, end, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  try {\n    ;(function c(node, st, override) {\n      var type = override || node.type\n      if ((start == null || node.start <= start) &&\n          (end == null || node.end >= end))\n        base[type](node, st, c)\n      if ((start == null || node.start == start) &&\n          (end == null || node.end == end) &&\n          test(type, node))\n        throw new Found(node, st)\n    })(node, state)\n  } catch (e) {\n    if (e instanceof Found) return e\n    throw e\n  }\n}\n\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nfunction findNodeAround(node, pos, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  try {\n    ;(function c(node, st, override) {\n      var type = override || node.type\n      if (node.start > pos || node.end < pos) return\n      base[type](node, st, c)\n      if (test(type, node)) throw new Found(node, st)\n    })(node, state)\n  } catch (e) {\n    if (e instanceof Found) return e\n    throw e\n  }\n}\n\n// Find the outermost matching node after a given position.\nfunction findNodeAfter(node, pos, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  try {\n    ;(function c(node, st, override) {\n      if (node.end < pos) return\n      var type = override || node.type\n      if (node.start >= pos && test(type, node)) throw new Found(node, st)\n      base[type](node, st, c)\n    })(node, state)\n  } catch (e) {\n    if (e instanceof Found) return e\n    throw e\n  }\n}\n\n// Find the outermost matching node before a given position.\nfunction findNodeBefore(node, pos, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  var max\n  ;(function c(node, st, override) {\n    if (node.start > pos) return\n    var type = override || node.type\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n      max = new Found(node, st)\n    base[type](node, st, c)\n  })(node, state)\n  return max\n}\n\n// Fallback to an Object.create polyfill for older environments.\nvar create = Object.create || function(proto) {\n  function Ctor() {}\n  Ctor.prototype = proto\n  return new Ctor\n}\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nfunction make(funcs, base) {\n  if (!base) base = exports.base\n  var visitor = create(base)\n  for (var type in funcs) visitor[type] = funcs[type]\n  return visitor\n}\n\nfunction skipThrough(node, st, c) { c(node, st) }\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nvar base = {}\n\nbase.Program = base.BlockStatement = function (node, st, c) {\n  for (var i = 0; i < node.body.length; ++i)\n    c(node.body[i], st, \"Statement\")\n}\nbase.Statement = skipThrough\nbase.EmptyStatement = ignore\nbase.ExpressionStatement = base.ParenthesizedExpression =\n  function (node, st, c) { return c(node.expression, st, \"Expression\"); }\nbase.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\")\n  c(node.consequent, st, \"Statement\")\n  if (node.alternate) c(node.alternate, st, \"Statement\")\n}\nbase.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); }\nbase.BreakStatement = base.ContinueStatement = ignore\nbase.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\")\n  for (var i = 0; i < node.cases.length; ++i) {\n    var cs = node.cases[i]\n    if (cs.test) c(cs.test, st, \"Expression\")\n    for (var j = 0; j < cs.consequent.length; ++j)\n      c(cs.consequent[j], st, \"Statement\")\n  }\n}\nbase.ReturnStatement = base.YieldExpression = function (node, st, c) {\n  if (node.argument) c(node.argument, st, \"Expression\")\n}\nbase.ThrowStatement = base.SpreadElement =\n  function (node, st, c) { return c(node.argument, st, \"Expression\"); }\nbase.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\")\n  if (node.handler) c(node.handler, st)\n  if (node.finalizer) c(node.finalizer, st, \"Statement\")\n}\nbase.CatchClause = function (node, st, c) {\n  c(node.param, st, \"Pattern\")\n  c(node.body, st, \"ScopeBody\")\n}\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.ForStatement = function (node, st, c) {\n  if (node.init) c(node.init, st, \"ForInit\")\n  if (node.test) c(node.test, st, \"Expression\")\n  if (node.update) c(node.update, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\")\n  c(node.right, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.ForInit = function (node, st, c) {\n  if (node.type == \"VariableDeclaration\") c(node, st)\n  else c(node, st, \"Expression\")\n}\nbase.DebuggerStatement = ignore\n\nbase.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); }\nbase.VariableDeclaration = function (node, st, c) {\n  for (var i = 0; i < node.declarations.length; ++i)\n    c(node.declarations[i], st)\n}\nbase.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\")\n  if (node.init) c(node.init, st, \"Expression\")\n}\n\nbase.Function = function (node, st, c) {\n  if (node.id) c(node.id, st, \"Pattern\")\n  for (var i = 0; i < node.params.length; i++)\n    c(node.params[i], st, \"Pattern\")\n  c(node.body, st, node.expression ? \"ScopeExpression\" : \"ScopeBody\")\n}\n// FIXME drop these node types in next major version\n// (They are awkward, and in ES6 every block can be a scope.)\nbase.ScopeBody = function (node, st, c) { return c(node, st, \"Statement\"); }\nbase.ScopeExpression = function (node, st, c) { return c(node, st, \"Expression\"); }\n\nbase.Pattern = function (node, st, c) {\n  if (node.type == \"Identifier\")\n    c(node, st, \"VariablePattern\")\n  else if (node.type == \"MemberExpression\")\n    c(node, st, \"MemberPattern\")\n  else\n    c(node, st)\n}\nbase.VariablePattern = ignore\nbase.MemberPattern = skipThrough\nbase.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); }\nbase.ArrayPattern =  function (node, st, c) {\n  for (var i = 0; i < node.elements.length; ++i) {\n    var elt = node.elements[i]\n    if (elt) c(elt, st, \"Pattern\")\n  }\n}\nbase.ObjectPattern = function (node, st, c) {\n  for (var i = 0; i < node.properties.length; ++i)\n    c(node.properties[i].value, st, \"Pattern\")\n}\n\nbase.Expression = skipThrough\nbase.ThisExpression = base.Super = base.MetaProperty = ignore\nbase.ArrayExpression = function (node, st, c) {\n  for (var i = 0; i < node.elements.length; ++i) {\n    var elt = node.elements[i]\n    if (elt) c(elt, st, \"Expression\")\n  }\n}\nbase.ObjectExpression = function (node, st, c) {\n  for (var i = 0; i < node.properties.length; ++i)\n    c(node.properties[i], st)\n}\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration\nbase.SequenceExpression = base.TemplateLiteral = function (node, st, c) {\n  for (var i = 0; i < node.expressions.length; ++i)\n    c(node.expressions[i], st, \"Expression\")\n}\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\")\n}\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\")\n  c(node.right, st, \"Expression\")\n}\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\")\n  c(node.right, st, \"Expression\")\n}\nbase.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\")\n  c(node.consequent, st, \"Expression\")\n  c(node.alternate, st, \"Expression\")\n}\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\")\n  if (node.arguments) for (var i = 0; i < node.arguments.length; ++i)\n    c(node.arguments[i], st, \"Expression\")\n}\nbase.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\")\n  if (node.computed) c(node.property, st, \"Expression\")\n}\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration)\n    c(node.declaration, st, node.type == \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\")\n  if (node.source) c(node.source, st, \"Expression\")\n}\nbase.ExportAllDeclaration = function (node, st, c) {\n  c(node.source, st, \"Expression\")\n}\nbase.ImportDeclaration = function (node, st, c) {\n  for (var i = 0; i < node.specifiers.length; i++)\n    c(node.specifiers[i], st)\n  c(node.source, st, \"Expression\")\n}\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore\n\nbase.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\")\n  c(node.quasi, st)\n}\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); }\nbase.Class = function (node, st, c) {\n  if (node.id) c(node.id, st, \"Pattern\")\n  if (node.superClass) c(node.superClass, st, \"Expression\")\n  for (var i = 0; i < node.body.body.length; i++)\n    c(node.body.body[i], st)\n}\nbase.MethodDefinition = base.Property = function (node, st, c) {\n  if (node.computed) c(node.key, st, \"Expression\")\n  c(node.value, st, \"Expression\")\n}\n\nexport { simple, ancestor, recursive, findNodeAt, findNodeAround, findNodeAfter, findNodeBefore, make, base };"]}