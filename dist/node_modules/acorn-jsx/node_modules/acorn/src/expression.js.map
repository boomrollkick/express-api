{"version":3,"sources":["../../../../../../src/node_modules/acorn-jsx/node_modules/acorn/src/expression.js"],"names":["pp","Parser","prototype","checkPropClash","prop","propHash","options","ecmaVersion","computed","method","shorthand","key","name","type","String","value","kind","proto","raiseRecoverable","start","other","isGetSet","strict","init","get","set","parseExpression","noIn","refDestructuringErrors","startPos","startLoc","expr","parseMaybeAssign","tt","comma","node","startNodeAt","expressions","eat","push","finishNode","afterLeftParse","inGenerator","isContextual","parseYield","ownDestructuringErrors","DestructuringErrors","parenL","potentialArrowAt","left","parseMaybeConditional","call","isAssign","checkPatternErrors","operator","eq","toAssignable","shorthandAssign","checkLVal","next","right","checkExpressionErrors","parseExprOps","question","test","consequent","expect","colon","alternate","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","prec","binop","_in","logical","logicalOR","logicalAND","op","buildBinary","sawUnary","prefix","startNode","update","incDec","argument","parseExprSubscripts","postfix","canInsertSemicolon","starstar","parseExprAtom","skipArrowSubscripts","input","slice","lastTokStart","lastTokEnd","parseSubscripts","base","noCalls","dot","object","property","parseIdent","bracketL","bracketR","callee","arguments","parseExprList","parenR","backQuote","tag","quasi","parseTemplate","canBeArrow","_super","inFunction","raise","_this","id","arrow","parseArrowExpression","regexp","parseLiteral","regex","pattern","flags","num","string","_null","_true","_false","raw","keyword","parseParenAndDistinguishExpression","elements","braceL","parseObj","_function","parseFunction","_class","parseClass","_new","parseNew","unexpected","end","parseParenExpression","val","innerStartPos","innerStartLoc","exprList","first","spreadStart","innerParenStart","ellipsis","parseParenItem","parseRest","innerEndPos","innerEndLoc","parseParenArrowList","length","finishNodeAt","preserveParens","par","expression","item","empty","meta","parseTemplateElement","elem","replace","cooked","tail","curElt","quasis","dollarBraceL","braceR","isPattern","properties","afterTrailingComma","isGenerator","star","parsePropertyName","parsePropertyValue","parseMaybeDefault","parseMethod","paramCount","params","keywords","reservedWordsStrictBind","reservedWords","initFunction","generator","oldInGen","parseBindingList","parseFunctionBody","toAssignableList","isArrowFunction","isExpression","body","oldInFunc","oldLabels","labels","parseBlock","useStrict","isUseStrict","oldStrict","checkParams","nameHash","i","close","allowTrailingComma","allowEmpty","elts","elt","parseSpread","trailingComma","liberal","allowReserved","reservedWordsStrict","indexOf","semi","startsExpr","delegate"],"mappings":"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","file":"expression.js","sourcesContent":["// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {DestructuringErrors} from \"./parseutil\"\n\nconst pp = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    return\n  let {key} = prop, name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  let {kind} = prop\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\")\n      propHash.proto = true\n    }\n    return\n  }\n  name = \"$\" + name\n  let other = propHash[name]\n  if (other) {\n    let isGetSet = kind !== \"init\"\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))\n      this.raiseRecoverable(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp.parseExpression = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeAssign(noIn, refDestructuringErrors)\n  if (this.type === tt.comma) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield()\n\n  let ownDestructuringErrors = false\n  if (!refDestructuringErrors) {\n    refDestructuringErrors = new DestructuringErrors\n    ownDestructuringErrors = true\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  let left = this.parseMaybeConditional(noIn, refDestructuringErrors)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true)\n    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)\n    let node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refDestructuringErrors.shorthandAssign = 0 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprOps(noIn, refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  if (this.eat(tt.question)) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp.parseExprOps = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeUnary(refDestructuringErrors, false)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  return this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  let prec = this.type.binop\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      let logical = this.type === tt.logicalOR || this.type === tt.logicalAND\n      let op = this.value\n      this.next()\n      let startPos = this.start, startLoc = this.startLoc\n      let right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)\n      let node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\npp.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  let node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.operator = op\n  node.right = right\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  let startPos = this.start, startLoc = this.startLoc, expr\n  if (this.type.prefix) {\n    let node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary(null, true)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\")\n    else sawUnary = true\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors)\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.operator = this.value\n      node.prefix = false\n      node.argument = expr\n      this.checkLVal(expr)\n      this.next()\n      expr = this.finishNode(node, \"UpdateExpression\")\n    }\n  }\n\n  if (!sawUnary && this.eat(tt.starstar))\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false)\n  else\n    return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp.parseExprSubscripts = function(refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprAtom(refDestructuringErrors)\n  let skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\"\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr\n  return this.parseSubscripts(expr, startPos, startLoc)\n}\n\npp.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  for (;;) {\n    if (this.eat(tt.dot)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = this.parseIdent(true)\n      node.computed = false\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (this.eat(tt.bracketL)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = this.parseExpression()\n      node.computed = true\n      this.expect(tt.bracketR)\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this.eat(tt.parenL)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.callee = base\n      node.arguments = this.parseExprList(tt.parenR, false)\n      base = this.finishNode(node, \"CallExpression\")\n    } else if (this.type === tt.backQuote) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.tag = base\n      node.quasi = this.parseTemplate()\n      base = this.finishNode(node, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp.parseExprAtom = function(refDestructuringErrors) {\n  let node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._super:\n    if (!this.inFunction)\n      this.raise(this.start, \"'super' outside of function or class\")\n\n  case tt._this:\n    let type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt.name:\n    let startPos = this.start, startLoc = this.startLoc\n    let id = this.parseIdent(this.type !== tt.name)\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow))\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id])\n    return id\n\n  case tt.regexp:\n    let value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    return this.parseParenAndDistinguishExpression(canBeArrow)\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseLiteral = function(value) {\n  let node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  let val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp.parseParenAndDistinguishExpression = function(canBeArrow) {\n  let startPos = this.start, startLoc = this.startLoc, val\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    let innerStartPos = this.start, innerStartLoc = this.startLoc\n    let exprList = [], first = true\n    let refDestructuringErrors = new DestructuringErrors, spreadStart, innerParenStart\n    while (this.type !== tt.parenR) {\n      first ? first = false : this.expect(tt.comma)\n      if (this.type === tt.ellipsis) {\n        spreadStart = this.start\n        exprList.push(this.parseParenItem(this.parseRest()))\n        break\n      } else {\n        if (this.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this.start\n        }\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem))\n      }\n    }\n    let innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, true)\n      if (innerParenStart) this.unexpected(innerParenStart)\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    let par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp.parseParenItem = function(item) {\n  return item\n}\n\npp.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nconst empty = []\n\npp.parseNew = function() {\n  let node = this.startNode()\n  let meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\")\n    if (!this.inFunction)\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false)\n  else node.arguments = empty\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp.parseTemplateElement = function() {\n  let elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp.parseTemplate = function() {\n  let node = this.startNode()\n  this.next()\n  node.expressions = []\n  let curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this.expect(tt.dollarBraceL)\n    node.expressions.push(this.parseExpression())\n    this.expect(tt.braceR)\n    node.quasis.push(curElt = this.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp.parseObj = function(isPattern, refDestructuringErrors) {\n  let node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let prop = this.startNode(), isGenerator, startPos, startLoc\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start\n        startLoc = this.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this.eat(tt.star)\n    }\n    this.parsePropertyName(prop)\n    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors)\n    this.checkPropClash(prop, propHash)\n    node.properties.push(this.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp.parsePropertyValue = function(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {\n  if (this.eat(tt.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)\n    prop.kind = \"init\"\n  } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n    if (isPattern) this.unexpected()\n    prop.kind = \"init\"\n    prop.method = true\n    prop.value = this.parseMethod(isGenerator)\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != tt.comma && this.type != tt.braceR)) {\n    if (isGenerator || isPattern) this.unexpected()\n    prop.kind = prop.key.name\n    this.parsePropertyName(prop)\n    prop.value = this.parseMethod(false)\n    let paramCount = prop.kind === \"get\" ? 0 : 1\n    if (prop.value.params.length !== paramCount) {\n      let start = prop.value.start\n      if (prop.kind === \"get\")\n        this.raiseRecoverable(start, \"getter should have no params\")\n      else\n        this.raiseRecoverable(start, \"setter should have exactly one param\")\n    }\n    if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n      this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\")\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (this.keywords.test(prop.key.name) ||\n        (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) ||\n        (this.inGenerator && prop.key.name == \"yield\"))\n      this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\")\n    prop.kind = \"init\"\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else if (this.type === tt.eq && refDestructuringErrors) {\n      if (!refDestructuringErrors.shorthandAssign)\n        refDestructuringErrors.shorthandAssign = this.start\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else {\n      prop.value = prop.key\n    }\n    prop.shorthand = true\n  } else this.unexpected()\n}\n\npp.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n}\n\n// Parse object or class method.\n\npp.parseMethod = function(isGenerator) {\n  let node = this.startNode(), oldInGen = this.inGenerator\n  this.inGenerator = isGenerator\n  this.initFunction(node)\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, false)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = isGenerator\n  this.parseFunctionBody(node, false)\n  this.inGenerator = oldInGen\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp.parseArrowExpression = function(node, params) {\n  let oldInGen = this.inGenerator\n  this.inGenerator = false\n  this.initFunction(node)\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n  this.inGenerator = oldInGen\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp.parseFunctionBody = function(node, isArrowFunction) {\n  let isExpression = isArrowFunction && this.type !== tt.braceL\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n  } else {\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    let oldInFunc = this.inFunction, oldLabels = this.labels\n    this.inFunction = true; this.labels = []\n    node.body = this.parseBlock(true)\n    node.expression = false\n    this.inFunction = oldInFunc; this.labels = oldLabels\n  }\n\n  // If this is a strict mode function, verify that argument names\n  // are not repeated, and it does not try to bind the words `eval`\n  // or `arguments`.\n  let useStrict = (!isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) ? node.body.body[0] : null;\n  if (this.strict || useStrict) {\n    let oldStrict = this.strict\n    this.strict = true\n    if (node.id)\n      this.checkLVal(node.id, true)\n    this.checkParams(node, useStrict)\n    this.strict = oldStrict\n  } else if (isArrowFunction) {\n    this.checkParams(node, useStrict)\n  }\n}\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp.checkParams = function(node, useStrict) {\n    let nameHash = {}\n    for (let i = 0; i < node.params.length; i++) {\n      if (useStrict && this.options.ecmaVersion >= 7 && node.params[i].type !== \"Identifier\")\n        this.raiseRecoverable(useStrict.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n      this.checkLVal(node.params[i], true, nameHash)\n    }\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (allowTrailingComma && this.afterTrailingComma(close)) break\n    } else first = false\n\n    let elt\n    if (allowEmpty && this.type === tt.comma)\n      elt = null\n    else if (this.type === tt.ellipsis) {\n      elt = this.parseSpread(refDestructuringErrors)\n      if (this.type === tt.comma && refDestructuringErrors && !refDestructuringErrors.trailingComma) {\n        refDestructuringErrors.trailingComma = this.lastTokStart\n      }\n    } else\n      elt = this.parseMaybeAssign(false, refDestructuringErrors)\n    elts.push(elt)\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp.parseIdent = function(liberal) {\n  let node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&\n        (this.options.ecmaVersion >= 6 ||\n         this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))\n      this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    if (!liberal && this.inGenerator && this.value === \"yield\")\n      this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp.parseYield = function() {\n  let node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n"]}