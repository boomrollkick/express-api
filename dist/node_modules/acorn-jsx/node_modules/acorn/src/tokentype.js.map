{"version":3,"sources":["../../../../../../src/node_modules/acorn-jsx/node_modules/acorn/src/tokentype.js"],"names":["TokenType","label","conf","keyword","beforeExpr","startsExpr","isLoop","isAssign","prefix","postfix","binop","updateContext","name","prec","keywords","kw","options","types","num","regexp","string","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","arrow","template","ellipsis","backQuote","dollarBraceL","eq","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete"],"mappings":"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","file":"tokentype.js","sourcesContent":["// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nexport class TokenType {\n  constructor(label, conf = {}) {\n    this.label = label\n    this.keyword = conf.keyword\n    this.beforeExpr = !!conf.beforeExpr\n    this.startsExpr = !!conf.startsExpr\n    this.isLoop = !!conf.isLoop\n    this.isAssign = !!conf.isAssign\n    this.prefix = !!conf.prefix\n    this.postfix = !!conf.postfix\n    this.binop = conf.binop || null\n    this.updateContext = null\n  }\n}\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nconst beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true}\n\n// Map keyword names to token types.\n\nexport const keywords = {}\n\n// Succinct definitions of keyword token types\nfunction kw(name, options = {}) {\n  options.keyword = name\n  return keywords[name] = new TokenType(name, options)\n}\n\nexport const types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\"),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n}\n"]}