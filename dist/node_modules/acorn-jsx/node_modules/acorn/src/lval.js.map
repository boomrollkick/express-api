{"version":3,"sources":["../../../../../../src/node_modules/acorn-jsx/node_modules/acorn/src/lval.js"],"names":["pp","Parser","prototype","toAssignable","node","isBinding","options","ecmaVersion","type","i","properties","length","prop","kind","raise","key","start","value","toAssignableList","elements","operator","left","end","right","expression","exprList","last","arg","argument","unexpected","elt","parseSpread","refDestructuringErrors","startNode","next","parseMaybeAssign","finishNode","parseRest","allowNonIdent","tt","name","parseIdent","bracketL","parseBindingAtom","parseBindingList","bracketR","braceL","parseObj","close","allowEmpty","allowTrailingComma","elts","first","eat","expect","comma","push","afterTrailingComma","ellipsis","rest","parseBindingListItem","elem","parseMaybeDefault","startLoc","param","startPos","eq","startNodeAt","checkLVal","expr","checkClashes","strict","reservedWordsStrictBind","test","raiseRecoverable"],"mappings":"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","file":"lval.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {has} from \"./util\"\n\nconst pp = Parser.prototype\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp.toAssignable = function(node, isBinding) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\"\n      for (let i = 0; i < node.properties.length; i++) {\n        let prop = node.properties[i]\n        if (prop.kind !== \"init\") this.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n        this.toAssignable(prop.value, isBinding)\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\"\n      this.toAssignableList(node.elements, isBinding)\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\"\n        delete node.operator\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n        break\n      }\n\n    case \"AssignmentPattern\":\n      if (node.right.type === \"YieldExpression\")\n        this.raise(node.right.start, \"Yield expression cannot be a default value\")\n      break\n\n    case \"ParenthesizedExpression\":\n      node.expression = this.toAssignable(node.expression, isBinding)\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) break\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\")\n    }\n  }\n  return node\n}\n\n// Convert list of expression atoms to binding list.\n\npp.toAssignableList = function(exprList, isBinding) {\n  let end = exprList.length\n  if (end) {\n    let last = exprList[end - 1]\n    if (last && last.type == \"RestElement\") {\n      --end\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\"\n      let arg = last.argument\n      this.toAssignable(arg, isBinding)\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n        this.unexpected(arg.start)\n      --end\n    }\n\n    if (isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      this.unexpected(last.argument.start)\n  }\n  for (let i = 0; i < end; i++) {\n    let elt = exprList[i]\n    if (elt) this.toAssignable(elt, isBinding)\n  }\n  return exprList\n}\n\n// Parses spread element.\n\npp.parseSpread = function(refDestructuringErrors) {\n  let node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors)\n  return this.finishNode(node, \"SpreadElement\")\n}\n\npp.parseRest = function(allowNonIdent) {\n  let node = this.startNode()\n  this.next()\n\n  // RestElement inside of a function parameter must be an identifier\n  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()\n  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n\n  return this.finishNode(node, \"RestElement\")\n}\n\n// Parses lvalue (assignable) atom.\n\npp.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) return this.parseIdent()\n  switch (this.type) {\n  case tt.name:\n    return this.parseIdent()\n\n  case tt.bracketL:\n    let node = this.startNode()\n    this.next()\n    node.elements = this.parseBindingList(tt.bracketR, true, true)\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case tt.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (first) first = false\n    else this.expect(tt.comma)\n    if (allowEmpty && this.type === tt.comma) {\n      elts.push(null)\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === tt.ellipsis) {\n      let rest = this.parseRest(allowNonIdent)\n      this.parseBindingListItem(rest)\n      elts.push(rest)\n      if (this.type === tt.comma) this.raise(this.start, \"Comma is not permitted after the rest element\")\n      this.expect(close)\n      break\n    } else {\n      let elem = this.parseMaybeDefault(this.start, this.startLoc)\n      this.parseBindingListItem(elem)\n      elts.push(elem)\n    }\n  }\n  return elts\n}\n\npp.parseBindingListItem = function(param) {\n  return param\n}\n\n// Parses assignment pattern around given atom if possible.\n\npp.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom()\n  if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left\n  let node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.right = this.parseMaybeAssign()\n  return this.finishNode(node, \"AssignmentPattern\")\n}\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n\npp.checkLVal = function(expr, isBinding, checkClashes) {\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      this.raiseRecoverable(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        this.raiseRecoverable(expr.start, \"Argument name clash\")\n      checkClashes[expr.name] = true\n    }\n    break\n\n  case \"MemberExpression\":\n    if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\")\n    break\n\n  case \"ObjectPattern\":\n    for (let i = 0; i < expr.properties.length; i++)\n      this.checkLVal(expr.properties[i].value, isBinding, checkClashes)\n    break\n\n  case \"ArrayPattern\":\n    for (let i = 0; i < expr.elements.length; i++) {\n      let elem = expr.elements[i]\n      if (elem) this.checkLVal(elem, isBinding, checkClashes)\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, isBinding, checkClashes)\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, isBinding, checkClashes)\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, isBinding, checkClashes)\n    break\n\n  default:\n    this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n  }\n}\n"]}