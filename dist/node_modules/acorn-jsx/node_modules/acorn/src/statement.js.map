{"version":3,"sources":["../../../../../../src/node_modules/acorn-jsx/node_modules/acorn/src/statement.js"],"names":["pp","Parser","prototype","parseTopLevel","node","first","body","type","tt","eof","stmt","parseStatement","push","isUseStrict","setStrict","next","options","ecmaVersion","sourceType","finishNode","loopLabel","kind","switchLabel","isLet","name","value","skipWhiteSpace","lastIndex","pos","skip","exec","input","length","nextCh","charCodeAt","ident","slice","isKeyword","declaration","topLevel","starttype","startNode","_var","_break","_continue","parseBreakContinueStatement","keyword","_debugger","parseDebuggerStatement","_do","parseDoStatement","_for","parseForStatement","_function","unexpected","parseFunctionStatement","_class","parseClass","_if","parseIfStatement","_return","parseReturnStatement","_switch","parseSwitchStatement","_throw","parseThrowStatement","_try","parseTryStatement","_const","parseVarStatement","_while","parseWhileStatement","_with","parseWithStatement","braceL","parseBlock","semi","parseEmptyStatement","_export","_import","allowImportExportEverywhere","raise","start","inModule","parseImport","parseExport","maybeName","expr","parseExpression","eat","colon","parseLabeledStatement","parseExpressionStatement","isBreak","insertSemicolon","label","parseIdent","semicolon","i","labels","lab","pop","expect","test","parseParenExpression","parenL","parseFor","init","parseVar","_in","isContextual","declarations","parseForIn","refDestructuringErrors","DestructuringErrors","checkPatternErrors","toAssignable","checkLVal","checkExpressionErrors","parseFunction","consequent","alternate","_else","inFunction","allowReturnOutsideFunction","argument","discriminant","cases","cur","sawDefault","braceR","_case","_default","isCase","raiseRecoverable","lastTokStart","lineBreak","lastTokEnd","empty","block","handler","_catch","clause","param","parseBindingAtom","parenR","finalizer","_finally","strict","object","isLoop","statementStart","expression","allowStrict","oldStrict","update","left","right","isFor","decl","parseVarId","eq","parseMaybeAssign","id","comma","isStatement","allowExpressionBody","initFunction","generator","star","oldInGen","inGenerator","parseFunctionParams","parseFunctionBody","params","parseBindingList","parseClassId","parseClassSuper","classBody","hadConstructor","method","isGenerator","isMaybeStatic","parsePropertyName","static","isGetSet","computed","key","parseClassMethod","paramCount","parseMethod","superClass","_extends","parseExprSubscripts","expectContextual","source","string","parseExprAtom","parens","needsSemi","shouldParseExportStatement","specifiers","parseExportSpecifiers","eatContextual","keywords","local","reservedWords","nodes","afterTrailingComma","exported","parseImportSpecifiers","imported","reservedWordsStrict"],"mappings":";;AAAA;;AACA;;AACA;;AACA;;AACA;;AAEA,IAAMA,KAAKC,cAAOC,SAAlB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEAF,GAAGG,aAAH,GAAmB,UAASC,IAAT,EAAe;AAChC,MAAIC,QAAQ,IAAZ;AACA,MAAI,CAACD,KAAKE,IAAV,EAAgBF,KAAKE,IAAL,GAAY,EAAZ;AAChB,SAAO,KAAKC,IAAL,KAAcC,iBAAGC,GAAxB,EAA6B;AAC3B,QAAIC,OAAO,KAAKC,cAAL,CAAoB,IAApB,EAA0B,IAA1B,CAAX;AACAP,SAAKE,IAAL,CAAUM,IAAV,CAAeF,IAAf;AACA,QAAIL,KAAJ,EAAW;AACT,UAAI,KAAKQ,WAAL,CAAiBH,IAAjB,CAAJ,EAA4B,KAAKI,SAAL,CAAe,IAAf;AAC5BT,cAAQ,KAAR;AACD;AACF;AACD,OAAKU,IAAL;AACA,MAAI,KAAKC,OAAL,CAAaC,WAAb,IAA4B,CAAhC,EAAmC;AACjCb,SAAKc,UAAL,GAAkB,KAAKF,OAAL,CAAaE,UAA/B;AACD;AACD,SAAO,KAAKC,UAAL,CAAgBf,IAAhB,EAAsB,SAAtB,CAAP;AACD,CAhBD;;AAkBA,IAAMgB,YAAY,EAACC,MAAM,MAAP,EAAlB;AAAA,IAAkCC,cAAc,EAACD,MAAM,QAAP,EAAhD;;AAEArB,GAAGuB,KAAH,GAAW,YAAW;AACpB,MAAI,KAAKhB,IAAL,KAAcC,iBAAGgB,IAAjB,IAAyB,KAAKR,OAAL,CAAaC,WAAb,GAA2B,CAApD,IAAyD,KAAKQ,KAAL,IAAc,KAA3E,EAAkF,OAAO,KAAP;AAClFC,6BAAeC,SAAf,GAA2B,KAAKC,GAAhC;AACA,MAAIC,OAAOH,2BAAeI,IAAf,CAAoB,KAAKC,KAAzB,CAAX;AACA,MAAIhB,OAAO,KAAKa,GAAL,GAAWC,KAAK,CAAL,EAAQG,MAA9B;AAAA,MAAsCC,SAAS,KAAKF,KAAL,CAAWG,UAAX,CAAsBnB,IAAtB,CAA/C;AACA,MAAIkB,WAAW,EAAX,IAAiBA,UAAU,GAA/B,EAAoC,OAAO,IAAP,CALhB,CAK4B;AAChD,MAAI,mCAAkBA,MAAlB,EAA0B,IAA1B,CAAJ,EAAqC;AACnC,SAAK,IAAIL,MAAMb,OAAO,CAAtB,EAAyB,kCAAiB,KAAKgB,KAAL,CAAWG,UAAX,CAAsBN,GAAtB,CAAjB,EAA6C,IAA7C,CAAzB,EAA6E,EAAEA,GAA/E,EAAoF,CAAE;AACtF,QAAIO,QAAQ,KAAKJ,KAAL,CAAWK,KAAX,CAAiBrB,IAAjB,EAAuBa,GAAvB,CAAZ;AACA,QAAI,CAAC,KAAKS,SAAL,CAAeF,KAAf,CAAL,EAA4B,OAAO,IAAP;AAC7B;AACD,SAAO,KAAP;AACD,CAZD;;AAcA;AACA;AACA;AACA;AACA;AACA;;AAEAnC,GAAGW,cAAH,GAAoB,UAAS2B,WAAT,EAAsBC,QAAtB,EAAgC;AAClD,MAAIC,YAAY,KAAKjC,IAArB;AAAA,MAA2BH,OAAO,KAAKqC,SAAL,EAAlC;AAAA,MAAoDpB,aAApD;;AAEA,MAAI,KAAKE,KAAL,EAAJ,EAAkB;AAChBiB,gBAAYhC,iBAAGkC,IAAf;AACArB,WAAO,KAAP;AACD;;AAED;AACA;AACA;;AAEA,UAAQmB,SAAR;AACA,SAAKhC,iBAAGmC,MAAR,CAAgB,KAAKnC,iBAAGoC,SAAR;AAAmB,aAAO,KAAKC,2BAAL,CAAiCzC,IAAjC,EAAuCoC,UAAUM,OAAjD,CAAP;AACnC,SAAKtC,iBAAGuC,SAAR;AAAmB,aAAO,KAAKC,sBAAL,CAA4B5C,IAA5B,CAAP;AACnB,SAAKI,iBAAGyC,GAAR;AAAa,aAAO,KAAKC,gBAAL,CAAsB9C,IAAtB,CAAP;AACb,SAAKI,iBAAG2C,IAAR;AAAc,aAAO,KAAKC,iBAAL,CAAuBhD,IAAvB,CAAP;AACd,SAAKI,iBAAG6C,SAAR;AACE,UAAI,CAACf,WAAD,IAAgB,KAAKtB,OAAL,CAAaC,WAAb,IAA4B,CAAhD,EAAmD,KAAKqC,UAAL;AACnD,aAAO,KAAKC,sBAAL,CAA4BnD,IAA5B,CAAP;AACF,SAAKI,iBAAGgD,MAAR;AACE,UAAI,CAAClB,WAAL,EAAkB,KAAKgB,UAAL;AAClB,aAAO,KAAKG,UAAL,CAAgBrD,IAAhB,EAAsB,IAAtB,CAAP;AACF,SAAKI,iBAAGkD,GAAR;AAAa,aAAO,KAAKC,gBAAL,CAAsBvD,IAAtB,CAAP;AACb,SAAKI,iBAAGoD,OAAR;AAAiB,aAAO,KAAKC,oBAAL,CAA0BzD,IAA1B,CAAP;AACjB,SAAKI,iBAAGsD,OAAR;AAAiB,aAAO,KAAKC,oBAAL,CAA0B3D,IAA1B,CAAP;AACjB,SAAKI,iBAAGwD,MAAR;AAAgB,aAAO,KAAKC,mBAAL,CAAyB7D,IAAzB,CAAP;AAChB,SAAKI,iBAAG0D,IAAR;AAAc,aAAO,KAAKC,iBAAL,CAAuB/D,IAAvB,CAAP;AACd,SAAKI,iBAAG4D,MAAR,CAAgB,KAAK5D,iBAAGkC,IAAR;AACdrB,aAAOA,QAAQ,KAAKI,KAApB;AACA,UAAI,CAACa,WAAD,IAAgBjB,QAAQ,KAA5B,EAAmC,KAAKiC,UAAL;AACnC,aAAO,KAAKe,iBAAL,CAAuBjE,IAAvB,EAA6BiB,IAA7B,CAAP;AACF,SAAKb,iBAAG8D,MAAR;AAAgB,aAAO,KAAKC,mBAAL,CAAyBnE,IAAzB,CAAP;AAChB,SAAKI,iBAAGgE,KAAR;AAAe,aAAO,KAAKC,kBAAL,CAAwBrE,IAAxB,CAAP;AACf,SAAKI,iBAAGkE,MAAR;AAAgB,aAAO,KAAKC,UAAL,EAAP;AAChB,SAAKnE,iBAAGoE,IAAR;AAAc,aAAO,KAAKC,mBAAL,CAAyBzE,IAAzB,CAAP;AACd,SAAKI,iBAAGsE,OAAR;AACA,SAAKtE,iBAAGuE,OAAR;AACE,UAAI,CAAC,KAAK/D,OAAL,CAAagE,2BAAlB,EAA+C;AAC7C,YAAI,CAACzC,QAAL,EACE,KAAK0C,KAAL,CAAW,KAAKC,KAAhB,EAAuB,wDAAvB;AACF,YAAI,CAAC,KAAKC,QAAV,EACE,KAAKF,KAAL,CAAW,KAAKC,KAAhB,EAAuB,iEAAvB;AACH;AACD,aAAO1C,cAAchC,iBAAGuE,OAAjB,GAA2B,KAAKK,WAAL,CAAiBhF,IAAjB,CAA3B,GAAoD,KAAKiF,WAAL,CAAiBjF,IAAjB,CAA3D;;AAEA;AACA;AACA;AACA;AACA;AACF;AACE,UAAIkF,YAAY,KAAK7D,KAArB;AAAA,UAA4B8D,OAAO,KAAKC,eAAL,EAAnC;AACA,UAAIhD,cAAchC,iBAAGgB,IAAjB,IAAyB+D,KAAKhF,IAAL,KAAc,YAAvC,IAAuD,KAAKkF,GAAL,CAASjF,iBAAGkF,KAAZ,CAA3D,EACE,OAAO,KAAKC,qBAAL,CAA2BvF,IAA3B,EAAiCkF,SAAjC,EAA4CC,IAA5C,CAAP,CADF,KAEK,OAAO,KAAKK,wBAAL,CAA8BxF,IAA9B,EAAoCmF,IAApC,CAAP;AA3CP;AA6CD,CAzDD;;AA2DAvF,GAAG6C,2BAAH,GAAiC,UAASzC,IAAT,EAAe0C,OAAf,EAAwB;AACvD,MAAI+C,UAAU/C,WAAW,OAAzB;AACA,OAAK/B,IAAL;AACA,MAAI,KAAK0E,GAAL,CAASjF,iBAAGoE,IAAZ,KAAqB,KAAKkB,eAAL,EAAzB,EAAiD1F,KAAK2F,KAAL,GAAa,IAAb,CAAjD,KACK,IAAI,KAAKxF,IAAL,KAAcC,iBAAGgB,IAArB,EAA2B,KAAK8B,UAAL,GAA3B,KACA;AACHlD,SAAK2F,KAAL,GAAa,KAAKC,UAAL,EAAb;AACA,SAAKC,SAAL;AACD;;AAED;AACA;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,KAAKC,MAAL,CAAYnE,MAAhC,EAAwC,EAAEkE,CAA1C,EAA6C;AAC3C,QAAIE,MAAM,KAAKD,MAAL,CAAYD,CAAZ,CAAV;AACA,QAAI9F,KAAK2F,KAAL,IAAc,IAAd,IAAsBK,IAAI5E,IAAJ,KAAapB,KAAK2F,KAAL,CAAWvE,IAAlD,EAAwD;AACtD,UAAI4E,IAAI/E,IAAJ,IAAY,IAAZ,KAAqBwE,WAAWO,IAAI/E,IAAJ,KAAa,MAA7C,CAAJ,EAA0D;AAC1D,UAAIjB,KAAK2F,KAAL,IAAcF,OAAlB,EAA2B;AAC5B;AACF;AACD,MAAIK,MAAM,KAAKC,MAAL,CAAYnE,MAAtB,EAA8B,KAAKiD,KAAL,CAAW7E,KAAK8E,KAAhB,EAAuB,iBAAiBpC,OAAxC;AAC9B,SAAO,KAAK3B,UAAL,CAAgBf,IAAhB,EAAsByF,UAAU,gBAAV,GAA6B,mBAAnD,CAAP;AACD,CArBD;;AAuBA7F,GAAGgD,sBAAH,GAA4B,UAAS5C,IAAT,EAAe;AACzC,OAAKW,IAAL;AACA,OAAKkF,SAAL;AACA,SAAO,KAAK9E,UAAL,CAAgBf,IAAhB,EAAsB,mBAAtB,CAAP;AACD,CAJD;;AAMAJ,GAAGkD,gBAAH,GAAsB,UAAS9C,IAAT,EAAe;AACnC,OAAKW,IAAL;AACA,OAAKoF,MAAL,CAAYvF,IAAZ,CAAiBQ,SAAjB;AACAhB,OAAKE,IAAL,GAAY,KAAKK,cAAL,CAAoB,KAApB,CAAZ;AACA,OAAKwF,MAAL,CAAYE,GAAZ;AACA,OAAKC,MAAL,CAAY9F,iBAAG8D,MAAf;AACAlE,OAAKmG,IAAL,GAAY,KAAKC,oBAAL,EAAZ;AACA,MAAI,KAAKxF,OAAL,CAAaC,WAAb,IAA4B,CAAhC,EACE,KAAKwE,GAAL,CAASjF,iBAAGoE,IAAZ,EADF,KAGE,KAAKqB,SAAL;AACF,SAAO,KAAK9E,UAAL,CAAgBf,IAAhB,EAAsB,kBAAtB,CAAP;AACD,CAZD;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAJ,GAAGoD,iBAAH,GAAuB,UAAShD,IAAT,EAAe;AACpC,OAAKW,IAAL;AACA,OAAKoF,MAAL,CAAYvF,IAAZ,CAAiBQ,SAAjB;AACA,OAAKkF,MAAL,CAAY9F,iBAAGiG,MAAf;AACA,MAAI,KAAKlG,IAAL,KAAcC,iBAAGoE,IAArB,EAA2B,OAAO,KAAK8B,QAAL,CAActG,IAAd,EAAoB,IAApB,CAAP;AAC3B,MAAImB,QAAQ,KAAKA,KAAL,EAAZ;AACA,MAAI,KAAKhB,IAAL,KAAcC,iBAAGkC,IAAjB,IAAyB,KAAKnC,IAAL,KAAcC,iBAAG4D,MAA1C,IAAoD7C,KAAxD,EAA+D;AAC7D,QAAIoF,QAAO,KAAKlE,SAAL,EAAX;AAAA,QAA6BpB,OAAOE,QAAQ,KAAR,GAAgB,KAAKE,KAAzD;AACA,SAAKV,IAAL;AACA,SAAK6F,QAAL,CAAcD,KAAd,EAAoB,IAApB,EAA0BtF,IAA1B;AACA,SAAKF,UAAL,CAAgBwF,KAAhB,EAAsB,qBAAtB;AACA,QAAI,CAAC,KAAKpG,IAAL,KAAcC,iBAAGqG,GAAjB,IAAyB,KAAK7F,OAAL,CAAaC,WAAb,IAA4B,CAA5B,IAAiC,KAAK6F,YAAL,CAAkB,IAAlB,CAA3D,KAAwFH,MAAKI,YAAL,CAAkB/E,MAAlB,KAA6B,CAArH,IACA,EAAEX,SAAS,KAAT,IAAkBsF,MAAKI,YAAL,CAAkB,CAAlB,EAAqBJ,IAAzC,CADJ,EAEE,OAAO,KAAKK,UAAL,CAAgB5G,IAAhB,EAAsBuG,KAAtB,CAAP;AACF,WAAO,KAAKD,QAAL,CAActG,IAAd,EAAoBuG,KAApB,CAAP;AACD;AACD,MAAIM,yBAAyB,IAAIC,8BAAJ,EAA7B;AACA,MAAIP,OAAO,KAAKnB,eAAL,CAAqB,IAArB,EAA2ByB,sBAA3B,CAAX;AACA,MAAI,KAAK1G,IAAL,KAAcC,iBAAGqG,GAAjB,IAAyB,KAAK7F,OAAL,CAAaC,WAAb,IAA4B,CAA5B,IAAiC,KAAK6F,YAAL,CAAkB,IAAlB,CAA9D,EAAwF;AACtF,SAAKK,kBAAL,CAAwBF,sBAAxB,EAAgD,IAAhD;AACA,SAAKG,YAAL,CAAkBT,IAAlB;AACA,SAAKU,SAAL,CAAeV,IAAf;AACA,WAAO,KAAKK,UAAL,CAAgB5G,IAAhB,EAAsBuG,IAAtB,CAAP;AACD,GALD,MAKO;AACL,SAAKW,qBAAL,CAA2BL,sBAA3B,EAAmD,IAAnD;AACD;AACD,SAAO,KAAKP,QAAL,CAActG,IAAd,EAAoBuG,IAApB,CAAP;AACD,CA3BD;;AA6BA3G,GAAGuD,sBAAH,GAA4B,UAASnD,IAAT,EAAe;AACzC,OAAKW,IAAL;AACA,SAAO,KAAKwG,aAAL,CAAmBnH,IAAnB,EAAyB,IAAzB,CAAP;AACD,CAHD;;AAKAJ,GAAG2D,gBAAH,GAAsB,UAASvD,IAAT,EAAe;AACnC,OAAKW,IAAL;AACAX,OAAKmG,IAAL,GAAY,KAAKC,oBAAL,EAAZ;AACApG,OAAKoH,UAAL,GAAkB,KAAK7G,cAAL,CAAoB,KAApB,CAAlB;AACAP,OAAKqH,SAAL,GAAiB,KAAKhC,GAAL,CAASjF,iBAAGkH,KAAZ,IAAqB,KAAK/G,cAAL,CAAoB,KAApB,CAArB,GAAkD,IAAnE;AACA,SAAO,KAAKQ,UAAL,CAAgBf,IAAhB,EAAsB,aAAtB,CAAP;AACD,CAND;;AAQAJ,GAAG6D,oBAAH,GAA0B,UAASzD,IAAT,EAAe;AACvC,MAAI,CAAC,KAAKuH,UAAN,IAAoB,CAAC,KAAK3G,OAAL,CAAa4G,0BAAtC,EACE,KAAK3C,KAAL,CAAW,KAAKC,KAAhB,EAAuB,8BAAvB;AACF,OAAKnE,IAAL;;AAEA;AACA;AACA;;AAEA,MAAI,KAAK0E,GAAL,CAASjF,iBAAGoE,IAAZ,KAAqB,KAAKkB,eAAL,EAAzB,EAAiD1F,KAAKyH,QAAL,GAAgB,IAAhB,CAAjD,KACK;AAAEzH,SAAKyH,QAAL,GAAgB,KAAKrC,eAAL,EAAhB,CAAwC,KAAKS,SAAL;AAAkB;AACjE,SAAO,KAAK9E,UAAL,CAAgBf,IAAhB,EAAsB,iBAAtB,CAAP;AACD,CAZD;;AAcAJ,GAAG+D,oBAAH,GAA0B,UAAS3D,IAAT,EAAe;AACvC,OAAKW,IAAL;AACAX,OAAK0H,YAAL,GAAoB,KAAKtB,oBAAL,EAApB;AACApG,OAAK2H,KAAL,GAAa,EAAb;AACA,OAAKzB,MAAL,CAAY9F,iBAAGkE,MAAf;AACA,OAAKyB,MAAL,CAAYvF,IAAZ,CAAiBU,WAAjB;;AAEA;AACA;AACA;;AAEA,OAAK,IAAI0G,GAAJ,EAASC,aAAa,KAA3B,EAAkC,KAAK1H,IAAL,IAAaC,iBAAG0H,MAAlD,GAA2D;AACzD,QAAI,KAAK3H,IAAL,KAAcC,iBAAG2H,KAAjB,IAA0B,KAAK5H,IAAL,KAAcC,iBAAG4H,QAA/C,EAAyD;AACvD,UAAIC,SAAS,KAAK9H,IAAL,KAAcC,iBAAG2H,KAA9B;AACA,UAAIH,GAAJ,EAAS,KAAK7G,UAAL,CAAgB6G,GAAhB,EAAqB,YAArB;AACT5H,WAAK2H,KAAL,CAAWnH,IAAX,CAAgBoH,MAAM,KAAKvF,SAAL,EAAtB;AACAuF,UAAIR,UAAJ,GAAiB,EAAjB;AACA,WAAKzG,IAAL;AACA,UAAIsH,MAAJ,EAAY;AACVL,YAAIzB,IAAJ,GAAW,KAAKf,eAAL,EAAX;AACD,OAFD,MAEO;AACL,YAAIyC,UAAJ,EAAgB,KAAKK,gBAAL,CAAsB,KAAKC,YAA3B,EAAyC,0BAAzC;AAChBN,qBAAa,IAAb;AACAD,YAAIzB,IAAJ,GAAW,IAAX;AACD;AACD,WAAKD,MAAL,CAAY9F,iBAAGkF,KAAf;AACD,KAdD,MAcO;AACL,UAAI,CAACsC,GAAL,EAAU,KAAK1E,UAAL;AACV0E,UAAIR,UAAJ,CAAe5G,IAAf,CAAoB,KAAKD,cAAL,CAAoB,IAApB,CAApB;AACD;AACF;AACD,MAAIqH,GAAJ,EAAS,KAAK7G,UAAL,CAAgB6G,GAAhB,EAAqB,YAArB;AACT,OAAKjH,IAAL,GAhCuC,CAgC3B;AACZ,OAAKoF,MAAL,CAAYE,GAAZ;AACA,SAAO,KAAKlF,UAAL,CAAgBf,IAAhB,EAAsB,iBAAtB,CAAP;AACD,CAnCD;;AAqCAJ,GAAGiE,mBAAH,GAAyB,UAAS7D,IAAT,EAAe;AACtC,OAAKW,IAAL;AACA,MAAIyH,sBAAUjC,IAAV,CAAe,KAAKxE,KAAL,CAAWK,KAAX,CAAiB,KAAKqG,UAAtB,EAAkC,KAAKvD,KAAvC,CAAf,CAAJ,EACE,KAAKD,KAAL,CAAW,KAAKwD,UAAhB,EAA4B,6BAA5B;AACFrI,OAAKyH,QAAL,GAAgB,KAAKrC,eAAL,EAAhB;AACA,OAAKS,SAAL;AACA,SAAO,KAAK9E,UAAL,CAAgBf,IAAhB,EAAsB,gBAAtB,CAAP;AACD,CAPD;;AASA;;AAEA,IAAMsI,QAAQ,EAAd;;AAEA1I,GAAGmE,iBAAH,GAAuB,UAAS/D,IAAT,EAAe;AACpC,OAAKW,IAAL;AACAX,OAAKuI,KAAL,GAAa,KAAKhE,UAAL,EAAb;AACAvE,OAAKwI,OAAL,GAAe,IAAf;AACA,MAAI,KAAKrI,IAAL,KAAcC,iBAAGqI,MAArB,EAA6B;AAC3B,QAAIC,SAAS,KAAKrG,SAAL,EAAb;AACA,SAAK1B,IAAL;AACA,SAAKuF,MAAL,CAAY9F,iBAAGiG,MAAf;AACAqC,WAAOC,KAAP,GAAe,KAAKC,gBAAL,EAAf;AACA,SAAK3B,SAAL,CAAeyB,OAAOC,KAAtB,EAA6B,IAA7B;AACA,SAAKzC,MAAL,CAAY9F,iBAAGyI,MAAf;AACAH,WAAOxI,IAAP,GAAc,KAAKqE,UAAL,EAAd;AACAvE,SAAKwI,OAAL,GAAe,KAAKzH,UAAL,CAAgB2H,MAAhB,EAAwB,aAAxB,CAAf;AACD;AACD1I,OAAK8I,SAAL,GAAiB,KAAKzD,GAAL,CAASjF,iBAAG2I,QAAZ,IAAwB,KAAKxE,UAAL,EAAxB,GAA4C,IAA7D;AACA,MAAI,CAACvE,KAAKwI,OAAN,IAAiB,CAACxI,KAAK8I,SAA3B,EACE,KAAKjE,KAAL,CAAW7E,KAAK8E,KAAhB,EAAuB,iCAAvB;AACF,SAAO,KAAK/D,UAAL,CAAgBf,IAAhB,EAAsB,cAAtB,CAAP;AACD,CAlBD;;AAoBAJ,GAAGqE,iBAAH,GAAuB,UAASjE,IAAT,EAAeiB,IAAf,EAAqB;AAC1C,OAAKN,IAAL;AACA,OAAK6F,QAAL,CAAcxG,IAAd,EAAoB,KAApB,EAA2BiB,IAA3B;AACA,OAAK4E,SAAL;AACA,SAAO,KAAK9E,UAAL,CAAgBf,IAAhB,EAAsB,qBAAtB,CAAP;AACD,CALD;;AAOAJ,GAAGuE,mBAAH,GAAyB,UAASnE,IAAT,EAAe;AACtC,OAAKW,IAAL;AACAX,OAAKmG,IAAL,GAAY,KAAKC,oBAAL,EAAZ;AACA,OAAKL,MAAL,CAAYvF,IAAZ,CAAiBQ,SAAjB;AACAhB,OAAKE,IAAL,GAAY,KAAKK,cAAL,CAAoB,KAApB,CAAZ;AACA,OAAKwF,MAAL,CAAYE,GAAZ;AACA,SAAO,KAAKlF,UAAL,CAAgBf,IAAhB,EAAsB,gBAAtB,CAAP;AACD,CAPD;;AASAJ,GAAGyE,kBAAH,GAAwB,UAASrE,IAAT,EAAe;AACrC,MAAI,KAAKgJ,MAAT,EAAiB,KAAKnE,KAAL,CAAW,KAAKC,KAAhB,EAAuB,uBAAvB;AACjB,OAAKnE,IAAL;AACAX,OAAKiJ,MAAL,GAAc,KAAK7C,oBAAL,EAAd;AACApG,OAAKE,IAAL,GAAY,KAAKK,cAAL,CAAoB,KAApB,CAAZ;AACA,SAAO,KAAKQ,UAAL,CAAgBf,IAAhB,EAAsB,eAAtB,CAAP;AACD,CAND;;AAQAJ,GAAG6E,mBAAH,GAAyB,UAASzE,IAAT,EAAe;AACtC,OAAKW,IAAL;AACA,SAAO,KAAKI,UAAL,CAAgBf,IAAhB,EAAsB,gBAAtB,CAAP;AACD,CAHD;;AAKAJ,GAAG2F,qBAAH,GAA2B,UAASvF,IAAT,EAAekF,SAAf,EAA0BC,IAA1B,EAAgC;AACzD,OAAK,IAAIW,IAAI,CAAb,EAAgBA,IAAI,KAAKC,MAAL,CAAYnE,MAAhC,EAAwC,EAAEkE,CAA1C;AACE,QAAI,KAAKC,MAAL,CAAYD,CAAZ,EAAe1E,IAAf,KAAwB8D,SAA5B,EAAuC,KAAKL,KAAL,CAAWM,KAAKL,KAAhB,EAAuB,YAAYI,SAAZ,GAAwB,uBAA/C;AADzC,GAEA,IAAIjE,OAAO,KAAKd,IAAL,CAAU+I,MAAV,GAAmB,MAAnB,GAA4B,KAAK/I,IAAL,KAAcC,iBAAGsD,OAAjB,GAA2B,QAA3B,GAAsC,IAA7E;AACA,OAAK,IAAIoC,KAAI,KAAKC,MAAL,CAAYnE,MAAZ,GAAqB,CAAlC,EAAqCkE,MAAK,CAA1C,EAA6CA,IAA7C,EAAkD;AAChD,QAAIH,QAAQ,KAAKI,MAAL,CAAYD,EAAZ,CAAZ;AACA,QAAIH,MAAMwD,cAAN,IAAwBnJ,KAAK8E,KAAjC,EAAwC;AACtCa,YAAMwD,cAAN,GAAuB,KAAKrE,KAA5B;AACAa,YAAM1E,IAAN,GAAaA,IAAb;AACD,KAHD,MAGO;AACR;AACD,OAAK8E,MAAL,CAAYvF,IAAZ,CAAiB,EAACY,MAAM8D,SAAP,EAAkBjE,MAAMA,IAAxB,EAA8BkI,gBAAgB,KAAKrE,KAAnD,EAAjB;AACA9E,OAAKE,IAAL,GAAY,KAAKK,cAAL,CAAoB,IAApB,CAAZ;AACA,OAAKwF,MAAL,CAAYE,GAAZ;AACAjG,OAAK2F,KAAL,GAAaR,IAAb;AACA,SAAO,KAAKpE,UAAL,CAAgBf,IAAhB,EAAsB,kBAAtB,CAAP;AACD,CAhBD;;AAkBAJ,GAAG4F,wBAAH,GAA8B,UAASxF,IAAT,EAAemF,IAAf,EAAqB;AACjDnF,OAAKoJ,UAAL,GAAkBjE,IAAlB;AACA,OAAKU,SAAL;AACA,SAAO,KAAK9E,UAAL,CAAgBf,IAAhB,EAAsB,qBAAtB,CAAP;AACD,CAJD;;AAMA;AACA;AACA;;AAEAJ,GAAG2E,UAAH,GAAgB,UAAS8E,WAAT,EAAsB;AACpC,MAAIrJ,OAAO,KAAKqC,SAAL,EAAX;AAAA,MAA6BpC,QAAQ,IAArC;AAAA,MAA2CqJ,kBAA3C;AACAtJ,OAAKE,IAAL,GAAY,EAAZ;AACA,OAAKgG,MAAL,CAAY9F,iBAAGkE,MAAf;AACA,SAAO,CAAC,KAAKe,GAAL,CAASjF,iBAAG0H,MAAZ,CAAR,EAA6B;AAC3B,QAAIxH,OAAO,KAAKC,cAAL,CAAoB,IAApB,CAAX;AACAP,SAAKE,IAAL,CAAUM,IAAV,CAAeF,IAAf;AACA,QAAIL,SAASoJ,WAAT,IAAwB,KAAK5I,WAAL,CAAiBH,IAAjB,CAA5B,EAAoD;AAClDgJ,kBAAY,KAAKN,MAAjB;AACA,WAAKtI,SAAL,CAAe,KAAKsI,MAAL,GAAc,IAA7B;AACD;AACD/I,YAAQ,KAAR;AACD;AACD,MAAIqJ,cAAc,KAAlB,EAAyB,KAAK5I,SAAL,CAAe,KAAf;AACzB,SAAO,KAAKK,UAAL,CAAgBf,IAAhB,EAAsB,gBAAtB,CAAP;AACD,CAfD;;AAiBA;AACA;AACA;;AAEAJ,GAAG0G,QAAH,GAAc,UAAStG,IAAT,EAAeuG,IAAf,EAAqB;AACjCvG,OAAKuG,IAAL,GAAYA,IAAZ;AACA,OAAKL,MAAL,CAAY9F,iBAAGoE,IAAf;AACAxE,OAAKmG,IAAL,GAAY,KAAKhG,IAAL,KAAcC,iBAAGoE,IAAjB,GAAwB,IAAxB,GAA+B,KAAKY,eAAL,EAA3C;AACA,OAAKc,MAAL,CAAY9F,iBAAGoE,IAAf;AACAxE,OAAKuJ,MAAL,GAAc,KAAKpJ,IAAL,KAAcC,iBAAGyI,MAAjB,GAA0B,IAA1B,GAAiC,KAAKzD,eAAL,EAA/C;AACA,OAAKc,MAAL,CAAY9F,iBAAGyI,MAAf;AACA7I,OAAKE,IAAL,GAAY,KAAKK,cAAL,CAAoB,KAApB,CAAZ;AACA,OAAKwF,MAAL,CAAYE,GAAZ;AACA,SAAO,KAAKlF,UAAL,CAAgBf,IAAhB,EAAsB,cAAtB,CAAP;AACD,CAVD;;AAYA;AACA;;AAEAJ,GAAGgH,UAAH,GAAgB,UAAS5G,IAAT,EAAeuG,IAAf,EAAqB;AACnC,MAAIpG,OAAO,KAAKA,IAAL,KAAcC,iBAAGqG,GAAjB,GAAuB,gBAAvB,GAA0C,gBAArD;AACA,OAAK9F,IAAL;AACAX,OAAKwJ,IAAL,GAAYjD,IAAZ;AACAvG,OAAKyJ,KAAL,GAAa,KAAKrE,eAAL,EAAb;AACA,OAAKc,MAAL,CAAY9F,iBAAGyI,MAAf;AACA7I,OAAKE,IAAL,GAAY,KAAKK,cAAL,CAAoB,KAApB,CAAZ;AACA,OAAKwF,MAAL,CAAYE,GAAZ;AACA,SAAO,KAAKlF,UAAL,CAAgBf,IAAhB,EAAsBG,IAAtB,CAAP;AACD,CATD;;AAWA;;AAEAP,GAAG4G,QAAH,GAAc,UAASxG,IAAT,EAAe0J,KAAf,EAAsBzI,IAAtB,EAA4B;AACxCjB,OAAK2G,YAAL,GAAoB,EAApB;AACA3G,OAAKiB,IAAL,GAAYA,IAAZ;AACA,WAAS;AACP,QAAI0I,OAAO,KAAKtH,SAAL,EAAX;AACA,SAAKuH,UAAL,CAAgBD,IAAhB;AACA,QAAI,KAAKtE,GAAL,CAASjF,iBAAGyJ,EAAZ,CAAJ,EAAqB;AACnBF,WAAKpD,IAAL,GAAY,KAAKuD,gBAAL,CAAsBJ,KAAtB,CAAZ;AACD,KAFD,MAEO,IAAIzI,SAAS,OAAT,IAAoB,EAAE,KAAKd,IAAL,KAAcC,iBAAGqG,GAAjB,IAAyB,KAAK7F,OAAL,CAAaC,WAAb,IAA4B,CAA5B,IAAiC,KAAK6F,YAAL,CAAkB,IAAlB,CAA5D,CAAxB,EAA+G;AACpH,WAAKxD,UAAL;AACD,KAFM,MAEA,IAAIyG,KAAKI,EAAL,CAAQ5J,IAAR,IAAgB,YAAhB,IAAgC,EAAEuJ,UAAU,KAAKvJ,IAAL,KAAcC,iBAAGqG,GAAjB,IAAwB,KAAKC,YAAL,CAAkB,IAAlB,CAAlC,CAAF,CAApC,EAAmG;AACxG,WAAK7B,KAAL,CAAW,KAAKwD,UAAhB,EAA4B,0DAA5B;AACD,KAFM,MAEA;AACLsB,WAAKpD,IAAL,GAAY,IAAZ;AACD;AACDvG,SAAK2G,YAAL,CAAkBnG,IAAlB,CAAuB,KAAKO,UAAL,CAAgB4I,IAAhB,EAAsB,oBAAtB,CAAvB;AACA,QAAI,CAAC,KAAKtE,GAAL,CAASjF,iBAAG4J,KAAZ,CAAL,EAAyB;AAC1B;AACD,SAAOhK,IAAP;AACD,CAnBD;;AAqBAJ,GAAGgK,UAAH,GAAgB,UAASD,IAAT,EAAe;AAC7BA,OAAKI,EAAL,GAAU,KAAKnB,gBAAL,EAAV;AACA,OAAK3B,SAAL,CAAe0C,KAAKI,EAApB,EAAwB,IAAxB;AACD,CAHD;;AAKA;AACA;;AAEAnK,GAAGuH,aAAH,GAAmB,UAASnH,IAAT,EAAeiK,WAAf,EAA4BC,mBAA5B,EAAiD;AAClE,OAAKC,YAAL,CAAkBnK,IAAlB;AACA,MAAI,KAAKY,OAAL,CAAaC,WAAb,IAA4B,CAAhC,EACEb,KAAKoK,SAAL,GAAiB,KAAK/E,GAAL,CAASjF,iBAAGiK,IAAZ,CAAjB;AACF,MAAIC,WAAW,KAAKC,WAApB;AACA,OAAKA,WAAL,GAAmBvK,KAAKoK,SAAxB;AACA,MAAIH,eAAe,KAAK9J,IAAL,KAAcC,iBAAGgB,IAApC,EACEpB,KAAK+J,EAAL,GAAU,KAAKnE,UAAL,EAAV;AACF,OAAK4E,mBAAL,CAAyBxK,IAAzB;AACA,OAAKyK,iBAAL,CAAuBzK,IAAvB,EAA6BkK,mBAA7B;AACA,OAAKK,WAAL,GAAmBD,QAAnB;AACA,SAAO,KAAKvJ,UAAL,CAAgBf,IAAhB,EAAsBiK,cAAc,qBAAd,GAAsC,oBAA5D,CAAP;AACD,CAZD;;AAcArK,GAAG4K,mBAAH,GAAyB,UAASxK,IAAT,EAAe;AACtC,OAAKkG,MAAL,CAAY9F,iBAAGiG,MAAf;AACArG,OAAK0K,MAAL,GAAc,KAAKC,gBAAL,CAAsBvK,iBAAGyI,MAAzB,EAAiC,KAAjC,EAAwC,KAAxC,EAA+C,IAA/C,CAAd;AACD,CAHD;;AAKA;AACA;;AAEAjJ,GAAGyD,UAAH,GAAgB,UAASrD,IAAT,EAAeiK,WAAf,EAA4B;AAC1C,OAAKtJ,IAAL;AACA,OAAKiK,YAAL,CAAkB5K,IAAlB,EAAwBiK,WAAxB;AACA,OAAKY,eAAL,CAAqB7K,IAArB;AACA,MAAI8K,YAAY,KAAKzI,SAAL,EAAhB;AACA,MAAI0I,iBAAiB,KAArB;AACAD,YAAU5K,IAAV,GAAiB,EAAjB;AACA,OAAKgG,MAAL,CAAY9F,iBAAGkE,MAAf;AACA,SAAO,CAAC,KAAKe,GAAL,CAASjF,iBAAG0H,MAAZ,CAAR,EAA6B;AAC3B,QAAI,KAAKzC,GAAL,CAASjF,iBAAGoE,IAAZ,CAAJ,EAAuB;AACvB,QAAIwG,SAAS,KAAK3I,SAAL,EAAb;AACA,QAAI4I,cAAc,KAAK5F,GAAL,CAASjF,iBAAGiK,IAAZ,CAAlB;AACA,QAAIa,gBAAgB,KAAK/K,IAAL,KAAcC,iBAAGgB,IAAjB,IAAyB,KAAKC,KAAL,KAAe,QAA5D;AACA,SAAK8J,iBAAL,CAAuBH,MAAvB;AACAA,WAAOI,MAAP,GAAgBF,iBAAiB,KAAK/K,IAAL,KAAcC,iBAAGiG,MAAlD;AACA,QAAI2E,OAAOI,MAAX,EAAmB;AACjB,UAAIH,WAAJ,EAAiB,KAAK/H,UAAL;AACjB+H,oBAAc,KAAK5F,GAAL,CAASjF,iBAAGiK,IAAZ,CAAd;AACA,WAAKc,iBAAL,CAAuBH,MAAvB;AACD;AACDA,WAAO/J,IAAP,GAAc,QAAd;AACA,QAAIoK,WAAW,KAAf;AACA,QAAI,CAACL,OAAOM,QAAZ,EAAsB;AAAA,UACfC,GADe,GACRP,MADQ,CACfO,GADe;;AAEpB,UAAI,CAACN,WAAD,IAAgBM,IAAIpL,IAAJ,KAAa,YAA7B,IAA6C,KAAKA,IAAL,KAAcC,iBAAGiG,MAA9D,KAAyEkF,IAAInK,IAAJ,KAAa,KAAb,IAAsBmK,IAAInK,IAAJ,KAAa,KAA5G,CAAJ,EAAwH;AACtHiK,mBAAW,IAAX;AACAL,eAAO/J,IAAP,GAAcsK,IAAInK,IAAlB;AACAmK,cAAM,KAAKJ,iBAAL,CAAuBH,MAAvB,CAAN;AACD;AACD,UAAI,CAACA,OAAOI,MAAR,KAAmBG,IAAIpL,IAAJ,KAAa,YAAb,IAA6BoL,IAAInK,IAAJ,KAAa,aAA1C,IACnBmK,IAAIpL,IAAJ,KAAa,SAAb,IAA0BoL,IAAIlK,KAAJ,KAAc,aADxC,CAAJ,EAC4D;AAC1D,YAAI0J,cAAJ,EAAoB,KAAKlG,KAAL,CAAW0G,IAAIzG,KAAf,EAAsB,yCAAtB;AACpB,YAAIuG,QAAJ,EAAc,KAAKxG,KAAL,CAAW0G,IAAIzG,KAAf,EAAsB,yCAAtB;AACd,YAAImG,WAAJ,EAAiB,KAAKpG,KAAL,CAAW0G,IAAIzG,KAAf,EAAsB,kCAAtB;AACjBkG,eAAO/J,IAAP,GAAc,aAAd;AACA8J,yBAAiB,IAAjB;AACD;AACF;AACD,SAAKS,gBAAL,CAAsBV,SAAtB,EAAiCE,MAAjC,EAAyCC,WAAzC;AACA,QAAII,QAAJ,EAAc;AACZ,UAAII,aAAaT,OAAO/J,IAAP,KAAgB,KAAhB,GAAwB,CAAxB,GAA4B,CAA7C;AACA,UAAI+J,OAAO3J,KAAP,CAAaqJ,MAAb,CAAoB9I,MAApB,KAA+B6J,UAAnC,EAA+C;AAC7C,YAAI3G,QAAQkG,OAAO3J,KAAP,CAAayD,KAAzB;AACA,YAAIkG,OAAO/J,IAAP,KAAgB,KAApB,EACE,KAAKiH,gBAAL,CAAsBpD,KAAtB,EAA6B,8BAA7B,EADF,KAGE,KAAKoD,gBAAL,CAAsBpD,KAAtB,EAA6B,sCAA7B;AACH;AACD,UAAIkG,OAAO/J,IAAP,KAAgB,KAAhB,IAAyB+J,OAAO3J,KAAP,CAAaqJ,MAAb,CAAoB,CAApB,EAAuBvK,IAAvB,KAAgC,aAA7D,EACE,KAAK0E,KAAL,CAAWmG,OAAO3J,KAAP,CAAaqJ,MAAb,CAAoB,CAApB,EAAuB5F,KAAlC,EAAyC,+BAAzC;AACH;AACF;AACD9E,OAAKE,IAAL,GAAY,KAAKa,UAAL,CAAgB+J,SAAhB,EAA2B,WAA3B,CAAZ;AACA,SAAO,KAAK/J,UAAL,CAAgBf,IAAhB,EAAsBiK,cAAc,kBAAd,GAAmC,iBAAzD,CAAP;AACD,CAtDD;;AAwDArK,GAAG4L,gBAAH,GAAsB,UAASV,SAAT,EAAoBE,MAApB,EAA4BC,WAA5B,EAAyC;AAC7DD,SAAO3J,KAAP,GAAe,KAAKqK,WAAL,CAAiBT,WAAjB,CAAf;AACAH,YAAU5K,IAAV,CAAeM,IAAf,CAAoB,KAAKO,UAAL,CAAgBiK,MAAhB,EAAwB,kBAAxB,CAApB;AACD,CAHD;;AAKApL,GAAGgL,YAAH,GAAkB,UAAS5K,IAAT,EAAeiK,WAAf,EAA4B;AAC5CjK,OAAK+J,EAAL,GAAU,KAAK5J,IAAL,KAAcC,iBAAGgB,IAAjB,GAAwB,KAAKwE,UAAL,EAAxB,GAA4CqE,cAAc,KAAK/G,UAAL,EAAd,GAAkC,IAAxF;AACD,CAFD;;AAIAtD,GAAGiL,eAAH,GAAqB,UAAS7K,IAAT,EAAe;AAClCA,OAAK2L,UAAL,GAAkB,KAAKtG,GAAL,CAASjF,iBAAGwL,QAAZ,IAAwB,KAAKC,mBAAL,EAAxB,GAAqD,IAAvE;AACD,CAFD;;AAIA;;AAEAjM,GAAGqF,WAAH,GAAiB,UAASjF,IAAT,EAAe;AAC9B,OAAKW,IAAL;AACA;AACA,MAAI,KAAK0E,GAAL,CAASjF,iBAAGiK,IAAZ,CAAJ,EAAuB;AACrB,SAAKyB,gBAAL,CAAsB,MAAtB;AACA9L,SAAK+L,MAAL,GAAc,KAAK5L,IAAL,KAAcC,iBAAG4L,MAAjB,GAA0B,KAAKC,aAAL,EAA1B,GAAiD,KAAK/I,UAAL,EAA/D;AACA,SAAK2C,SAAL;AACA,WAAO,KAAK9E,UAAL,CAAgBf,IAAhB,EAAsB,sBAAtB,CAAP;AACD;AACD,MAAI,KAAKqF,GAAL,CAASjF,iBAAG4H,QAAZ,CAAJ,EAA2B;AAAE;AAC3B,QAAIkE,SAAS,KAAK/L,IAAL,IAAaC,iBAAGiG,MAA7B;AACA,QAAIlB,OAAO,KAAK2E,gBAAL,EAAX;AACA,QAAIqC,YAAY,IAAhB;AACA,QAAI,CAACD,MAAD,KAAY/G,KAAKhF,IAAL,IAAa,oBAAb,IACAgF,KAAKhF,IAAL,IAAa,iBADzB,CAAJ,EACiD;AAC/CgM,kBAAY,KAAZ;AACA,UAAIhH,KAAK4E,EAAT,EAAa;AACX5E,aAAKhF,IAAL,GAAYgF,KAAKhF,IAAL,IAAa,oBAAb,GACR,qBADQ,GAER,kBAFJ;AAGD;AACF;AACDH,SAAKkC,WAAL,GAAmBiD,IAAnB;AACA,QAAIgH,SAAJ,EAAe,KAAKtG,SAAL;AACf,WAAO,KAAK9E,UAAL,CAAgBf,IAAhB,EAAsB,0BAAtB,CAAP;AACD;AACD;AACA,MAAI,KAAKoM,0BAAL,EAAJ,EAAuC;AACrCpM,SAAKkC,WAAL,GAAmB,KAAK3B,cAAL,CAAoB,IAApB,CAAnB;AACAP,SAAKqM,UAAL,GAAkB,EAAlB;AACArM,SAAK+L,MAAL,GAAc,IAAd;AACD,GAJD,MAIO;AAAE;AACP/L,SAAKkC,WAAL,GAAmB,IAAnB;AACAlC,SAAKqM,UAAL,GAAkB,KAAKC,qBAAL,EAAlB;AACA,QAAI,KAAKC,aAAL,CAAmB,MAAnB,CAAJ,EAAgC;AAC9BvM,WAAK+L,MAAL,GAAc,KAAK5L,IAAL,KAAcC,iBAAG4L,MAAjB,GAA0B,KAAKC,aAAL,EAA1B,GAAiD,KAAK/I,UAAL,EAA/D;AACD,KAFD,MAEO;AACL;AACA,WAAK,IAAI4C,IAAI,CAAb,EAAgBA,IAAI9F,KAAKqM,UAAL,CAAgBzK,MAApC,EAA4CkE,GAA5C,EAAiD;AAC/C,YAAI,KAAK0G,QAAL,CAAcrG,IAAd,CAAmBnG,KAAKqM,UAAL,CAAgBvG,CAAhB,EAAmB2G,KAAnB,CAAyBrL,IAA5C,KAAqD,KAAKsL,aAAL,CAAmBvG,IAAnB,CAAwBnG,KAAKqM,UAAL,CAAgBvG,CAAhB,EAAmB2G,KAAnB,CAAyBrL,IAAjD,CAAzD,EAAiH;AAC/G,eAAK8B,UAAL,CAAgBlD,KAAKqM,UAAL,CAAgBvG,CAAhB,EAAmB2G,KAAnB,CAAyB3H,KAAzC;AACD;AACF;;AAED9E,WAAK+L,MAAL,GAAc,IAAd;AACD;AACD,SAAKlG,SAAL;AACD;AACD,SAAO,KAAK9E,UAAL,CAAgBf,IAAhB,EAAsB,wBAAtB,CAAP;AACD,CAjDD;;AAmDAJ,GAAGwM,0BAAH,GAAgC,YAAW;AACzC,SAAO,KAAKjM,IAAL,CAAUuC,OAAV,IAAqB,KAAKvB,KAAL,EAA5B;AACD,CAFD;;AAIA;;AAEAvB,GAAG0M,qBAAH,GAA2B,YAAW;AACpC,MAAIK,QAAQ,EAAZ;AAAA,MAAgB1M,QAAQ,IAAxB;AACA;AACA,OAAKiG,MAAL,CAAY9F,iBAAGkE,MAAf;AACA,SAAO,CAAC,KAAKe,GAAL,CAASjF,iBAAG0H,MAAZ,CAAR,EAA6B;AAC3B,QAAI,CAAC7H,KAAL,EAAY;AACV,WAAKiG,MAAL,CAAY9F,iBAAG4J,KAAf;AACA,UAAI,KAAK4C,kBAAL,CAAwBxM,iBAAG0H,MAA3B,CAAJ,EAAwC;AACzC,KAHD,MAGO7H,QAAQ,KAAR;;AAEP,QAAID,OAAO,KAAKqC,SAAL,EAAX;AACArC,SAAKyM,KAAL,GAAa,KAAK7G,UAAL,CAAgB,KAAKzF,IAAL,KAAcC,iBAAG4H,QAAjC,CAAb;AACAhI,SAAK6M,QAAL,GAAgB,KAAKN,aAAL,CAAmB,IAAnB,IAA2B,KAAK3G,UAAL,CAAgB,IAAhB,CAA3B,GAAmD5F,KAAKyM,KAAxE;AACAE,UAAMnM,IAAN,CAAW,KAAKO,UAAL,CAAgBf,IAAhB,EAAsB,iBAAtB,CAAX;AACD;AACD,SAAO2M,KAAP;AACD,CAhBD;;AAkBA;;AAEA/M,GAAGoF,WAAH,GAAiB,UAAShF,IAAT,EAAe;AAC9B,OAAKW,IAAL;AACA;AACA,MAAI,KAAKR,IAAL,KAAcC,iBAAG4L,MAArB,EAA6B;AAC3BhM,SAAKqM,UAAL,GAAkB/D,KAAlB;AACAtI,SAAK+L,MAAL,GAAc,KAAKE,aAAL,EAAd;AACD,GAHD,MAGO;AACLjM,SAAKqM,UAAL,GAAkB,KAAKS,qBAAL,EAAlB;AACA,SAAKhB,gBAAL,CAAsB,MAAtB;AACA9L,SAAK+L,MAAL,GAAc,KAAK5L,IAAL,KAAcC,iBAAG4L,MAAjB,GAA0B,KAAKC,aAAL,EAA1B,GAAiD,KAAK/I,UAAL,EAA/D;AACD;AACD,OAAK2C,SAAL;AACA,SAAO,KAAK9E,UAAL,CAAgBf,IAAhB,EAAsB,mBAAtB,CAAP;AACD,CAbD;;AAeA;;AAEAJ,GAAGkN,qBAAH,GAA2B,YAAW;AACpC,MAAIH,QAAQ,EAAZ;AAAA,MAAgB1M,QAAQ,IAAxB;AACA,MAAI,KAAKE,IAAL,KAAcC,iBAAGgB,IAArB,EAA2B;AACzB;AACA,QAAIpB,OAAO,KAAKqC,SAAL,EAAX;AACArC,SAAKyM,KAAL,GAAa,KAAK7G,UAAL,EAAb;AACA,SAAKqB,SAAL,CAAejH,KAAKyM,KAApB,EAA2B,IAA3B;AACAE,UAAMnM,IAAN,CAAW,KAAKO,UAAL,CAAgBf,IAAhB,EAAsB,wBAAtB,CAAX;AACA,QAAI,CAAC,KAAKqF,GAAL,CAASjF,iBAAG4J,KAAZ,CAAL,EAAyB,OAAO2C,KAAP;AAC1B;AACD,MAAI,KAAKxM,IAAL,KAAcC,iBAAGiK,IAArB,EAA2B;AACzB,QAAIrK,QAAO,KAAKqC,SAAL,EAAX;AACA,SAAK1B,IAAL;AACA,SAAKmL,gBAAL,CAAsB,IAAtB;AACA9L,UAAKyM,KAAL,GAAa,KAAK7G,UAAL,EAAb;AACA,SAAKqB,SAAL,CAAejH,MAAKyM,KAApB,EAA2B,IAA3B;AACAE,UAAMnM,IAAN,CAAW,KAAKO,UAAL,CAAgBf,KAAhB,EAAsB,0BAAtB,CAAX;AACA,WAAO2M,KAAP;AACD;AACD,OAAKzG,MAAL,CAAY9F,iBAAGkE,MAAf;AACA,SAAO,CAAC,KAAKe,GAAL,CAASjF,iBAAG0H,MAAZ,CAAR,EAA6B;AAC3B,QAAI,CAAC7H,KAAL,EAAY;AACV,WAAKiG,MAAL,CAAY9F,iBAAG4J,KAAf;AACA,UAAI,KAAK4C,kBAAL,CAAwBxM,iBAAG0H,MAA3B,CAAJ,EAAwC;AACzC,KAHD,MAGO7H,QAAQ,KAAR;;AAEP,QAAID,SAAO,KAAKqC,SAAL,EAAX;AACArC,WAAK+M,QAAL,GAAgB,KAAKnH,UAAL,CAAgB,IAAhB,CAAhB;AACA,QAAI,KAAK2G,aAAL,CAAmB,IAAnB,CAAJ,EAA8B;AAC5BvM,aAAKyM,KAAL,GAAa,KAAK7G,UAAL,EAAb;AACD,KAFD,MAEO;AACL5F,aAAKyM,KAAL,GAAazM,OAAK+M,QAAlB;AACA,UAAI,KAAK9K,SAAL,CAAejC,OAAKyM,KAAL,CAAWrL,IAA1B,CAAJ,EAAqC,KAAK8B,UAAL,CAAgBlD,OAAKyM,KAAL,CAAW3H,KAA3B;AACrC,UAAI,KAAKkI,mBAAL,CAAyB7G,IAAzB,CAA8BnG,OAAKyM,KAAL,CAAWrL,IAAzC,CAAJ,EAAoD,KAAKyD,KAAL,CAAW7E,OAAKyM,KAAL,CAAW3H,KAAtB,EAA6B,kBAAkB9E,OAAKyM,KAAL,CAAWrL,IAA7B,GAAoC,eAAjE;AACrD;AACD,SAAK6F,SAAL,CAAejH,OAAKyM,KAApB,EAA2B,IAA3B;AACAE,UAAMnM,IAAN,CAAW,KAAKO,UAAL,CAAgBf,MAAhB,EAAsB,iBAAtB,CAAX;AACD;AACD,SAAO2M,KAAP;AACD,CAvCD","file":"statement.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {lineBreak, skipWhiteSpace} from \"./whitespace\"\nimport {isIdentifierStart, isIdentifierChar} from \"./identifier\"\nimport {DestructuringErrors} from \"./parseutil\"\n\nconst pp = Parser.prototype\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp.parseTopLevel = function(node) {\n  let first = true\n  if (!node.body) node.body = []\n  while (this.type !== tt.eof) {\n    let stmt = this.parseStatement(true, true)\n    node.body.push(stmt)\n    if (first) {\n      if (this.isUseStrict(stmt)) this.setStrict(true)\n      first = false\n    }\n  }\n  this.next()\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType\n  }\n  return this.finishNode(node, \"Program\")\n}\n\nconst loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"}\n\npp.isLet = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != \"let\") return false\n  skipWhiteSpace.lastIndex = this.pos\n  let skip = skipWhiteSpace.exec(this.input)\n  let next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)\n  if (nextCh === 91 || nextCh == 123) return true // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}\n    let ident = this.input.slice(next, pos)\n    if (!this.isKeyword(ident)) return true\n  }\n  return false\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp.parseStatement = function(declaration, topLevel) {\n  let starttype = this.type, node = this.startNode(), kind\n\n  if (this.isLet()) {\n    starttype = tt._var\n    kind = \"let\"\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case tt._debugger: return this.parseDebuggerStatement(node)\n  case tt._do: return this.parseDoStatement(node)\n  case tt._for: return this.parseForStatement(node)\n  case tt._function:\n    if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()\n    return this.parseFunctionStatement(node)\n  case tt._class:\n    if (!declaration) this.unexpected()\n    return this.parseClass(node, true)\n  case tt._if: return this.parseIfStatement(node)\n  case tt._return: return this.parseReturnStatement(node)\n  case tt._switch: return this.parseSwitchStatement(node)\n  case tt._throw: return this.parseThrowStatement(node)\n  case tt._try: return this.parseTryStatement(node)\n  case tt._const: case tt._var:\n    kind = kind || this.value\n    if (!declaration && kind != \"var\") this.unexpected()\n    return this.parseVarStatement(node, kind)\n  case tt._while: return this.parseWhileStatement(node)\n  case tt._with: return this.parseWithStatement(node)\n  case tt.braceL: return this.parseBlock()\n  case tt.semi: return this.parseEmptyStatement(node)\n  case tt._export:\n  case tt._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        this.raise(this.start, \"'import' and 'export' may only appear at the top level\")\n      if (!this.inModule)\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n    }\n    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    let maybeName = this.value, expr = this.parseExpression()\n    if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon))\n      return this.parseLabeledStatement(node, maybeName, expr)\n    else return this.parseExpressionStatement(node, expr)\n  }\n}\n\npp.parseBreakContinueStatement = function(node, keyword) {\n  let isBreak = keyword == \"break\"\n  this.next()\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null\n  else if (this.type !== tt.name) this.unexpected()\n  else {\n    node.label = this.parseIdent()\n    this.semicolon()\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  for (var i = 0; i < this.labels.length; ++i) {\n    let lab = this.labels[i]\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break\n      if (node.label && isBreak) break\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword)\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n}\n\npp.parseDebuggerStatement = function(node) {\n  this.next()\n  this.semicolon()\n  return this.finishNode(node, \"DebuggerStatement\")\n}\n\npp.parseDoStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  this.expect(tt._while)\n  node.test = this.parseParenExpression()\n  if (this.options.ecmaVersion >= 6)\n    this.eat(tt.semi)\n  else\n    this.semicolon()\n  return this.finishNode(node, \"DoWhileStatement\")\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp.parseForStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  this.expect(tt.parenL)\n  if (this.type === tt.semi) return this.parseFor(node, null)\n  let isLet = this.isLet()\n  if (this.type === tt._var || this.type === tt._const || isLet) {\n    let init = this.startNode(), kind = isLet ? \"let\" : this.value\n    this.next()\n    this.parseVar(init, true, kind)\n    this.finishNode(init, \"VariableDeclaration\")\n    if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init.declarations.length === 1 &&\n        !(kind !== \"var\" && init.declarations[0].init))\n      return this.parseForIn(node, init)\n    return this.parseFor(node, init)\n  }\n  let refDestructuringErrors = new DestructuringErrors\n  let init = this.parseExpression(true, refDestructuringErrors)\n  if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.checkPatternErrors(refDestructuringErrors, true)\n    this.toAssignable(init)\n    this.checkLVal(init)\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return this.parseFor(node, init)\n}\n\npp.parseFunctionStatement = function(node) {\n  this.next()\n  return this.parseFunction(node, true)\n}\n\npp.parseIfStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  node.consequent = this.parseStatement(false)\n  node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null\n  return this.finishNode(node, \"IfStatement\")\n}\n\npp.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    this.raise(this.start, \"'return' outside of function\")\n  this.next()\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null\n  else { node.argument = this.parseExpression(); this.semicolon() }\n  return this.finishNode(node, \"ReturnStatement\")\n}\n\npp.parseSwitchStatement = function(node) {\n  this.next()\n  node.discriminant = this.parseParenExpression()\n  node.cases = []\n  this.expect(tt.braceL)\n  this.labels.push(switchLabel)\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  for (var cur, sawDefault = false; this.type != tt.braceR;) {\n    if (this.type === tt._case || this.type === tt._default) {\n      let isCase = this.type === tt._case\n      if (cur) this.finishNode(cur, \"SwitchCase\")\n      node.cases.push(cur = this.startNode())\n      cur.consequent = []\n      this.next()\n      if (isCase) {\n        cur.test = this.parseExpression()\n      } else {\n        if (sawDefault) this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\")\n        sawDefault = true\n        cur.test = null\n      }\n      this.expect(tt.colon)\n    } else {\n      if (!cur) this.unexpected()\n      cur.consequent.push(this.parseStatement(true))\n    }\n  }\n  if (cur) this.finishNode(cur, \"SwitchCase\")\n  this.next() // Closing brace\n  this.labels.pop()\n  return this.finishNode(node, \"SwitchStatement\")\n}\n\npp.parseThrowStatement = function(node) {\n  this.next()\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\")\n  node.argument = this.parseExpression()\n  this.semicolon()\n  return this.finishNode(node, \"ThrowStatement\")\n}\n\n// Reused empty array added for node fields that are always empty.\n\nconst empty = []\n\npp.parseTryStatement = function(node) {\n  this.next()\n  node.block = this.parseBlock()\n  node.handler = null\n  if (this.type === tt._catch) {\n    let clause = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    clause.param = this.parseBindingAtom()\n    this.checkLVal(clause.param, true)\n    this.expect(tt.parenR)\n    clause.body = this.parseBlock()\n    node.handler = this.finishNode(clause, \"CatchClause\")\n  }\n  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null\n  if (!node.handler && !node.finalizer)\n    this.raise(node.start, \"Missing catch or finally clause\")\n  return this.finishNode(node, \"TryStatement\")\n}\n\npp.parseVarStatement = function(node, kind) {\n  this.next()\n  this.parseVar(node, false, kind)\n  this.semicolon()\n  return this.finishNode(node, \"VariableDeclaration\")\n}\n\npp.parseWhileStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"WhileStatement\")\n}\n\npp.parseWithStatement = function(node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\")\n  this.next()\n  node.object = this.parseParenExpression()\n  node.body = this.parseStatement(false)\n  return this.finishNode(node, \"WithStatement\")\n}\n\npp.parseEmptyStatement = function(node) {\n  this.next()\n  return this.finishNode(node, \"EmptyStatement\")\n}\n\npp.parseLabeledStatement = function(node, maybeName, expr) {\n  for (let i = 0; i < this.labels.length; ++i)\n    if (this.labels[i].name === maybeName) this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\")\n  let kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null\n  for (let i = this.labels.length - 1; i >= 0; i--) {\n    let label = this.labels[i]\n    if (label.statementStart == node.start) {\n      label.statementStart = this.start\n      label.kind = kind\n    } else break\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start})\n  node.body = this.parseStatement(true)\n  this.labels.pop()\n  node.label = expr\n  return this.finishNode(node, \"LabeledStatement\")\n}\n\npp.parseExpressionStatement = function(node, expr) {\n  node.expression = expr\n  this.semicolon()\n  return this.finishNode(node, \"ExpressionStatement\")\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp.parseBlock = function(allowStrict) {\n  let node = this.startNode(), first = true, oldStrict\n  node.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    let stmt = this.parseStatement(true)\n    node.body.push(stmt)\n    if (first && allowStrict && this.isUseStrict(stmt)) {\n      oldStrict = this.strict\n      this.setStrict(this.strict = true)\n    }\n    first = false\n  }\n  if (oldStrict === false) this.setStrict(false)\n  return this.finishNode(node, \"BlockStatement\")\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp.parseFor = function(node, init) {\n  node.init = init\n  this.expect(tt.semi)\n  node.test = this.type === tt.semi ? null : this.parseExpression()\n  this.expect(tt.semi)\n  node.update = this.type === tt.parenR ? null : this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"ForStatement\")\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp.parseForIn = function(node, init) {\n  let type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\"\n  this.next()\n  node.left = init\n  node.right = this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, type)\n}\n\n// Parse a list of variable declarations.\n\npp.parseVar = function(node, isFor, kind) {\n  node.declarations = []\n  node.kind = kind\n  for (;;) {\n    let decl = this.startNode()\n    this.parseVarId(decl)\n    if (this.eat(tt.eq)) {\n      decl.init = this.parseMaybeAssign(isFor)\n    } else if (kind === \"const\" && !(this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected()\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this.type === tt._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\")\n    } else {\n      decl.init = null\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"))\n    if (!this.eat(tt.comma)) break\n  }\n  return node\n}\n\npp.parseVarId = function(decl) {\n  decl.id = this.parseBindingAtom()\n  this.checkLVal(decl.id, true)\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseFunction = function(node, isStatement, allowExpressionBody) {\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = this.eat(tt.star)\n  var oldInGen = this.inGenerator\n  this.inGenerator = node.generator\n  if (isStatement || this.type === tt.name)\n    node.id = this.parseIdent()\n  this.parseFunctionParams(node)\n  this.parseFunctionBody(node, allowExpressionBody)\n  this.inGenerator = oldInGen\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n}\n\npp.parseFunctionParams = function(node) {\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, false, true)\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseClass = function(node, isStatement) {\n  this.next()\n  this.parseClassId(node, isStatement)\n  this.parseClassSuper(node)\n  let classBody = this.startNode()\n  let hadConstructor = false\n  classBody.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (this.eat(tt.semi)) continue\n    let method = this.startNode()\n    let isGenerator = this.eat(tt.star)\n    let isMaybeStatic = this.type === tt.name && this.value === \"static\"\n    this.parsePropertyName(method)\n    method.static = isMaybeStatic && this.type !== tt.parenL\n    if (method.static) {\n      if (isGenerator) this.unexpected()\n      isGenerator = this.eat(tt.star)\n      this.parsePropertyName(method)\n    }\n    method.kind = \"method\"\n    let isGetSet = false\n    if (!method.computed) {\n      let {key} = method\n      if (!isGenerator && key.type === \"Identifier\" && this.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true\n        method.kind = key.name\n        key = this.parsePropertyName(method)\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) this.raise(key.start, \"Duplicate constructor in the same class\")\n        if (isGetSet) this.raise(key.start, \"Constructor can't have get/set modifier\")\n        if (isGenerator) this.raise(key.start, \"Constructor can't be a generator\")\n        method.kind = \"constructor\"\n        hadConstructor = true\n      }\n    }\n    this.parseClassMethod(classBody, method, isGenerator)\n    if (isGetSet) {\n      let paramCount = method.kind === \"get\" ? 0 : 1\n      if (method.value.params.length !== paramCount) {\n        let start = method.value.start\n        if (method.kind === \"get\")\n          this.raiseRecoverable(start, \"getter should have no params\")\n        else\n          this.raiseRecoverable(start, \"setter should have exactly one param\")\n      }\n      if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n        this.raise(method.value.params[0].start, \"Setter cannot use rest params\")\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\")\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n}\n\npp.parseClassMethod = function(classBody, method, isGenerator) {\n  method.value = this.parseMethod(isGenerator)\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"))\n}\n\npp.parseClassId = function(node, isStatement) {\n  node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null\n}\n\npp.parseClassSuper = function(node) {\n  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null\n}\n\n// Parses module export declaration.\n\npp.parseExport = function(node) {\n  this.next()\n  // export * from '...'\n  if (this.eat(tt.star)) {\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    this.semicolon()\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(tt._default)) { // export default ...\n    let parens = this.type == tt.parenL\n    let expr = this.parseMaybeAssign()\n    let needsSemi = true\n    if (!parens && (expr.type == \"FunctionExpression\" ||\n                    expr.type == \"ClassExpression\")) {\n      needsSemi = false\n      if (expr.id) {\n        expr.type = expr.type == \"FunctionExpression\"\n          ? \"FunctionDeclaration\"\n          : \"ClassDeclaration\"\n      }\n    }\n    node.declaration = expr\n    if (needsSemi) this.semicolon()\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true)\n    node.specifiers = []\n    node.source = null\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null\n    node.specifiers = this.parseExportSpecifiers()\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    } else {\n      // check for keywords used as local names\n      for (let i = 0; i < node.specifiers.length; i++) {\n        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {\n          this.unexpected(node.specifiers[i].local.start)\n        }\n      }\n\n      node.source = null\n    }\n    this.semicolon()\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n}\n\npp.shouldParseExportStatement = function() {\n  return this.type.keyword || this.isLet()\n}\n\n// Parses a comma-separated list of module exports.\n\npp.parseExportSpecifiers = function() {\n  let nodes = [], first = true\n  // export { x, y as z } [from '...']\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let node = this.startNode()\n    node.local = this.parseIdent(this.type === tt._default)\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"))\n  }\n  return nodes\n}\n\n// Parses import declaration.\n\npp.parseImport = function(node) {\n  this.next()\n  // import '...'\n  if (this.type === tt.string) {\n    node.specifiers = empty\n    node.source = this.parseExprAtom()\n  } else {\n    node.specifiers = this.parseImportSpecifiers()\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n  }\n  this.semicolon()\n  return this.finishNode(node, \"ImportDeclaration\")\n}\n\n// Parses a comma-separated list of module imports.\n\npp.parseImportSpecifiers = function() {\n  let nodes = [], first = true\n  if (this.type === tt.name) {\n    // import defaultObj, { x, y as z } from '...'\n    let node = this.startNode()\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"))\n    if (!this.eat(tt.comma)) return nodes\n  }\n  if (this.type === tt.star) {\n    let node = this.startNode()\n    this.next()\n    this.expectContextual(\"as\")\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportNamespaceSpecifier\"))\n    return nodes\n  }\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let node = this.startNode()\n    node.imported = this.parseIdent(true)\n    if (this.eatContextual(\"as\")) {\n      node.local = this.parseIdent()\n    } else {\n      node.local = node.imported\n      if (this.isKeyword(node.local.name)) this.unexpected(node.local.start)\n      if (this.reservedWordsStrict.test(node.local.name)) this.raise(node.local.start, \"The keyword '\" + node.local.name + \"' is reserved\")\n    }\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportSpecifier\"))\n  }\n  return nodes\n}\n"]}