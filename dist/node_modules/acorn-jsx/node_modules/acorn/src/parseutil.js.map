{"version":3,"sources":["../../../../../../src/node_modules/acorn-jsx/node_modules/acorn/src/parseutil.js"],"names":["pp","Parser","prototype","isUseStrict","stmt","options","ecmaVersion","type","expression","raw","slice","eat","next","isContextual","name","tt","value","eatContextual","expectContextual","unexpected","canInsertSemicolon","eof","braceR","lineBreak","test","input","lastTokEnd","start","insertSemicolon","onInsertedSemicolon","lastTokEndLoc","semicolon","semi","afterTrailingComma","tokType","onTrailingComma","lastTokStart","lastTokStartLoc","expect","pos","raise","DestructuringErrors","shorthandAssign","trailingComma","checkPatternErrors","refDestructuringErrors","andThrow","trailing","checkExpressionErrors"],"mappings":"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","file":"parseutil.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {lineBreak} from \"./whitespace\"\n\nconst pp = Parser.prototype\n\n// ## Parser utilities\n\n// Test whether a statement node is the string literal `\"use strict\"`.\n\npp.isUseStrict = function(stmt) {\n  return this.options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n    stmt.expression.type === \"Literal\" &&\n    stmt.expression.raw.slice(1, -1) === \"use strict\"\n}\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next()\n    return true\n  } else {\n    return false\n  }\n}\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === tt.name && this.value === name\n}\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(tt.name)\n}\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) this.unexpected()\n}\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === tt.eof ||\n    this.type === tt.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n}\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)\n    return true\n  }\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()\n}\n\npp.afterTrailingComma = function(tokType) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)\n    this.next()\n    return true\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected()\n}\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\")\n}\n\nexport class DestructuringErrors {\n  constructor() {\n    this.shorthandAssign = 0\n    this.trailingComma = 0\n  }\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, andThrow) {\n  let trailing = refDestructuringErrors && refDestructuringErrors.trailingComma\n  if (!andThrow) return !!trailing\n  if (trailing) this.raise(trailing, \"Comma is not permitted after the rest element\")\n}\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  let pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign\n  if (!andThrow) return !!pos\n  if (pos) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\")\n}\n"]}