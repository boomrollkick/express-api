{"version":3,"sources":["../../../../../../../src/node_modules/acorn-jsx/node_modules/acorn/src/walk/index.js"],"names":["simple","ancestor","recursive","findNodeAt","findNodeAround","findNodeAfter","findNodeBefore","make","node","visitors","base","state","override","exports","c","st","type","found","ancestors","isNew","length","push","pop","funcs","visitor","makeTest","test","Found","start","end","e","pos","max","create","Object","proto","Ctor","prototype","skipThrough","ignore","_node","_st","_c","Program","BlockStatement","i","body","Statement","EmptyStatement","ExpressionStatement","ParenthesizedExpression","expression","IfStatement","consequent","alternate","LabeledStatement","BreakStatement","ContinueStatement","WithStatement","object","SwitchStatement","discriminant","cases","cs","j","ReturnStatement","YieldExpression","argument","ThrowStatement","SpreadElement","TryStatement","block","handler","finalizer","CatchClause","param","WhileStatement","DoWhileStatement","ForStatement","init","update","ForInStatement","ForOfStatement","left","right","ForInit","DebuggerStatement","FunctionDeclaration","VariableDeclaration","declarations","VariableDeclarator","id","Function","params","ScopeBody","ScopeExpression","Pattern","VariablePattern","MemberPattern","RestElement","ArrayPattern","elements","elt","ObjectPattern","properties","value","Expression","ThisExpression","Super","MetaProperty","ArrayExpression","ObjectExpression","FunctionExpression","ArrowFunctionExpression","SequenceExpression","TemplateLiteral","expressions","UnaryExpression","UpdateExpression","BinaryExpression","LogicalExpression","AssignmentExpression","AssignmentPattern","ConditionalExpression","NewExpression","CallExpression","callee","arguments","MemberExpression","computed","property","ExportNamedDeclaration","ExportDefaultDeclaration","declaration","source","ExportAllDeclaration","ImportDeclaration","specifiers","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","Identifier","Literal","TaggedTemplateExpression","tag","quasi","ClassDeclaration","ClassExpression","Class","superClass","MethodDefinition","Property","key"],"mappings":"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","file":"index.js","sourcesContent":["// AST walker module for Mozilla Parser API compatible trees\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression,\n// Statement, and ScopeBody, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n\nexport function simple(node, visitors, base, state, override) {\n  if (!base) base = exports.base\n  ;(function c(node, st, override) {\n    let type = override || node.type, found = visitors[type]\n    base[type](node, st, c)\n    if (found) found(node, st)\n  })(node, state, override)\n}\n\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\nexport function ancestor(node, visitors, base, state) {\n  if (!base) base = exports.base\n  let ancestors = []\n  ;(function c(node, st, override) {\n    let type = override || node.type, found = visitors[type]\n    let isNew = node != ancestors[ancestors.length - 1]\n    if (isNew) ancestors.push(node)\n    base[type](node, st, c)\n    if (found) found(node, st || ancestors, ancestors)\n    if (isNew) ancestors.pop()\n  })(node, state)\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nexport function recursive(node, state, funcs, base, override) {\n  let visitor = funcs ? exports.make(funcs, base) : base\n  ;(function c(node, st, override) {\n    visitor[override || node.type](node, st, c)\n  })(node, state, override)\n}\n\nfunction makeTest(test) {\n  if (typeof test == \"string\")\n    return type => type == test\n  else if (!test)\n    return () => true\n  else\n    return test\n}\n\nclass Found {\n  constructor(node, state) { this.node = node; this.state = state }\n}\n\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nexport function findNodeAt(node, start, end, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  try {\n    ;(function c(node, st, override) {\n      let type = override || node.type\n      if ((start == null || node.start <= start) &&\n          (end == null || node.end >= end))\n        base[type](node, st, c)\n      if ((start == null || node.start == start) &&\n          (end == null || node.end == end) &&\n          test(type, node))\n        throw new Found(node, st)\n    })(node, state)\n  } catch (e) {\n    if (e instanceof Found) return e\n    throw e\n  }\n}\n\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nexport function findNodeAround(node, pos, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  try {\n    ;(function c(node, st, override) {\n      let type = override || node.type\n      if (node.start > pos || node.end < pos) return\n      base[type](node, st, c)\n      if (test(type, node)) throw new Found(node, st)\n    })(node, state)\n  } catch (e) {\n    if (e instanceof Found) return e\n    throw e\n  }\n}\n\n// Find the outermost matching node after a given position.\nexport function findNodeAfter(node, pos, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  try {\n    ;(function c(node, st, override) {\n      if (node.end < pos) return\n      let type = override || node.type\n      if (node.start >= pos && test(type, node)) throw new Found(node, st)\n      base[type](node, st, c)\n    })(node, state)\n  } catch (e) {\n    if (e instanceof Found) return e\n    throw e\n  }\n}\n\n// Find the outermost matching node before a given position.\nexport function findNodeBefore(node, pos, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  let max\n  ;(function c(node, st, override) {\n    if (node.start > pos) return\n    let type = override || node.type\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n      max = new Found(node, st)\n    base[type](node, st, c)\n  })(node, state)\n  return max\n}\n\n// Fallback to an Object.create polyfill for older environments.\nconst create = Object.create || function(proto) {\n  function Ctor() {}\n  Ctor.prototype = proto\n  return new Ctor\n}\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nexport function make(funcs, base) {\n  if (!base) base = exports.base\n  let visitor = create(base)\n  for (var type in funcs) visitor[type] = funcs[type]\n  return visitor\n}\n\nfunction skipThrough(node, st, c) { c(node, st) }\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nexport const base = {}\n\nbase.Program = base.BlockStatement = (node, st, c) => {\n  for (let i = 0; i < node.body.length; ++i)\n    c(node.body[i], st, \"Statement\")\n}\nbase.Statement = skipThrough\nbase.EmptyStatement = ignore\nbase.ExpressionStatement = base.ParenthesizedExpression =\n  (node, st, c) => c(node.expression, st, \"Expression\")\nbase.IfStatement = (node, st, c) => {\n  c(node.test, st, \"Expression\")\n  c(node.consequent, st, \"Statement\")\n  if (node.alternate) c(node.alternate, st, \"Statement\")\n}\nbase.LabeledStatement = (node, st, c) => c(node.body, st, \"Statement\")\nbase.BreakStatement = base.ContinueStatement = ignore\nbase.WithStatement = (node, st, c) => {\n  c(node.object, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.SwitchStatement = (node, st, c) => {\n  c(node.discriminant, st, \"Expression\")\n  for (let i = 0; i < node.cases.length; ++i) {\n    let cs = node.cases[i]\n    if (cs.test) c(cs.test, st, \"Expression\")\n    for (let j = 0; j < cs.consequent.length; ++j)\n      c(cs.consequent[j], st, \"Statement\")\n  }\n}\nbase.ReturnStatement = base.YieldExpression = (node, st, c) => {\n  if (node.argument) c(node.argument, st, \"Expression\")\n}\nbase.ThrowStatement = base.SpreadElement =\n  (node, st, c) => c(node.argument, st, \"Expression\")\nbase.TryStatement = (node, st, c) => {\n  c(node.block, st, \"Statement\")\n  if (node.handler) c(node.handler, st)\n  if (node.finalizer) c(node.finalizer, st, \"Statement\")\n}\nbase.CatchClause = (node, st, c) => {\n  c(node.param, st, \"Pattern\")\n  c(node.body, st, \"ScopeBody\")\n}\nbase.WhileStatement = base.DoWhileStatement = (node, st, c) => {\n  c(node.test, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.ForStatement = (node, st, c) => {\n  if (node.init) c(node.init, st, \"ForInit\")\n  if (node.test) c(node.test, st, \"Expression\")\n  if (node.update) c(node.update, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.ForInStatement = base.ForOfStatement = (node, st, c) => {\n  c(node.left, st, \"ForInit\")\n  c(node.right, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.ForInit = (node, st, c) => {\n  if (node.type == \"VariableDeclaration\") c(node, st)\n  else c(node, st, \"Expression\")\n}\nbase.DebuggerStatement = ignore\n\nbase.FunctionDeclaration = (node, st, c) => c(node, st, \"Function\")\nbase.VariableDeclaration = (node, st, c) => {\n  for (let i = 0; i < node.declarations.length; ++i)\n    c(node.declarations[i], st)\n}\nbase.VariableDeclarator = (node, st, c) => {\n  c(node.id, st, \"Pattern\")\n  if (node.init) c(node.init, st, \"Expression\")\n}\n\nbase.Function = (node, st, c) => {\n  if (node.id) c(node.id, st, \"Pattern\")\n  for (let i = 0; i < node.params.length; i++)\n    c(node.params[i], st, \"Pattern\")\n  c(node.body, st, node.expression ? \"ScopeExpression\" : \"ScopeBody\")\n}\n// FIXME drop these node types in next major version\n// (They are awkward, and in ES6 every block can be a scope.)\nbase.ScopeBody = (node, st, c) => c(node, st, \"Statement\")\nbase.ScopeExpression = (node, st, c) => c(node, st, \"Expression\")\n\nbase.Pattern = (node, st, c) => {\n  if (node.type == \"Identifier\")\n    c(node, st, \"VariablePattern\")\n  else if (node.type == \"MemberExpression\")\n    c(node, st, \"MemberPattern\")\n  else\n    c(node, st)\n}\nbase.VariablePattern = ignore\nbase.MemberPattern = skipThrough\nbase.RestElement = (node, st, c) => c(node.argument, st, \"Pattern\")\nbase.ArrayPattern =  (node, st, c) => {\n  for (let i = 0; i < node.elements.length; ++i) {\n    let elt = node.elements[i]\n    if (elt) c(elt, st, \"Pattern\")\n  }\n}\nbase.ObjectPattern = (node, st, c) => {\n  for (let i = 0; i < node.properties.length; ++i)\n    c(node.properties[i].value, st, \"Pattern\")\n}\n\nbase.Expression = skipThrough\nbase.ThisExpression = base.Super = base.MetaProperty = ignore\nbase.ArrayExpression = (node, st, c) => {\n  for (let i = 0; i < node.elements.length; ++i) {\n    let elt = node.elements[i]\n    if (elt) c(elt, st, \"Expression\")\n  }\n}\nbase.ObjectExpression = (node, st, c) => {\n  for (let i = 0; i < node.properties.length; ++i)\n    c(node.properties[i], st)\n}\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration\nbase.SequenceExpression = base.TemplateLiteral = (node, st, c) => {\n  for (let i = 0; i < node.expressions.length; ++i)\n    c(node.expressions[i], st, \"Expression\")\n}\nbase.UnaryExpression = base.UpdateExpression = (node, st, c) => {\n  c(node.argument, st, \"Expression\")\n}\nbase.BinaryExpression = base.LogicalExpression = (node, st, c) => {\n  c(node.left, st, \"Expression\")\n  c(node.right, st, \"Expression\")\n}\nbase.AssignmentExpression = base.AssignmentPattern = (node, st, c) => {\n  c(node.left, st, \"Pattern\")\n  c(node.right, st, \"Expression\")\n}\nbase.ConditionalExpression = (node, st, c) => {\n  c(node.test, st, \"Expression\")\n  c(node.consequent, st, \"Expression\")\n  c(node.alternate, st, \"Expression\")\n}\nbase.NewExpression = base.CallExpression = (node, st, c) => {\n  c(node.callee, st, \"Expression\")\n  if (node.arguments) for (let i = 0; i < node.arguments.length; ++i)\n    c(node.arguments[i], st, \"Expression\")\n}\nbase.MemberExpression = (node, st, c) => {\n  c(node.object, st, \"Expression\")\n  if (node.computed) c(node.property, st, \"Expression\")\n}\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = (node, st, c) => {\n  if (node.declaration)\n    c(node.declaration, st, node.type == \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\")\n  if (node.source) c(node.source, st, \"Expression\")\n}\nbase.ExportAllDeclaration = (node, st, c) => {\n  c(node.source, st, \"Expression\")\n}\nbase.ImportDeclaration = (node, st, c) => {\n  for (let i = 0; i < node.specifiers.length; i++)\n    c(node.specifiers[i], st)\n  c(node.source, st, \"Expression\")\n}\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore\n\nbase.TaggedTemplateExpression = (node, st, c) => {\n  c(node.tag, st, \"Expression\")\n  c(node.quasi, st)\n}\nbase.ClassDeclaration = base.ClassExpression = (node, st, c) => c(node, st, \"Class\")\nbase.Class = (node, st, c) => {\n  if (node.id) c(node.id, st, \"Pattern\")\n  if (node.superClass) c(node.superClass, st, \"Expression\")\n  for (let i = 0; i < node.body.body.length; i++)\n    c(node.body.body[i], st)\n}\nbase.MethodDefinition = base.Property = (node, st, c) => {\n  if (node.computed) c(node.key, st, \"Expression\")\n  c(node.value, st, \"Expression\")\n}\n"]}