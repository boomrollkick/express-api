{"version":3,"sources":["../../../../../../../src/node_modules/acorn-jsx/node_modules/acorn/src/loose/tokenize.js"],"names":["lp","LooseParser","prototype","isSpace","ch","next","last","tok","ahead","length","shift","readToken","start","nextLineStart","curLineStart","lineEnd","curIndent","indentationAfter","toks","type","tt","dot","input","substr","end","options","ecmaVersion","ellipsis","Token","e","SyntaxError","msg","message","pos","raisedAt","replace","test","string","value","slice","re","RegExp","regexp","template","charCodeAt","resetTo","name","locations","loc","SourceLocation","charAt","exprAllowed","curLine","lineStart","lineBreakG","lastIndex","match","exec","index","lookAhead","n","push"],"mappings":"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","file":"tokenize.js","sourcesContent":["import {tokTypes as tt, Token, isNewLine, SourceLocation, getLineInfo, lineBreakG} from \"acorn\"\nimport {LooseParser} from \"./state\"\n\nconst lp = LooseParser.prototype\n\nfunction isSpace(ch) {\n  return (ch < 14 && ch > 8) || ch === 32 || ch === 160 || isNewLine(ch)\n}\n\nlp.next = function() {\n  this.last = this.tok\n  if (this.ahead.length)\n    this.tok = this.ahead.shift()\n  else\n    this.tok = this.readToken()\n\n  if (this.tok.start >= this.nextLineStart) {\n    while (this.tok.start >= this.nextLineStart) {\n      this.curLineStart = this.nextLineStart\n      this.nextLineStart = this.lineEnd(this.curLineStart) + 1\n    }\n    this.curIndent = this.indentationAfter(this.curLineStart)\n  }\n}\n\nlp.readToken = function() {\n  for (;;) {\n    try {\n      this.toks.next()\n      if (this.toks.type === tt.dot &&\n          this.input.substr(this.toks.end, 1) === \".\" &&\n          this.options.ecmaVersion >= 6) {\n        this.toks.end++\n        this.toks.type = tt.ellipsis\n      }\n      return new Token(this.toks)\n    } catch(e) {\n      if (!(e instanceof SyntaxError)) throw e\n\n      // Try to skip some text, based on the error message, and then continue\n      let msg = e.message, pos = e.raisedAt, replace = true\n      if (/unterminated/i.test(msg)) {\n        pos = this.lineEnd(e.pos + 1)\n        if (/string/.test(msg)) {\n          replace = {start: e.pos, end: pos, type: tt.string, value: this.input.slice(e.pos + 1, pos)}\n        } else if (/regular expr/i.test(msg)) {\n          let re = this.input.slice(e.pos, pos)\n          try { re = new RegExp(re) } catch(e) {}\n          replace = {start: e.pos, end: pos, type: tt.regexp, value: re}\n        } else if (/template/.test(msg)) {\n          replace = {start: e.pos, end: pos,\n                     type: tt.template,\n                     value: this.input.slice(e.pos, pos)}\n        } else {\n          replace = false\n        }\n      } else if (/invalid (unicode|regexp|number)|expecting unicode|octal literal|is reserved|directly after number|expected number in radix/i.test(msg)) {\n        while (pos < this.input.length && !isSpace(this.input.charCodeAt(pos))) ++pos\n      } else if (/character escape|expected hexadecimal/i.test(msg)) {\n        while (pos < this.input.length) {\n          let ch = this.input.charCodeAt(pos++)\n          if (ch === 34 || ch === 39 || isNewLine(ch)) break\n        }\n      } else if (/unexpected character/i.test(msg)) {\n        pos++\n        replace = false\n      } else if (/regular expression/i.test(msg)) {\n        replace = true\n      } else {\n        throw e\n      }\n      this.resetTo(pos)\n      if (replace === true) replace = {start: pos, end: pos, type: tt.name, value: \"âœ–\"}\n      if (replace) {\n        if (this.options.locations)\n          replace.loc = new SourceLocation(\n            this.toks,\n            getLineInfo(this.input, replace.start),\n            getLineInfo(this.input, replace.end))\n        return replace\n      }\n    }\n  }\n}\n\nlp.resetTo = function(pos) {\n  this.toks.pos = pos\n  let ch = this.input.charAt(pos - 1)\n  this.toks.exprAllowed = !ch || /[\\[\\{\\(,;:?\\/*=+\\-~!|&%^<>]/.test(ch) ||\n    /[enwfd]/.test(ch) &&\n    /\\b(keywords|case|else|return|throw|new|in|(instance|type)of|delete|void)$/.test(this.input.slice(pos - 10, pos))\n\n  if (this.options.locations) {\n    this.toks.curLine = 1\n    this.toks.lineStart = lineBreakG.lastIndex = 0\n    let match\n    while ((match = lineBreakG.exec(this.input)) && match.index < pos) {\n      ++this.toks.curLine\n      this.toks.lineStart = match.index + match[0].length\n    }\n  }\n}\n\nlp.lookAhead = function(n) {\n  while (n > this.ahead.length)\n    this.ahead.push(this.readToken())\n  return this.ahead[n - 1]\n}\n"]}